{
  "id": "ALAS2-2025-2964",
  "title": "Amazon Linux 2 2017.12 - ALAS2-2025-2964: medium priority package update for gstreamer1-plugins-good",
  "issued": {
    "date": "2025-08-05 23:18:00"
  },
  "updated": {
    "date": "2025-08-19 10:51:00"
  },
  "severity": "medium",
  "description": "Package updates are available for Amazon Linux 2 that fix the following vulnerabilities:\nCVE-2024-47834:\n\tGStreamer is a library for constructing graphs of media-handling components. An Use-After-Free read vulnerability has been discovered affecting the processing of CodecPrivate elements in Matroska streams. In the GST_MATROSKA_ID_CODECPRIVATE case within the gst_matroska_demux_parse_stream function, a data chunk is allocated using gst_ebml_read_binary. Later, the allocated memory is freed in the gst_matroska_track_free function, by the call to g_free (track-\u003ecodec_priv). Finally, the freed memory is accessed in the caps_serialize function through gst_value_serialize_buffer. The freed memory will be accessed in the gst_value_serialize_buffer function. This results in a UAF read vulnerability, as the function tries to process memory that has already been freed. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47778:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read vulnerability has been discovered in gst_wavparse_adtl_chunk within gstwavparse.c. This vulnerability arises due to insufficient validation of the size parameter, which can exceed the bounds of the data buffer. As a result, an OOB read occurs in the following while loop. This vulnerability can result in reading up to 4GB of process memory or potentially causing a segmentation fault (SEGV) when accessing invalid memory. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47777:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read vulnerability has been identified in the gst_wavparse_smpl_chunk function within gstwavparse.c. This function attempts to read 4 bytes from the data + 12 offset without checking if the size of the data buffer is sufficient. If the buffer is too small, the function reads beyond its bounds. This vulnerability may result in reading 4 bytes out of the boundaries of the data buffer. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47776:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read has been discovered in gst_wavparse_cue_chunk within gstwavparse.c. The vulnerability happens due to a discrepancy between the size of the data buffer and the size value provided to the function. This mismatch causes the comparison  if (size \u003c 4 + ncues * 24) to fail in some cases, allowing the subsequent loop to access beyond the bounds of the data buffer. The root cause of this discrepancy stems from a miscalculation when clipping the chunk size based on upstream data size. This vulnerability allows reading beyond the bounds of the data buffer, potentially leading to a crash (denial of service) or the leak of sensitive data. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47775:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read vulnerability has been found in the parse_ds64 function within gstwavparse.c. The parse_ds64 function does not check that the buffer buf contains sufficient data before attempting to read from it, doing multiple GST_READ_UINT32_LE operations without performing boundary checks. This can lead to an OOB-read when buf is smaller than expected. This vulnerability allows reading beyond the bounds of the data buffer, potentially leading to a crash (denial of service) or the leak of sensitive data. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47774:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read vulnerability has been identified in the gst_avi_subtitle_parse_gab2_chunk function within gstavisubtitle.c. The function reads the name_length value directly from the input file without checking it properly. Then, the a condition, does not properly handle cases where name_length is greater than 0xFFFFFFFF - 17, causing an integer overflow. In such scenario, the function attempts to access memory beyond the buffer leading to an OOB-read. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47603:\n\tGStreamer is a library for constructing graphs of media-handling components. A null pointer dereference vulnerability has been discovered in the gst_matroska_demux_update_tracks function within matroska-demux.c. The vulnerability occurs when the gst_caps_is_equal function is called with invalid caps values. If this happen, then in the function gst_buffer_get_size the call to GST_BUFFER_MEM_PTR can return a null pointer. Attempting to dereference the size field of this null pointer results in a null pointer dereference. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47602:\n\tGStreamer is a library for constructing graphs of media-handling components. A null pointer dereference vulnerability has been discovered in the gst_matroska_demux_add_wvpk_header function within matroska-demux.c. This function does not properly check the validity of the stream-\u003ecodec_priv pointer in the following code. If stream-\u003ecodec_priv is NULL, the call to GST_READ_UINT16_LE will attempt to dereference a null pointer, leading to a crash of the application. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47601:\n\tGStreamer is a library for constructing graphs of media-handling components. A null pointer dereference vulnerability has been discovered in the gst_matroska_demux_parse_blockgroup_or_simpleblock function within matroska-demux.c. This function does not properly check the validity of the GstBuffer *sub pointer before performing dereferences. As a result, null pointer dereferences may occur. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47599:\n\tGStreamer is a library for constructing graphs of media-handling components. A null pointer dereference vulnerability has been discovered in the gst_jpeg_dec_negotiate function in gstjpegdec.c. This function does not check for a NULL return value from gst_video_decoder_set_output_state. When this happens, dereferences of the outstate pointer will lead to a null pointer dereference. This vulnerability can result in a Denial of Service (DoS) by triggering a segmentation fault (SEGV). This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47598:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read vulnerability has been discovered in the qtdemux_merge_sample_table function within qtdemux.c. The problem is that the size of the stts buffer isn't properly checked before reading stts_duration, allowing the program to read 4 bytes beyond the boundaries of stts-\u003edata. This vulnerability reads up to 4 bytes past the allocated bounds of the stts array. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47597:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read has been detected in the function qtdemux_parse_samples within qtdemux.c. This issue arises when the function qtdemux_parse_samples reads data beyond the boundaries of the stream-\u003estco buffer. The following code snippet shows the call to qt_atom_parser_get_offset_unchecked, which leads to the OOB-read when parsing the provided GHSL-2024-245_crash1.mp4 file. This issue may lead to read up to 8 bytes out-of-bounds. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47596:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read has been discovered in the qtdemux_parse_svq3_stsd_data function within qtdemux.c. In the FOURCC_SMI_ case, seqh_size is read from the input file without proper validation. If seqh_size is greater than the remaining size of the data buffer, it can lead to an OOB-read in the following call to gst_buffer_fill, which internally uses memcpy. This vulnerability can result in reading up to 4GB of process memory or potentially causing a segmentation fault (SEGV) when accessing invalid memory. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47546:\n\tGStreamer is a library for constructing graphs of media-handling components. An integer underflow has been detected in extract_cc_from_data function within qtdemux.c. In the FOURCC_c708 case, the subtraction atom_length - 8 may result in an underflow if atom_length is less than 8. When that subtraction underflows, *cclen ends up being a large number, and then cclen is passed to g_memdup2 leading to an out-of-bounds (OOB) read. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47545:\n\tGStreamer is a library for constructing graphs of media-handling components. An integer underflow has been detected in qtdemux_parse_trak function within qtdemux.c. During the strf parsing case, the subtraction size -= 40 can lead to a negative integer overflow if it is less than 40. If this happens, the subsequent call to gst_buffer_fill will invoke memcpy with a large tocopy size, resulting in an OOB-read. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47543:\n\tGStreamer is a library for constructing graphs of media-handling components. An OOB-read vulnerability has been discovered in qtdemux_parse_container function within qtdemux.c. In the parent function qtdemux_parse_node, the value of length is not well checked. So, if length is big enough, it causes the pointer end to point beyond the boundaries of buffer. Subsequently, in the qtdemux_parse_container function, the while loop can trigger an OOB-read, accessing memory beyond the bounds of buf. This vulnerability can result in reading up to 4GB of process memory or potentially causing a segmentation fault (SEGV) when accessing invalid memory. This vulnerability is fixed in 1.24.10.\n\nCVE-2024-47539:\n\tGStreamer is a library for constructing graphs of media-handling components. An out-of-bounds write vulnerability was identified in the convert_to_s334_1a function in isomp4/qtdemux.c. The vulnerability arises due to a discrepancy between the size of memory allocated to the storage array and the loop condition i * 2 \u003c ccpair_size. Specifically, when ccpair_size is even, the allocated size in storage does not match the loop's expected bounds, resulting in an out-of-bounds write. This bug allows for the overwriting of up to 3 bytes beyond the allocated bounds of the storage array. This vulnerability is fixed in 1.24.10.\n\nCVE-2021-3498:\n\tGStreamer before 1.18.4 might cause heap corruption when parsing certain malformed Matroska files.\n",
  "packages": [
    {
      "name": "gstreamer1-plugins-good",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "x86_64",
      "filename": "Packages/gstreamer1-plugins-good-1.18.4-6.amzn2.0.7.x86_64.rpm"
    },
    {
      "name": "gstreamer1-plugins-good-gtk",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "x86_64",
      "filename": "Packages/gstreamer1-plugins-good-gtk-1.18.4-6.amzn2.0.7.x86_64.rpm"
    },
    {
      "name": "gstreamer1-plugins-good-debuginfo",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "x86_64",
      "filename": "Packages/gstreamer1-plugins-good-debuginfo-1.18.4-6.amzn2.0.7.x86_64.rpm"
    },
    {
      "name": "gstreamer1-plugins-good",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "i686",
      "filename": "Packages/gstreamer1-plugins-good-1.18.4-6.amzn2.0.7.i686.rpm"
    },
    {
      "name": "gstreamer1-plugins-good-gtk",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "i686",
      "filename": "Packages/gstreamer1-plugins-good-gtk-1.18.4-6.amzn2.0.7.i686.rpm"
    },
    {
      "name": "gstreamer1-plugins-good-debuginfo",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "i686",
      "filename": "Packages/gstreamer1-plugins-good-debuginfo-1.18.4-6.amzn2.0.7.i686.rpm"
    },
    {
      "name": "gstreamer1-plugins-good",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "aarch64",
      "filename": "Packages/gstreamer1-plugins-good-1.18.4-6.amzn2.0.7.aarch64.rpm"
    },
    {
      "name": "gstreamer1-plugins-good-gtk",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "aarch64",
      "filename": "Packages/gstreamer1-plugins-good-gtk-1.18.4-6.amzn2.0.7.aarch64.rpm"
    },
    {
      "name": "gstreamer1-plugins-good-debuginfo",
      "epoch": "0",
      "version": "1.18.4",
      "release": "6.amzn2.0.7",
      "arch": "aarch64",
      "filename": "Packages/gstreamer1-plugins-good-debuginfo-1.18.4-6.amzn2.0.7.aarch64.rpm"
    }
  ],
  "references": [
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3498",
      "id": "CVE-2021-3498",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47539",
      "id": "CVE-2024-47539",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47543",
      "id": "CVE-2024-47543",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47545",
      "id": "CVE-2024-47545",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47546",
      "id": "CVE-2024-47546",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47596",
      "id": "CVE-2024-47596",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47597",
      "id": "CVE-2024-47597",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47598",
      "id": "CVE-2024-47598",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47599",
      "id": "CVE-2024-47599",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47601",
      "id": "CVE-2024-47601",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47602",
      "id": "CVE-2024-47602",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47603",
      "id": "CVE-2024-47603",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47774",
      "id": "CVE-2024-47774",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47775",
      "id": "CVE-2024-47775",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47776",
      "id": "CVE-2024-47776",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47777",
      "id": "CVE-2024-47777",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47778",
      "id": "CVE-2024-47778",
      "type": "cve"
    },
    {
      "href": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47834",
      "id": "CVE-2024-47834",
      "type": "cve"
    }
  ],
  "cveids": [
    "CVE-2021-3498",
    "CVE-2024-47539",
    "CVE-2024-47543",
    "CVE-2024-47545",
    "CVE-2024-47546",
    "CVE-2024-47596",
    "CVE-2024-47597",
    "CVE-2024-47598",
    "CVE-2024-47599",
    "CVE-2024-47601",
    "CVE-2024-47602",
    "CVE-2024-47603",
    "CVE-2024-47774",
    "CVE-2024-47775",
    "CVE-2024-47776",
    "CVE-2024-47777",
    "CVE-2024-47778",
    "CVE-2024-47834"
  ]
}