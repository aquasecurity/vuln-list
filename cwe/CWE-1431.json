{
 "Description": "The product uses a hardware module implementing a cryptographic\n\t\t  algorithm that writes sensitive information about the intermediate\n\t\t  state or results of its cryptographic operations via one of its output\n\t\t  wires (typically the output port containing the final result).",
 "ExtendedDescription": null,
 "RelatedWeaknesses": {
  "RelatedWeakness": [
   {
    "Nature": "ChildOf",
    "CWEID": 200,
    "ViewID": 1000,
    "ChainID": 0,
    "Ordinal": "Primary"
   },
   {
    "Nature": "PeerOf",
    "CWEID": 497,
    "ViewID": 1000,
    "ChainID": 0,
    "Ordinal": ""
   }
  ]
 },
 "WeaknessOrdinalities": {
  "WeaknessOrdinality": null
 },
 "ApplicablePlatforms": {
  "Language": [
   {
    "Name": "",
    "Class": "Not Language-Specific",
    "Prevalence": "Undetermined"
   }
  ],
  "OperatingSystem": null,
  "Architecture": [
   {
    "Name": "",
    "Class": "Not Architecture-Specific",
    "Prevalence": "Undetermined"
   }
  ],
  "Technology": [
   {
    "Name": "",
    "Class": "System on Chip",
    "Prevalence": "Undetermined"
   }
  ]
 },
 "BackgroundDetails": {
  "BackgroundDetail": null
 },
 "AlternateTerms": {
  "AlternateTerm": null
 },
 "ModesOfIntroduction": {
  "Introduction": [
   {
    "Phase": "Implementation",
    "Note": [
     "This can occur when intermediate cryptographic states are\n\t\t      directly assigned to output wires or ports."
    ]
   }
  ]
 },
 "ExploitationFactors": {
  "ExploitationFactor": null
 },
 "LikelihoodOfExploit": "",
 "CommonConsequences": {
  "Consequence": [
   {
    "Scope": [
     "Confidentiality"
    ],
    "Impact": [
     "Read Memory",
     "Read Application Data"
    ],
    "Likelihood": "Unknown",
    "Note": [
     "Mathematically sound cryptographic algorithms rely on their\n\t\t\t    correct implementation for security. These assumptions might break when a\n\t\t\t    hardware crypto module leaks intermediate encryption states or results\n\t\t\t    such that they can be observed by an adversary. If intermediate state\n\t\t\t    is observed, it might be possible for an attacker to identify the\n\t\t\t    secrets used in the cryptographic operation."
    ],
    "ConsequenceID": ""
   }
  ]
 },
 "DetectionMethods": {
  "DetectionMethod": [
   {
    "Method": "Automated Static Analysis - Source Code",
    "Description": [
     "Automated static analysis can find some instances of this\n\t\t\t    weakness by analyzing source register-transfer level (RTL) code\n\t\t\t    without having to simulate it or analyze it with a formal verification\n\t\t\t    engine. Typically, this is done by building a model of data flow and\n\t\t\t    control flow, then searching for potentially-vulnerable patterns that\n\t\t\t    connect \"sources\" (signals with intermediate cryptographic\n\t\t\t    state/results) with \"sinks\" (hardware module outputs and other signals\n\t\t\t    outside of trusted cryptographic zone) without any control flow."
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": [
     "Static code analysis can sometimes lead to false positives."
    ],
    "DetectionMethodID": ""
   },
   {
    "Method": "Simulation / Emulation",
    "Description": [
     "Simulation/emulation based analysis can find some instances of\n\t\t\t    this weakness by simulating source register-transfer level (RTL) code\n\t\t\t    along with a set of assertions that incorporate the simulated values\n\t\t\t    of relevant design signals. Typically, these assertions will capture\n\t\t\t    desired or undesired behavior. Analysis can be improved by using\n\t\t\t    simulation-based information flow tracking (IFT) to more precisely\n\t\t\t    detect unexpected results."
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": [
     "Simulation/emulation based analysis can sometimes lead to false\n\t\t\t    negatives if the testbench does not drive the design to a design state\n\t\t\t    in which the assertion would fail."
    ],
    "DetectionMethodID": ""
   },
   {
    "Method": "Formal Verification",
    "Description": [
     "Formal verification can find some instances of this weakness by\n\t\t\t    exhaustively analyzing whether a given assertion holds true for a\n\t\t\t    given hardware design specified in register-transfer level (RTL)\n\t\t\t    code. Typically, these assertions will capture desired or undesired\n\t\t\t    behavior. For this weakness, an assertion should check for undesired\n\t\t\t    behavior in which one output is a signal that captures when a\n\t\t\t    cryptographic algorithm has completely finished; another output is a\n\t\t\t    signal with intermediate cryptographic state/results; and there is an\n\t\t\t    assignment to a hardware module output or other signal outside of a\n\t\t\t    trusted cryptographic zone.",
     "Alternatively, when using a formal IFT verification, the same\n\t\t\t    undesired behavior can be detected by checking if computation results\n\t\t\t    can ever leak to an output when the cryptographic result is not\n\t\t\t    copmlete."
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": [
     "Formal verification may not scale for RTL designs with a large state space."
    ],
    "DetectionMethodID": ""
   },
   {
    "Method": "Manual Analysis",
    "Description": [
     "Manual analysis can find some instances of this weakness by\n\t\t\t    manually reviewing relevant lines of source register-transfer level\n\t\t\t    (RTL) code to detect potentially-vulnerable patterns. Typically, the\n\t\t\t    reviewer will trace the sequence of assignments that connect \"sources\"\n\t\t\t    (signals with intermediate cryptographic state/results) with \"sinks\"\n\t\t\t    (hardware module outputs and other signals outside of trusted\n\t\t\t    cryptographic zone). If this sequence of assignments is missing\n\t\t\t    adequate control flow, then the weakness is likely to exist."
    ],
    "Effectiveness": "Opportunistic",
    "EffectivenessNotes": [
     "Manual analysis of source code is prone to errors (false\n\t\t\t    positives and false negatives) and highly opportunistic."
    ],
    "DetectionMethodID": ""
   }
  ]
 },
 "PotentialMitigations": {
  "Mitigation": [
   {
    "Phase": [
     "Architecture and Design"
    ],
    "Strategy": "",
    "Description": [
     "Designers/developers\n\t\t\t    should add or modify existing control flow\n\t\t\t    logic along any data flow paths that\n\t\t\t    connect \"sources\" (signals with\n\t\t\t    intermediate cryptographic state/results)\n\t\t\t    with \"sinks\" (hardware module outputs and\n\t\t\t    other signals outside of trusted\n\t\t\t    cryptographic zone). The control flow\n\t\t\t    logic should only allow cryptographic\n\t\t\t    results to be driven to \"sinks\" when\n\t\t\t    appropriate conditions are satisfied\n\t\t\t    (typically when the final result for a\n\t\t\t    cryptographic operation has been\n\t\t\t    generated). When the appropriate\n\t\t\t    conditions are not satisfied (i.e., before\n\t\t\t    or during a cryptographic operation), the\n\t\t\t    control flow logic should drive a safe\n\t\t\t    default value to\n\t\t\t    \"sinks\"."
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": null,
    "MitigationID": ""
   },
   {
    "Phase": [
     "Implementation"
    ],
    "Strategy": "",
    "Description": [
     "Designers/developers\n\t\t\t    should add or modify existing control flow\n\t\t\t    logic along any data flow paths that\n\t\t\t    connect \"sources\" (signals with\n\t\t\t    intermediate cryptographic state/results)\n\t\t\t    with \"sinks\" (hardware module outputs and\n\t\t\t    other signals outside of trusted\n\t\t\t    cryptographic zone). The control flow\n\t\t\t    logic should only allow cryptographic\n\t\t\t    results to be driven to \"sinks\" when\n\t\t\t    appropriate conditions are satisfied\n\t\t\t    (typically when the final result for a\n\t\t\t    cryptographic operation has been\n\t\t\t    generated). When the appropriate\n\t\t\t    conditions are not satisfied (i.e., before\n\t\t\t    or during a cryptographic operation), the\n\t\t\t    control flow logic should drive a safe\n\t\t\t    default value to\n\t\t\t    \"sinks\"."
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": null,
    "MitigationID": ""
   }
  ]
 },
 "DemonstrativeExamples": {
  "DemonstrativeExample": [
   {
    "TitleText": "",
    "IntroText": [
     "The following SystemVerilog code is a crypto module that takes input\n\t\t\t    data and encrypts it by processing the data through multiple\n\t\t\t    encryption rounds. Note: this example is derived from [REF-1469]."
    ],
    "BodyText": [
     "In line 50 above, data_state_q is assigned to data_o. Since data_state_q\n\t\t\t    contains intermediate state/results, this allows an attacker to obtain\n\t\t\t    these results through data_o.",
     "In line 50 of the fixed logic below,\n\t\t\t      while \"data_state_q\" does not contain the final result, \n\t\t\t      a \"sanitizing\" mechanism drives a safe default value (i.e., 0) to\n\t\t\t      \"data_o\" instead of the value of \"data_state_q\".\n\t\t\t      In doing so, the mechanism prevents\n\t\t\t      the exposure of intermediate state/results which could be used to\n\t\t\t      break soundness of the cryptographic operation being performed. A\n\t\t\t      real-world example of this weakness and mitigation can be seen in a\n\t\t\t      pull request that was submitted to the OpenTitan Github repository\n\t\t\t      [REF-1469]."
    ],
    "ExampleCode": {
     "Items": [
      "",
      "",
      "\n\t\t\t\t03 |     input  clk,\n\t\t\t\t04 |     input  rst,\n\t\t\t\t05 |     input  [127:0] data_i,\n\t\t\t\t06 |     output [127:0] data_o,\n\t\t\t\t07 |     output valid\n\t\t\t      ",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\n\t\t\t\t16 |     .clk     (clk),\n\t\t\t\t17 |     .rst     (rst),\n\t\t\t\t18 |     .round_i (round_id_q  ),\n\t\t\t\t19 |     .key_i   (key_state_q ),\n\t\t\t\t20 |     .data_i  (data_state_q),\n\t\t\t\t21 |     .key_o   (key_state_d ),\n\t\t\t\t22 |     .data_o  (data_state_d)\n\t\t\t      ",
      "",
      "",
      "",
      "\n\t\t\t\t26 |     if (rst) begin\n\t\t\t\t\n\t\t\t\t30 |     end\n\t\t\t\t31 |     else begin\n\t\t\t\t\n\t\t\t\t45 |     end\n\t\t\t      ",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\n\t\t\t\t03 |     input  clk,\n\t\t\t\t04 |     input  rst,\n\t\t\t\t05 |     input  [127:0] data_i,\n\t\t\t\t06 |     output [127:0] data_o,\n\t\t\t\t07 |     output valid\n\t\t\t\t08 | );\n\t\t\t      ",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\n\t\t\t\t16 |     .clk     (clk),\n\t\t\t\t17 |     .rst     (rst),\n\t\t\t\t18 |     .round_i (round_id_q  ),\n\t\t\t\t19 |     .key_i   (key_state_q ),\n\t\t\t\t20 |     .data_i  (data_state_q),\n\t\t\t\t21 |     .key_o   (key_state_d ),\n\t\t\t\t22 |     .data_o  (data_state_d)\n\t\t\t      ",
      "",
      "",
      "",
      "\n\t\t\t\t26 |     if (rst) begin\n\t\t\t\t\n\t\t\t\t30 |     end\n\t\t\t\t31 |     else begin\n\t\t\t\t\n\t\t\t\t45 |     end\n\t\t\t      ",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
     ],
     "Language": "Verilog",
     "Nature": "Good"
    },
    "References": {
     "Reference": null
    },
    "DemonstrativeExampleID": ""
   }
  ]
 },
 "ObservedExamples": {
  "ObservedExample": null
 },
 "FunctionalAreas": {
  "FunctionalArea": null
 },
 "AffectedResources": {
  "AffectedResource": null
 },
 "TaxonomyMappings": {
  "TaxonomyMapping": null
 },
 "RelatedAttackPatterns": {
  "RelatedAttackPattern": null
 },
 "References": {
  "Reference": [
   {
    "ExternalReferenceID": "REF-1469",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1470",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1471",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1472",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1473",
    "Section": ""
   }
  ]
 },
 "MappingNotes": {
  "Usage": "Allowed",
  "Rationale": null,
  "Comments": null,
  "Reasons": {
   "Reason": [
    {
     "Type": "Acceptable-Use"
    }
   ]
  },
  "Suggestions": {
   "Suggestion": null
  }
 },
 "Notes": {
  "Note": null
 },
 "ContentHistory": {
  "Submission": {
   "SubmissionName": "Andres Meza",
   "SubmissionOrganization": "University of California, San Diego",
   "SubmissionDate": "2022-08-15T00:00:00Z",
   "SubmissionVersion": "4.17",
   "SubmissionReleaseDate": "2025-04-03T00:00:00Z",
   "SubmissionComment": ""
  },
  "Modification": [
   {
    "ModificationName": "CWE Content Team",
    "ModificationOrganization": "MITRE",
    "ModificationDate": "2025-09-09T00:00:00Z",
    "ModificationVersion": "4.18",
    "ModificationReleaseDate": "2025-09-09T00:00:00Z",
    "ModificationImportance": "",
    "ModificationComment": "updated Relationships"
   }
  ],
  "Contribution": null,
  "PreviousEntryName": null
 },
 "ID": 1431,
 "Name": "Driving Intermediate Cryptographic State/Results to Hardware Module Outputs",
 "Abstraction": "Base",
 "Structure": "Simple",
 "Status": "Incomplete",
 "Diagram": ""
}