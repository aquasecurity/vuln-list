{
 "Description": "A race condition in the hardware logic results in undermining security guarantees of the system.",
 "ExtendedDescription": [
  "A race condition in logic circuits typically occurs when a logic gate gets inputs from signals that have traversed different paths while originating from the same source. Such inputs to the gate can change at slightly different times in response to a change in the source signal. This results in a timing error or a glitch (temporary or permanent) that causes the output to change to an unwanted state before settling back to the desired state. If such timing errors occur in access control logic or finite state machines that are implemented in security sensitive flows, an attacker might exploit them to circumvent existing protections."
 ],
 "RelatedWeaknesses": {
  "RelatedWeakness": [
   {
    "Nature": "ChildOf",
    "CWEID": 362,
    "ViewID": 1000,
    "ChainID": 0,
    "Ordinal": "Primary"
   }
  ]
 },
 "WeaknessOrdinalities": {
  "WeaknessOrdinality": null
 },
 "ApplicablePlatforms": {
  "Language": [
   {
    "Name": "Verilog",
    "Class": "",
    "Prevalence": "Undetermined"
   },
   {
    "Name": "VHDL",
    "Class": "",
    "Prevalence": "Undetermined"
   }
  ],
  "OperatingSystem": null,
  "Architecture": null,
  "Technology": [
   {
    "Name": "",
    "Class": "System on Chip",
    "Prevalence": "Undetermined"
   }
  ]
 },
 "BackgroundDetails": {
  "BackgroundDetail": null
 },
 "AlternateTerms": {
  "AlternateTerm": null
 },
 "ModesOfIntroduction": {
  "Introduction": [
   {
    "Phase": "Architecture and Design",
    "Note": null
   },
   {
    "Phase": "Implementation",
    "Note": null
   }
  ]
 },
 "ExploitationFactors": {
  "ExploitationFactor": null
 },
 "LikelihoodOfExploit": "",
 "CommonConsequences": {
  "Consequence": [
   {
    "Scope": [
     "Access Control"
    ],
    "Impact": [
     "Bypass Protection Mechanism",
     "Gain Privileges or Assume Identity",
     "Alter Execution Logic"
    ],
    "Likelihood": "",
    "Note": null,
    "ConsequenceID": ""
   }
  ]
 },
 "DetectionMethods": {
  "DetectionMethod": null
 },
 "PotentialMitigations": {
  "Mitigation": [
   {
    "Phase": [
     "Architecture and Design"
    ],
    "Strategy": "",
    "Description": null,
    "Effectiveness": "",
    "EffectivenessNotes": null,
    "MitigationID": ""
   },
   {
    "Phase": [
     "Implementation"
    ],
    "Strategy": "",
    "Description": null,
    "Effectiveness": "",
    "EffectivenessNotes": null,
    "MitigationID": ""
   }
  ]
 },
 "DemonstrativeExamples": {
  "DemonstrativeExample": [
   {
    "TitleText": "",
    "IntroText": null,
    "BodyText": null,
    "ExampleCode": {
     "Items": [
      "",
      "",
      "",
      "\n\t\t\t\t\t\t\tinput wire in0, in1, sel,\n\t\t\t\t\t\t\toutput wire z\n\t\t\t\t\t\t",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
     ],
     "Language": "Verilog",
     "Nature": "Good"
    },
    "References": {
     "Reference": null
    },
    "DemonstrativeExampleID": ""
   },
   {
    "TitleText": "",
    "IntroText": [
     "The example code is taken from the DMA (Direct Memory Access) module of the buggy OpenPiton SoC of HACK@DAC'21. The DMA contains a finite-state machine (FSM) for accessing the permissions using the physical memory protection (PMP) unit.",
     "PMP provides secure regions of physical memory against unauthorized access. It allows an operating system or a hypervisor to define a series of physical memory regions and then set permissions for those regions, such as read, write, and execute permissions. When a user tries to access a protected memory area (e.g., through DMA), PMP checks the access of a PMP address (e.g., pmpaddr_i) against its configuration (pmpcfg_i). If the access violates the defined permissions (e.g., CTRL_ABORT), the PMP can trigger a fault or an interrupt. This access check is implemented in the pmp parametrized module in the below code snippet. The below code assumes that the state of the pmpaddr_i and pmpcfg_i signals will not change during the different DMA states (i.e., CTRL_IDLE to CTRL_DONE) while processing a DMA request (via dma_ctrl_reg). The DMA state machine is implemented using a case statement (not shown in the code snippet)."
    ],
    "BodyText": [
     "However, the above code [REF-1394] allows the values of pmpaddr_i and pmpcfg_i to be changed through DMA's input ports. This causes a race condition and will enable attackers to access sensitive addresses that the configuration is not associated with.",
     "Attackers can initialize the DMA access process (CTRL_IDLE) using pmpcfg_i for a non-privileged PMP address (pmpaddr_i). Then during the loading state (CTRL_LOAD), attackers can replace the non-privileged address in pmpaddr_i with a privileged address without the requisite authorized access configuration.",
     "To fix this issue (see [REF-1395]), the value of the pmpaddr_i and pmpcfg_i signals should be stored in local registers (pmpaddr_reg and pmpcfg_reg at the start of the DMA access process and the pmp module should reference those registers instead of the signals directly. The values of the registers can only be updated at the start (CTRL_IDLE) or the end (CTRL_DONE) of the DMA access process, which prevents attackers from changing the PMP address in the middle of the DMA access process."
    ],
    "ExampleCode": {
     "Items": [
      "",
      "",
      "\n\t\t\t\t\t\tinput [7:0] [16-1:0] pmpcfg_i;\n\t\t\t\t\t\tinput logic [16-1:0][53:0]     pmpaddr_i;\n\t\t\t\t\t\t...\n\t\t\t\t\t\t//// Save the input command\n  \t\t\t\t\t\talways @ (posedge clk_i or negedge rst_ni)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t",
      "",
      "",
      "\n\t\t\t\t\t\tinput [7:0] [16-1:0] pmpcfg_i;   \n\t\t\t\t\t\tinput logic [16-1:0][53:0]     pmpaddr_i;\n\t\t\t\t\t\t...\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t...\n\t\t\t\t\t\t//// Save the input command\n\t\t\t\t\t\talways @ (posedge clk_i or negedge rst_ni)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t"
     ],
     "Language": "Verilog",
     "Nature": "Good"
    },
    "References": {
     "Reference": null
    },
    "DemonstrativeExampleID": ""
   }
  ]
 },
 "ObservedExamples": {
  "ObservedExample": null
 },
 "FunctionalAreas": {
  "FunctionalArea": null
 },
 "AffectedResources": {
  "AffectedResource": null
 },
 "TaxonomyMappings": {
  "TaxonomyMapping": null
 },
 "RelatedAttackPatterns": {
  "RelatedAttackPattern": [
   {
    "CAPECID": 26
   }
  ]
 },
 "References": {
  "Reference": [
   {
    "ExternalReferenceID": "REF-1115",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1116",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1394",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1395",
    "Section": ""
   }
  ]
 },
 "MappingNotes": {
  "Usage": "Allowed",
  "Rationale": null,
  "Comments": null,
  "Reasons": {
   "Reason": [
    {
     "Type": "Acceptable-Use"
    }
   ]
  },
  "Suggestions": {
   "Suggestion": null
  }
 },
 "Notes": {
  "Note": null
 },
 "ContentHistory": {
  "Submission": {
   "SubmissionName": "Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi",
   "SubmissionOrganization": "Intel Corporation",
   "SubmissionDate": "2020-02-10T00:00:00Z",
   "SubmissionVersion": "4.2",
   "SubmissionReleaseDate": "2020-08-20T00:00:00Z",
   "SubmissionComment": ""
  },
  "Modification": [
   {
    "ModificationName": "CWE Content Team",
    "ModificationOrganization": "MITRE",
    "ModificationDate": "2021-07-20T00:00:00Z",
    "ModificationVersion": "",
    "ModificationReleaseDate": "0001-01-01T00:00:00Z",
    "ModificationImportance": "",
    "ModificationComment": "updated Related_Attack_Patterns"
   },
   {
    "ModificationName": "CWE Content Team",
    "ModificationOrganization": "MITRE",
    "ModificationDate": "2023-04-27T00:00:00Z",
    "ModificationVersion": "",
    "ModificationReleaseDate": "0001-01-01T00:00:00Z",
    "ModificationImportance": "",
    "ModificationComment": "updated Relationships"
   },
   {
    "ModificationName": "CWE Content Team",
    "ModificationOrganization": "MITRE",
    "ModificationDate": "2023-06-29T00:00:00Z",
    "ModificationVersion": "",
    "ModificationReleaseDate": "0001-01-01T00:00:00Z",
    "ModificationImportance": "",
    "ModificationComment": "updated Mapping_Notes"
   },
   {
    "ModificationName": "CWE Content Team",
    "ModificationOrganization": "MITRE",
    "ModificationDate": "2024-02-29T00:00:00Z",
    "ModificationVersion": "4.14",
    "ModificationReleaseDate": "2024-02-29T00:00:00Z",
    "ModificationImportance": "",
    "ModificationComment": "updated Demonstrative_Examples, References"
   }
  ],
  "Contribution": [
   {
    "ContributionName": "Chen Chen, Rahul Kande, Jeyavijayan Rajendran",
    "ContributionOrganization": "Texas A\u0026M University",
    "ContributionDate": "2023-11-29T00:00:00Z",
    "ContributionVersion": "",
    "ContributionReleaseDate": "0001-01-01T00:00:00Z",
    "ContributionComment": "suggested demonstrative example",
    "Type": "Content"
   },
   {
    "ContributionName": "Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi",
    "ContributionOrganization": "Technical University of Darmstadt",
    "ContributionDate": "2023-11-29T00:00:00Z",
    "ContributionVersion": "",
    "ContributionReleaseDate": "0001-01-01T00:00:00Z",
    "ContributionComment": "suggested demonstrative example",
    "Type": "Content"
   }
  ],
  "PreviousEntryName": null
 },
 "ID": 1298,
 "Name": "Hardware Logic Contains Race Conditions",
 "Abstraction": "Base",
 "Structure": "Simple",
 "Status": "Draft",
 "Diagram": ""
}