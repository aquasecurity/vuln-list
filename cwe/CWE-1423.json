{
 "Description": "Shared microarchitectural predictor state may allow code to influence\n\t\t\t\ttransient execution across a hardware boundary, potentially exposing\n\t\t\t\tdata that is accessible beyond the boundary over a covert channel.\n\t\t\t",
 "ExtendedDescription": [
  "Many commodity processors have Instruction Set Architecture (ISA)\n\t\t\t\tfeatures that protect software components from one another. These\n\t\t\t\tfeatures can include memory segmentation, virtual memory, privilege\n\t\t\t\trings, trusted execution environments, and virtual machines, among\n\t\t\t\tothers. For example, virtual memory provides each process with its own\n\t\t\t\taddress space, which prevents processes from accessing each other's\n\t\t\t\tprivate data. Many of these features can be used to form\n\t\t\t\thardware-enforced security boundaries between software components.",
  "When separate software components (for example, two processes) share\n\t\t\t\tmicroarchitectural predictor state across a hardware boundary, code in\n\t\t\t\tone component may be able to influence microarchitectural predictor\n\t\t\t\tbehavior in another component. If the predictor can cause transient\n\t\t\t\texecution, the shared predictor state may allow an attacker to\n\t\t\t\tinfluence transient execution in a victim, and in a manner that could\n\t\t\t\tallow the attacker to infer private data from the victim by monitoring\n\t\t\t\tobservable discrepancies (CWE-203) in a covert channel [REF-1400].",
  "Predictor state may be shared when the processor transitions from one\n\t\t\t\tcomponent to another (for example, when a process makes a system call\n\t\t\t\tto enter the kernel). Many commodity processors have features which\n\t\t\t\tprevent microarchitectural predictions that occur before a boundary\n\t\t\t\tfrom influencing predictions that occur after the boundary.",
  "Predictor state may also be shared between hardware threads, for\n\t\t\t\texample, sibling hardware threads on a processor that supports\n\t\t\t\tsimultaneous multithreading (SMT). This sharing may be benign if the\n\t\t\t\thardware threads are simultaneously executing in the same software\n\t\t\t\tcomponent, or it could expose a weakness if one sibling is a malicious\n\t\t\t\tsoftware component, and the other sibling is a victim software\n\t\t\t\tcomponent. Processors that share microarchitectural predictors between\n\t\t\t\thardware threads may have features which prevent microarchitectural\n\t\t\t\tpredictions that occur on one hardware thread from influencing\n\t\t\t\tpredictions that occur on another hardware thread.",
  "Features that restrict predictor state sharing across transitions or\n\t\t\t\tbetween hardware threads may be always-on, on by default, or may\n\t\t\t\trequire opt-in from software."
 ],
 "RelatedWeaknesses": {
  "RelatedWeakness": [
   {
    "Nature": "ChildOf",
    "CWEID": 1420,
    "ViewID": 1000,
    "ChainID": 0,
    "Ordinal": "Primary"
   },
   {
    "Nature": "ChildOf",
    "CWEID": 1420,
    "ViewID": 1194,
    "ChainID": 0,
    "Ordinal": "Primary"
   }
  ]
 },
 "WeaknessOrdinalities": {
  "WeaknessOrdinality": null
 },
 "ApplicablePlatforms": {
  "Language": [
   {
    "Name": "",
    "Class": "Not Language-Specific",
    "Prevalence": "Undetermined"
   }
  ],
  "OperatingSystem": [
   {
    "Name": "",
    "Version": "",
    "CPEID": "",
    "Class": "Not OS-Specific",
    "Prevalence": "Undetermined"
   }
  ],
  "Architecture": [
   {
    "Name": "",
    "Class": "Not Architecture-Specific",
    "Prevalence": "Undetermined"
   }
  ],
  "Technology": [
   {
    "Name": "Microcontroller Hardware",
    "Class": "",
    "Prevalence": "Undetermined"
   },
   {
    "Name": "Processor Hardware",
    "Class": "",
    "Prevalence": "Undetermined"
   },
   {
    "Name": "Memory Hardware",
    "Class": "",
    "Prevalence": "Undetermined"
   },
   {
    "Name": "",
    "Class": "System on Chip",
    "Prevalence": "Undetermined"
   }
  ]
 },
 "BackgroundDetails": {
  "BackgroundDetail": null
 },
 "AlternateTerms": {
  "AlternateTerm": null
 },
 "ModesOfIntroduction": {
  "Introduction": [
   {
    "Phase": "Architecture and Design",
    "Note": [
     "This weakness can be introduced during hardware architecture and\n\t\t\t\t\tdesign if predictor state is not properly isolated between modes (for\n\t\t\t\t\texample, user mode and kernel mode), if predictor state is not\n\t\t\t\t\tisolated between hardware threads, or if it is not isolated between\n\t\t\t\t\tother kinds of execution contexts supported by the processor."
    ]
   },
   {
    "Phase": "Implementation",
    "Note": [
     "This weakness can be introduced during system software\n\t\t\t\t\timplementation if predictor-state-sanitizing operations (for example,\n\t\t\t\t\tthe indirect branch prediction barrier on Intel x86) are not invoked\n\t\t\t\t\twhen switching from one context to another."
    ]
   },
   {
    "Phase": "System Configuration",
    "Note": [
     "This weakness can be introduced if the system has not been\n\t\t\t\t\tconfigured according to the hardware vendor's recommendations for\n\t\t\t\t\tmitigating the weakness."
    ]
   }
  ]
 },
 "ExploitationFactors": {
  "ExploitationFactor": null
 },
 "LikelihoodOfExploit": "",
 "CommonConsequences": {
  "Consequence": [
   {
    "Scope": [
     "Confidentiality"
    ],
    "Impact": [
     "Read Memory"
    ],
    "Likelihood": "Medium",
    "Note": null,
    "ConsequenceID": ""
   }
  ]
 },
 "DetectionMethods": {
  "DetectionMethod": [
   {
    "Method": "Manual Analysis",
    "Description": [
     "This weakness can be detected in hardware by manually\n\t\t\t\t\tinspecting processor specifications. Features that exhibit this\n\t\t\t\t\tweakness may have microarchitectural predictor state that is shared\n\t\t\t\t\tbetween hardware threads, execution contexts (for example, user and\n\t\t\t\t\tkernel), or other components that may host mutually distrusting\n\t\t\t\t\tsoftware (or firmware, etc.)."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": null,
    "DetectionMethodID": ""
   },
   {
    "Method": "Automated Analysis",
    "Description": [
     "Software vendors can release tools that detect presence of\n\t\t\t\t\tknown weaknesses on a processor. For example, some of these tools can\n\t\t\t\t\tattempt to transiently execute a vulnerable code sequence and detect\n\t\t\t\t\twhether code successfully leaks data in a manner consistent with the\n\t\t\t\t\tweakness under test. Alternatively, some hardware vendors provide\n\t\t\t\t\tenumeration for the presence of a weakness (or lack of a\n\t\t\t\t\tweakness). These enumeration bits can be checked and reported by\n\t\t\t\t\tsystem software. For example, Linux supports these checks for many\n\t\t\t\t\tcommodity processors:",
     "$ cat /proc/cpuinfo | grep bugs | head -n 1",
     "bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit srbds mmio_stale_data retbleed"
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": null,
    "DetectionMethodID": ""
   },
   {
    "Method": "Automated Analysis",
    "Description": [
     "This weakness can be detected in hardware by employing static\n\t\t\t\t\tor dynamic taint analysis methods [REF-1401]. These methods can label\n\t\t\t\t\teach predictor entry (or prediction history, etc.) according to the\n\t\t\t\t\tprocessor context that created it. Taint analysis or information flow\n\t\t\t\t\tanalysis can then be applied to detect when predictor state created in\n\t\t\t\t\tone context can influence predictions made in another context."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": null,
    "DetectionMethodID": ""
   }
  ]
 },
 "PotentialMitigations": {
  "Mitigation": [
   {
    "Phase": [
     "Architecture and Design"
    ],
    "Strategy": "",
    "Description": [
     "The hardware designer can attempt to prevent transient\n\t\t\t\t\texecution from causing observable discrepancies in specific covert\n\t\t\t\t\tchannels."
    ],
    "Effectiveness": "",
    "EffectivenessNotes": null,
    "MitigationID": ""
   },
   {
    "Phase": [
     "Architecture and Design"
    ],
    "Strategy": "",
    "Description": [
     "Hardware designers may choose to use microarchitectural\n\t\t\t\t\tbits to tag predictor entries. For example, each predictor entry may\n\t\t\t\t\tbe tagged with a kernel-mode bit which, when set, indicates that the\n\t\t\t\t\tpredictor entry was created in kernel mode. The processor can use this\n\t\t\t\t\tbit to enforce that predictions in the current mode must have been\n\t\t\t\t\ttrained in the current mode. This can prevent malicious cross-mode\n\t\t\t\t\ttraining, such as when user-mode software attempts to create predictor\n\t\t\t\t\tentries that influence transient execution in the kernel. Predictor\n\t\t\t\t\tentry tags can also be used to associate each predictor entry with the\n\t\t\t\t\tSMT thread that created it, and thus the processor can enforce that\n\t\t\t\t\teach predictor entry can only be used by the SMT thread that created\n\t\t\t\t\tit. This can prevent an SMT thread from using predictor entries\n\t\t\t\t\tcrafted by a malicious sibling SMT thread."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": [
     "Tagging can be highly effective for predictor\n\t\t\t\t\tstate that is comprised of discrete elements, such as an array of\n\t\t\t\t\trecently visited branch targets. Predictor state can also have\n\t\t\t\t\tdifferent representations that are not conducive to tagging. For\n\t\t\t\t\texample, some processors keep a compressed digest of branch history\n\t\t\t\t\twhich does not contain discrete elements that can be individually\n\t\t\t\t\ttagged."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Architecture and Design"
    ],
    "Strategy": "",
    "Description": [
     "Hardware designers may choose to sanitize\n\t\t\t\t\tmicroarchitectural predictor state (for example, branch prediction\n\t\t\t\t\thistory) when the processor transitions to a different context, for\n\t\t\t\t\texample, whenever a system call is invoked. Alternatively, the\n\t\t\t\t\thardware may expose instruction(s) that allow software to sanitize\n\t\t\t\t\tpredictor state according to the user's threat model. For example,\n\t\t\t\t\tthis can allow operating system software to sanitize predictor state\n\t\t\t\t\twhen performing a context switch from one process to another."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": [
     "This technique may not be able to mitigate\n\t\t\t\t\tweaknesses that arise from predictor state that is shared across SMT\n\t\t\t\t\tthreads. Sanitizing predictor state on context switches may also\n\t\t\t\t\tnegatively impact performance, either by removing predictor entries\n\t\t\t\t\tthat could be reused when returning to the previous context, or by\n\t\t\t\t\tslowing down the context switch itself."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Implementation"
    ],
    "Strategy": "",
    "Description": [
     "System software can mitigate this weakness by invoking\n\t\t\t\t\tpredictor-state-sanitizing operations (for example, the indirect\n\t\t\t\t\tbranch prediction barrier on Intel x86) when switching from one\n\t\t\t\t\tcontext to another, according to the hardware vendor's\n\t\t\t\t\trecommendations."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": [
     "This technique may not be able to mitigate\n\t\t\t\t\tweaknesses that arise from predictor state shared across SMT\n\t\t\t\t\tthreads. Sanitizing predictor state may also negatively impact\n\t\t\t\t\tperformance in some circumstances."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Build and Compilation"
    ],
    "Strategy": "",
    "Description": [
     "If the weakness is exposed by a single instruction (or a\n\t\t\t\t\tsmall set of instructions), then the compiler (or JIT, etc.) can be\n\t\t\t\t\tconfigured to prevent the affected instruction(s) from being\n\t\t\t\t\tgenerated. One prominent example of this mitigation is retpoline\n\t\t\t\t\t([REF-1414])."
    ],
    "Effectiveness": "Limited",
    "EffectivenessNotes": [
     "This technique is only effective for software\n\t\t\t\t\tthat is compiled with this mitigation. Additionally, an alternate\n\t\t\t\t\tinstruction sequence may mitigate the weakness on some processors but\n\t\t\t\t\tnot others, even when the processors share the same ISA. For example,\n\t\t\t\t\tretpoline has been documented as effective on some x86 processors, but\n\t\t\t\t\tnot fully effective on other x86 processors."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Build and Compilation"
    ],
    "Strategy": "",
    "Description": [
     "Use control-flow integrity (CFI) techniques to constrain\n\t\t\t\t\tthe behavior of instructions that redirect the instruction pointer,\n\t\t\t\t\tsuch as indirect branch instructions."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": [
     "Some CFI techniques may not be able to constrain\n\t\t\t\t\ttransient execution, even though they are effective at constraining\n\t\t\t\t\tarchitectural execution. Or they may be able to provide some\n\t\t\t\t\tadditional protection against a transient execution weakness, but\n\t\t\t\t\twithout comprehensively mitigating the weakness. For example,\n\t\t\t\t\tClang-CFI provides strong architectural CFI properties and can make\n\t\t\t\t\tsome transient execution weaknesses more difficult to exploit [REF-1398]."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Build and Compilation"
    ],
    "Strategy": "",
    "Description": [
     "Use software techniques (including the use of\n\t\t\t\t\tserialization instructions) that are intended to reduce the number of\n\t\t\t\t\tinstructions that can be executed transiently after a processor event\n\t\t\t\t\tor misprediction."
    ],
    "Effectiveness": "Incidental",
    "EffectivenessNotes": [
     "Some transient execution weaknesses can be\n\t\t\t\t\texploited even if a single instruction is executed transiently after a\n\t\t\t\t\tprocessor event or mis-prediction. This mitigation strategy has many\n\t\t\t\t\tother pitfalls that prevent it from eliminating this weakness\n\t\t\t\t\tentirely. For example, see [REF-1389]."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "System Configuration"
    ],
    "Strategy": "",
    "Description": [
     "Some systems may allow the user to disable predictor\n\t\t\t\t\tsharing. For example, this could be a BIOS configuration, or a\n\t\t\t\t\tmodel-specific register (MSR) that can be configured by the operating\n\t\t\t\t\tsystem or virtual machine monitor."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": [
     "Disabling predictor sharing can negatively impact\n\t\t\t\t\tperformance for some workloads that benefit from shared predictor\n\t\t\t\t\tstate."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Patching and Maintenance"
    ],
    "Strategy": "",
    "Description": [
     "The hardware vendor may provide a patch to, for example,\n\t\t\t\t\tsanitize predictor state when the processor transitions to a different\n\t\t\t\t\tcontext, or to prevent predictor entries from being shared across SMT\n\t\t\t\t\tthreads. A patch may also introduce new ISA that allows software to\n\t\t\t\t\ttoggle a mitigation."
    ],
    "Effectiveness": "Moderate",
    "EffectivenessNotes": [
     "This mitigation may only be fully effective if\n\t\t\t\t\tthe patch prevents predictor sharing across all contexts that are\n\t\t\t\t\taffected by the weakness. Additionally, sanitizing predictor state\n\t\t\t\t\tand/or preventing shared predictor state can negatively impact\n\t\t\t\t\tperformance in some circumstances."
    ],
    "MitigationID": ""
   },
   {
    "Phase": [
     "Documentation"
    ],
    "Strategy": "",
    "Description": [
     "If a hardware feature can allow microarchitectural\n\t\t\t\t\tpredictor state to be shared between contexts, SMT threads, or other\n\t\t\t\t\tarchitecturally defined boundaries, the hardware designer may opt to\n\t\t\t\t\tdisclose this behavior in architecture documentation. This\n\t\t\t\t\tdocumentation can inform users about potential consequences and\n\t\t\t\t\teffective mitigations."
    ],
    "Effectiveness": "High",
    "EffectivenessNotes": null,
    "MitigationID": ""
   },
   {
    "Phase": [
     "Requirements"
    ],
    "Strategy": "",
    "Description": [
     "Processor designers, system software vendors, or other\n\t\t\t\t\tagents may choose to restrict the ability of unprivileged software to\n\t\t\t\t\taccess to high-resolution timers that are commonly used to monitor\n\t\t\t\t\tcovert channels."
    ],
    "Effectiveness": "",
    "EffectivenessNotes": null,
    "MitigationID": ""
   }
  ]
 },
 "DemonstrativeExamples": {
  "DemonstrativeExample": [
   {
    "TitleText": "",
    "IntroText": [
     "Branch Target Injection (BTI) is a vulnerability that can allow an SMT\n\t\t\t\t\thardware thread to maliciously train the indirect branch predictor\n\t\t\t\t\tstate that is shared with its sibling hardware thread. A cross-thread\n\t\t\t\t\tBTI attack requires the attacker to find a vulnerable code sequence\n\t\t\t\t\twithin the victim software. For example, the authors of [REF-1415]\n\t\t\t\t\tidentified the following code sequence in the Windows library\n\t\t\t\t\tntdll.dll:"
    ],
    "BodyText": [
     "To successfully exploit this code sequence to disclose the victim's\n\t\t\t\t\tprivate data, the attacker must also be able to find an indirect\n\t\t\t\t\tbranch site within the victim, where the attacker controls the values\n\t\t\t\t\tin edi and ebx, and the attacker knows the value in edx as shown above\n\t\t\t\t\tat the indirect branch site.",
     "A proof-of-concept cross-thread BTI attack might proceed as follows:",
     "\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t"
    ],
    "ExampleCode": {
     "Items": [
      "",
      "\n\t\t\t\t\t\tadc edi,dword ptr [ebx+edx+13BE13BDh]\n\t\t\t\t\t\tadc dl,byte ptr [edi]\n\t\t\t\t\t\t...\n\t\t\t\t\t\t",
      "",
      "\n\t\t\t\t\t\tjmp dword ptr [rsi]   # at this point attacker knows edx, controls edi and ebx\n\t\t\t\t\t\t"
     ],
     "Language": "x86 Assembly",
     "Nature": "Bad"
    },
    "References": {
     "Reference": null
    },
    "DemonstrativeExampleID": ""
   },
   {
    "TitleText": "",
    "IntroText": [
     "BTI can also allow software in one execution context to maliciously\n\t\t\t\t\ttrain branch predictor entries that can be used in another\n\t\t\t\t\tcontext. For example, on some processors user-mode software may be\n\t\t\t\t\table to train predictor entries that can also be used after\n\t\t\t\t\ttransitioning into kernel mode, such as after invoking a system\n\t\t\t\t\tcall. This vulnerability does not necessarily require SMT and may\n\t\t\t\t\tinstead be performed in synchronous steps, though it does require the\n\t\t\t\t\tattacker to find an exploitable code sequence in the victim's code,\n\t\t\t\t\tfor example, in the kernel."
    ],
    "BodyText": null,
    "ExampleCode": {
     "Items": null,
     "Language": "",
     "Nature": ""
    },
    "References": {
     "Reference": null
    },
    "DemonstrativeExampleID": ""
   }
  ]
 },
 "ObservedExamples": {
  "ObservedExample": [
   {
    "Reference": "CVE-2017-5754",
    "Description": null,
    "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5754"
   },
   {
    "Reference": "CVE-2022-0001",
    "Description": null,
    "Link": "https://www.cve.org/CVERecord?id=CVE-2022-0001"
   },
   {
    "Reference": "CVE-2021-33149",
    "Description": null,
    "Link": "https://www.cve.org/CVERecord?id=CVE-2021-33149"
   }
  ]
 },
 "FunctionalAreas": {
  "FunctionalArea": null
 },
 "AffectedResources": {
  "AffectedResource": null
 },
 "TaxonomyMappings": {
  "TaxonomyMapping": null
 },
 "RelatedAttackPatterns": {
  "RelatedAttackPattern": null
 },
 "References": {
  "Reference": [
   {
    "ExternalReferenceID": "REF-1414",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1415",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1416",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1398",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1389",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1400",
    "Section": ""
   },
   {
    "ExternalReferenceID": "REF-1401",
    "Section": ""
   }
  ]
 },
 "MappingNotes": {
  "Usage": "Allowed",
  "Rationale": null,
  "Comments": null,
  "Reasons": {
   "Reason": [
    {
     "Type": "Acceptable-Use"
    }
   ]
  },
  "Suggestions": {
   "Suggestion": [
    {
     "CWEID": 1420,
     "Comment": "If a weakness involves a microarchitectural predictor whose state is not shared across processor contexts, then CWE-1420 may be more appropriate for the mapping task."
    }
   ]
  }
 },
 "Notes": {
  "Note": null
 },
 "ContentHistory": {
  "Submission": {
   "SubmissionName": "Scott D. Constable",
   "SubmissionOrganization": "Intel Corporation",
   "SubmissionDate": "2023-09-19T00:00:00Z",
   "SubmissionVersion": "4.14",
   "SubmissionReleaseDate": "2024-02-29T00:00:00Z",
   "SubmissionComment": ""
  },
  "Modification": [
   {
    "ModificationName": "CWE Content Team",
    "ModificationOrganization": "MITRE",
    "ModificationDate": "2025-09-09T00:00:00Z",
    "ModificationVersion": "4.18",
    "ModificationReleaseDate": "2025-09-09T00:00:00Z",
    "ModificationImportance": "",
    "ModificationComment": "updated Relationships"
   }
  ],
  "Contribution": [
   {
    "ContributionName": "David Kaplan",
    "ContributionOrganization": "AMD",
    "ContributionDate": "2024-01-22T00:00:00Z",
    "ContributionVersion": "4.14",
    "ContributionReleaseDate": "2024-02-29T00:00:00Z",
    "ContributionComment": "Member of Microarchitectural Weaknesses Working Group",
    "Type": "Content"
   },
   {
    "ContributionName": "Rafael Dossantos, Abraham Fernandez Rubio, Alric Althoff, Lyndon Fawcett",
    "ContributionOrganization": "Arm",
    "ContributionDate": "2024-01-22T00:00:00Z",
    "ContributionVersion": "4.14",
    "ContributionReleaseDate": "2024-02-29T00:00:00Z",
    "ContributionComment": "Members of Microarchitectural Weaknesses Working Group",
    "Type": "Content"
   },
   {
    "ContributionName": "Jason Oberg",
    "ContributionOrganization": "Cycuity",
    "ContributionDate": "2024-01-22T00:00:00Z",
    "ContributionVersion": "4.14",
    "ContributionReleaseDate": "2024-02-29T00:00:00Z",
    "ContributionComment": "Member of Microarchitectural Weaknesses Working Group",
    "Type": "Content"
   },
   {
    "ContributionName": "Priya B. Iyer",
    "ContributionOrganization": "Intel Corporation",
    "ContributionDate": "2024-01-22T00:00:00Z",
    "ContributionVersion": "4.14",
    "ContributionReleaseDate": "2024-02-29T00:00:00Z",
    "ContributionComment": "Member of Microarchitectural Weaknesses Working Group",
    "Type": "Content"
   },
   {
    "ContributionName": "Nicole Fern",
    "ContributionOrganization": "Riscure",
    "ContributionDate": "2024-01-22T00:00:00Z",
    "ContributionVersion": "4.14",
    "ContributionReleaseDate": "2024-02-29T00:00:00Z",
    "ContributionComment": "Member of Microarchitectural Weaknesses Working Group",
    "Type": "Content"
   }
  ],
  "PreviousEntryName": null
 },
 "ID": 1423,
 "Name": "Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution",
 "Abstraction": "Base",
 "Structure": "Simple",
 "Status": "Incomplete",
 "Diagram": ""
}