{
  "Title": "SUSE-IU-2026:63-1",
  "Tracking": {
    "ID": "SUSE Image SUSE-IU-2026:63-1",
    "Status": "Interim",
    "Version": "1",
    "InitialReleaseDate": "2026-01-11T01:00:00Z",
    "CurrentReleaseDate": "2026-01-11T01:00:00Z",
    "RevisionHistory": [
      {
        "Number": "1",
        "Date": "2026-01-30T22:52:47Z",
        "Description": "current"
      }
    ]
  },
  "Notes": [
    {
      "Text": "Image update for SUSE-IU-2026:63-1 / google/sles-sap-12-sp5-byos-v20260111-x86-64",
      "Title": "Topic",
      "Type": "Summary"
    },
    {
      "Text": "This image update for google/sles-sap-12-sp5-byos-v20260111-x86-64 contains the following changes:\nPackage libpng12 was updated:\n\n- security update- modified patches\n  * libpng-1.2.50-CVE-2013-7353.patch (-p1)\n  * libpng-1.2.50-CVE-2013-7354.patch (-p1)\n  * libpng12-CVE-2015-7981.patch (-p1)\n  * libpng12-CVE-2015-8126-complete.patch (-p1)\n  * libpng12-CVE-2015-8126.patch (-p1)\n- added patches\n  CVE-2025-64505 [bsc#1254157], heap buffer over-read in `png_do_quantize` via malformed palette index\n  * libpng12-CVE-2025-64505.patch\n\nPackage pciutils was updated:\n\n- pciutils.spec: Add a strict dependency to libpci. [bsc#1252338]  Mixing different versions of pciutils and libpci could result in\n  a segmentation fault due to incompatible ABI.\n\nPackage libpcap was updated:\n\n- Security fix: [bsc#1255765, CVE-2025-11961]  * Fix out-of-bound-write and out-of-bound-read in pcap_ether_aton()\n    due to missing validation of provided MAC-48 address string\n  * Add libpcap-CVE-2025-11961.patch\n\nPackage openssh was updated:\n\n- Add openssh-cve-2025-61984-username-validation.patch  (bsc#1251198, CVE-2025-61984).\n\nPackage libxslt was updated:\n\n- security update- added patches\n  CVE-2025-11731 [bsc#1251979], type confusion in exsltFuncResultCompfunction leading to denial of service\n  * libxslt-CVE-2025-11731.patch\n\n- propagate test failure into build failure\n- added sources\n  * libxslt-test-results.ref\n\nPackage xkbcomp was updated:\n\n- 0001-xkbcomp-Don-t-crash-on-no-op-modmask-expressions.patch  (CVE-2018-15863, bsc#1105832)\n- 0002-xkbcomp-Don-t-falsely-promise-from-ExprResolveLhs.patch\n  (CVE-2018-15861, bsc#1105832)\n- 0003-Fail-expression-lookup-on-invalid-atoms.patch\n  (CVE-2018-15859, bsc#1105832)\n- 0004-xkbcomp-fix-stack-overflow-when-evaluating-boolean-n.patch\n  (CVE-2018-15853, bsc#1105832)\n\nPackage glib2 was updated:\n\n- Add CVE fixes:  + glib2-CVE-2025-13601.patch (bsc#1254297 CVE-2025-13601\n    glgo#GNOME/glib#3827).\n  + glib2-CVE-2025-14087-1.patch, glib2-CVE-2025-14087-2.patch,\n    glib2-CVE-2025-14087-3.patch (bsc#1254662 CVE-2025-14087\n    glgo#GNOME/glib#3834).\n  + glib2-CVE-2025-14512.patch (bsc#1254878 CVE-2025-14512\n    glgo#GNOME/glib#3845).\n\n- Add glib2-CVE-2025-7039.patch: fix computation of temporary file\n  name (bsc#1249055 CVE-2025-7039 glgo#GNOME/glib#3716).\n\nPackage libpng16 was updated:\n\n- security update- added patches\n  CVE-2025-66293 [bsc#1254480], LIBPNG out-of-bounds read in png_image_read_composite\n  * libpng16-CVE-2025-66293-1.patch\n  * libpng16-CVE-2025-66293-2.patch\n\n- security update\n- modified patches\n  * libpng16-1.6.8-CVE-2014-0333.patch (-p1)\n  * libpng16-CVE-2014-9495.patch (-p1)\n  * libpng16-CVE-2015-0973.patch (-p1)\n  * libpng16-CVE-2015-8126-complete.patch (-p1)\n  * libpng16-CVE-2015-8126.patch (-p1)\n- added patches\n  CVE-2025-64505 [bsc#1254157], heap buffer over-read in `png_do_quantize` via malformed palette index\n  * libpng16-CVE-2025-64505.patch\n  CVE-2025-64506 [bsc#1254158], heap buffer over-read in `png_write_image_8bit` with 8-bit input and `convert_to_8bit` enabled\n  * libpng16-CVE-2025-64506.patch\n  CVE-2025-64720 [bsc#1254159], buffer overflow in `png_image_read_composite` via incorrect palette premultiplication\n  * libpng16-CVE-2025-64720.patch\n  CVE-2025-65018 [bsc#1254160], heap buffer overflow in `png_combine_row` triggered via `png_image_finish_read`\n  * libpng16-CVE-2025-65018.patch\n\nPackage grub2 was updated:\n\n- Fix CVE-2025-54771 (bsc#1252931)  * 0001-kern-file-Call-grub_dl_unref-after-fs-fs_close.patch\n- Fix CVE-2025-61662 (bsc#1252933)\n  * 0002-gettext-gettext-Unregister-gettext-command-on-module.patch\n- Fix CVE-2025-61663 (bsc#1252934)\n- Fix CVE-2025-61664 (bsc#1252935)\n  * 0003-normal-main-Unregister-commands-on-module-unload.patch\n  * 0004-tests-lib-functional_test-Unregister-commands-on-mod.patch\n- Fix CVE-2025-61661 (bsc#1252932)\n  * 0005-commands-usbtest-Use-correct-string-length-field.patch\n  * 0006-commands-usbtest-Ensure-string-length-is-sufficient-.patch\n- Bump upstream SBAT generation to 6\n\nPackage kernel-default was updated:\n\n- wifi: ath9k: hif_usb: fix memory leak of remain_skbs (CVE-2023-53641 bsc#1251728)- commit cddd1eb\n\n- thermal: intel_powerclamp: Use first online CPU as control_cpu (bsc#1251173)\n- commit a5e3566\n\n- thermal: intel_powerclamp: Use get_cpu() instead of smp_processor_id() to avoid crash (CVE-2022-50494 bsc#1251173)\n- commit 2222fc8\n\n- drm/scheduler: signal scheduled fence when kill job (bsc#1247227 CVE-2025-38436)\n- commit b828f36\n\n- Update\n  patches.suse/tcp-Don-t-call-reqsk_fastopen_remove-in-tcp_conn_request.patch\n  (git-fixes CVE-2025-40186 bsc#1253438).\n- commit f901ef4\n\n- net: dcb: choose correct policy to parse DCB_ATTR_BCN (CVE-2023-53369 bsc#1250206)\n- commit 358246e\n\n- btrfs: avoid potential out-of-bounds in btrfs_encode_fh() (CVE-2025-40205 bsc#1253456)\n- commit 22c9af2\n\n- net/ip6_tunnel: Prevent perpetual tunnel growth (CVE-2025-40173\n  bsc#1253421).\n- commit d8c4c44\n\n- scsi: mvsas: Fix use-after-free bugs in mvs_work_queue\n  (CVE-2025-40001 bsc#1252303).\n- commit bb0f1cb\n\n- uio_hv_generic: Let userspace take care of interrupt mask (CVE-2025-40048 bsc#1252862).\n- commit 76a0e50\n\n- sctp: Fix MAC comparison to be constant-time (CVE-2025-40204\n  bsc#1253436).\n- commit eccee08\n\n- smb3: fix Open files on server counter going negative\n  (git-fixes).\n- commit 15583ca\n\n- cifs: return a single-use cfid if we did not get a lease\n  (bsc#1228688).\n- commit c039524\n\n- cifs: Check the lease context if we actually got a lease\n  (bsc#1228688).\n- Refresh\n  patches.suse/cifs-fix-open-leaks-in-open_cached_dir.patch.\n- Refresh\n  patches.suse/smb-client-fix-potential-OOBs-in-smb2_parse_contexts-.patch.\n- commit 9351453\n\n- kabi/severities: Update info about kvm_86_ops\n- commit 69450ab\n\n- net/sched: sch_qfq: Fix null-deref in agg_dequeue (CVE-2025-40083 bsc#1252912).\n- commit 2a85e50\n\n- KVM: x86: Give a hint when Win2016 might fail to boot due to XSAVES  erratum (git-fixes).\n- commit 4d19df5\n\n- Refresh patches.suse/x86-CPU-AMD-Disable-XSAVES-on-AMD-family-0x17.patch.\n  XSAVE feature clearing should apply to ZEN1/2 and not to K6 CPUs.\n- commit b258ad9\n\n- blacklist.conf: Add imxfb commit\n- Delete\n  patches.suse/0002-video-fbdev-imxfb-Fix-an-error-message.patch.\n- Delete\n  patches.suse/0004-fbdev-imxfb-warn-about-invalid-left-right-margin.patch.\n  We don't build this driver.\n- commit a556fb5\n\n- net/sched: sch_hfsc: upgrade 'rt' to 'sc' when it becomes a\n  inner curve (bsc#1220419).\n- commit 6275dfe\n\n- scsi: ses: Handle enclosure with just a primary component\n  gracefully (git-fixes CVE-2023-53431 bsc#1250374).\n- commit 1585d41\n\n- PCI: aardvark: Fix checking for MEM resource type (git-fixes).\n- commit ee4989d\n\n- Fix another type-mismatch issue in fbcon patches (bsc#1252033 CVE-2025-39967 bsc#1253237)\n  Fix another type mismatch in fbcon font handling:\n  * comparison of distinct pointer types lacks a cast [enabled by default] in ../drivers/video/console/fbcon.c in fbcon_set_font (from ../include/linux/overflow.h)\n  In file included from ../include/linux/vmalloc.h:10:0,\n  ../drivers/video/console/fbcon.c: In function 'fbcon_set_font':\n  ../include/linux/overflow.h:150:15: warning: comparison of distinct pointer types lacks a cast [enabled by default]\n  ../include/linux/overflow.h:206:4: note: in expansion of macro '__signed_add_overflow'\n  ../drivers/video/console/fbcon.c:2467:6: note: in expansion of macro 'check_add_overflow'\n  * comparison of distinct pointer types lacks a cast [enabled by default] in ../include/linux/overflow.h\n  ../include/linux/overflow.h:151:15: warning: comparison of distinct pointer types lacks a cast [enabled by default]\n  ../include/linux/overflow.h:206:4: note: in expansion of macro '__signed_add_overflow'\n  ../drivers/video/console/fbcon.c:2467:6: note: in expansion of macro 'check_add_overflow'\n  * comparison of distinct pointer types lacks a cast [enabled by default] in ../include/linux/overflow.h\n  ../include/linux/overflow.h:101:15: warning: comparison of distinct pointer types lacks a cast [enabled by default]\n  ../include/linux/overflow.h:207:4: note: in expansion of macro '__unsigned_add_overflow'\n  ../drivers/video/console/fbcon.c:2467:6: note: in expansion of macro 'check_add_overflow'\n  * comparison of distinct pointer types lacks a cast [enabled by default] in ../include/linux/overflow.h\n  ../include/linux/overflow.h:102:15: warning: comparison of distinct pointer types lacks a cast [enabled by default]\n  ../include/linux/overflow.h:207:4: note: in expansion of macro '__unsigned_add_overflow'\n  ../drivers/video/console/fbcon.c:2467:6: note: in expansion of macro 'check_add_overflow'\n- commit 3586116\n\n- Refresh\n  patches.suse/KVM-nSVM-always-intercept-VMLOAD-VMSAVE-when-nested.\n- Refresh\n  patches.suse/KVM-nSVM-avoid-picking-up-unsupported-bits-from-L2-i.\n  Add upstream commit ID and move to sorted section.\n- commit 808b040\n\n- dmaengine: bcm2835: Avoid GFP_KERNEL in device_prep_slave_sg\n  (bsc#1070872).\n  Rename, update with upstream description and reference, and move to the\n  sorted section.\n- commit 3ac835f\n\n- Move ocfs2 fixes to the sorted section\n- commit c36ff63\n\n- wifi: mac80211: fix invalid drv_sta_pre_rcu_remove calls for non-uploaded sta (CVE-2023-53229 bsc#1249650)\n- commit 6e55df1\n\n- Restore fixes for fbcon_do_set_font() (bsc#1252033 CVE-2025-39967 bsc#1253237)\n  The backport from bsc#1252033 failed because check_mul_overflow()\n  did not handle differences in type signs. Restore the patches and\n  fix them to use unsigned types for all calculations. Input arguments\n  are unsigned anyway.\n- commit 7a71d84\n\n- wifi: brcmfmac: Fix potential shift-out-of-bounds in brcmf_fw_alloc_request() (CVE-2022-50551 bsc#1251322)\n- commit 644642c\n\n- r6040: Fix kmemleak in probe and remove (CVE-2022-50545 bsc#1251285)\n- commit 506400a\n\n- xfrm: Update ipcomp_scratches with NULL when freed\n  (CVE-2022-50569 bsc#1252640).\n- commit 8b98d1b\n\n- scsi: target: iscsi: Fix buffer overflow in\n  lio_target_nacl_info_show() (bsc#1251786 CVE-2023-53676).\n- commit e9a3dc4\n\n- Revert \u0026quot;fbcon: fix integer overflow in fbcon_do_set_font (bsc#1252033 CVE-2025-39967)\u0026quot;\n  This reverts commit ef5b27e0395e36f32d5881894b4deb2dc992343a.\n- commit 541fc90\n\n- Revert \u0026quot;fbcon: Fix OOB access in font allocation (bsc#1252033)\u0026quot;\n  This reverts commit d696663168f05fd9eb1b90bb1be489edf7001e6b.\n- commit 3f75577\n\n- Alt-commit updates\n- Refresh\n  patches.suse/0001-drm-amdgpu-validate-the-parameters-of-bo-mapping-ope.patch.\n- Refresh\n  patches.suse/0001-drm-i915-gem-Fix-Virtual-Memory-mapping-boundaries-c.patch.\n- Refresh patches.suse/1394-drm-msm-fix-no_implicit-fencing-case.\n- Refresh\n  patches.suse/Revert-drm-radeon-Fix-EEH-during-kexec.patch.\n- commit 5d5cec6\n\n- ARM: dts: exynos: Use Exynos5420 compatible for the MIPI video phy (CVE-2023-53542 bsc#1251154)\n- commit f3fb811\n\n- drm/msm/dsi: fix memory corruption with too many bridges (CVE-2022-50368 bsc#1250009)\n- commit 520589a\n\n- pps: fix warning in pps_register_cdev when register device fail\n  (CVE-2025-40070 bsc#1252836).\n- commit cb71ffd\n\n- pinctrl: check the return value of\n  pinmux_ops::get_function_name() (CVE-2025-40030 bsc#1252773).\n- commit b26cdf3\n\n- ocfs2: fix double free in user_cluster_connect() (CVE-2025-40055 bsc#1252821)\n- commit 832b986\n\n- class: fix possible memory leak in __class_register()\n  (CVE-2022-50578 bsc#1252519).\n- commit 4001512\n\n- mm/ksm: fix flag-dropping behavior in ksm_madvise\n  (CVE-2025-40040 bsc#1252780).\n- commit 6af1ea3\n\n- net/9p: fix double req put in p9_fd_cancelled (CVE-2025-40027\n  bsc#1252763).\n- commit 12bcbd0\n\n- fs/smb: Fix inconsistent refcnt update (bsc#1250176,\n  CVE-2025-39819).\n- commit 8b09411\n\n- 9p/trans_fd: Fix concurrency del of req_list in\n  p9_fd_cancelled/p9_read_work (CVE-2025-40027 bsc#1252763).\n- commit 2d2d005\n\n- cifs: fix mid leak during reconnection after timeout threshold\n  (bsc#1251159, CVE-2023-53597).\n- commit 29af9dd\n\n- tcp_bpf: Call sk_msg_free() when tcp_bpf_send_verdict() fails\n  to allocate psock-\u0026gt;cork (bsc#1250705).\n- commit 5eef25f\n\n- tcp_bpf: Fix copied value in tcp_bpf_sendmsg (bsc#1250650).\n- skmsg: Return copied bytes in sk_msg_memcopy_from_iter\n  (bsc#1250650).\n- commit 7274f26\n\n- wifi: ath9k: Fix potential stack-out-of-bounds write in\n  ath9k_wmi_rsp_callback() (CVE-2023-53717 bsc#1252560).\n- commit 469787a\n\n- net: sched: cls_u32: Undo tcf_bind_filter if\n  u32_replace_hw_knode (CVE-2023-53733 bsc#1252685).\n- commit 308a4a1\n\n- blacklist.conf: CVE-2025-37928 bsc#1243621\n- Delete patches.suse/dm-bufio-don-t-schedule-in-atomic-context.patch\n- commit 2991827\n\n- udf: Preserve link count of system files (bsc#1252539\n  CVE-2023-53695).\n- commit c7818f7\n\n- udf: Detect system inodes linked into directory hierarchy\n  (bsc#1252539 CVE-2023-53695).\n- commit 9e1ad9a\n\n- NFSD: Define a proc_layoutcommit for the FlexFiles layout type\n  (CVE-2025-40088 bsc#1252909).\n- commit b682724\n\n- hfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()\n  (CVE-2025-40082 bsc#1252775).\n- commit 71ba5db\n\n- hfsplus: fix slab-out-of-bounds read in hfsplus_strcasecmp()\n  (CVE-2025-40088 bsc#1252904).\n- commit 3401643\n\n- kernel-subpackage-spec: Do not doubly-sign modules (bsc#1251930).\n- commit 0f034b6\n\n- bpf: Explicitly check accesses to bpf_sock_addr (CVE-2025-40078\n  bsc#1252789).\n- commit 62aaf66\n\n- Squashfs: fix uninit-value in squashfs_get_parent (bsc#1252822\n  CVE-2025-40049).\n- commit acc9cea\n\n- fs: udf: fix OOB read in lengthAllocDescs handling (bsc#1252785 CVE-2025-40044).\n- commit 7dc17e9\n\n- drm/amdkfd: Fix UBSAN shift-out-of-bounds warning (bsc#1250764 CVE-2021-4460)\n- commit 033f866\n\n- pnode: terminate at peers of source (CVE-2022-50280 bsc#1249806)\n- commit 628cc9e\n\n- crypto: af_alg - Set merge to zero early in af_alg_sendmsg (CVE-2025-39931 bsc#1251100).\n- commit 904e401\n\n- btrfs: call __btrfs_remove_free_space_cache_locked on cache load failure (CVE-2022-50571 bsc#1252487)\n- commit 8e09358\n\n- drm/amdgpu: Fix integer overflow in amdgpu_cs_pass1 (bsc#1252632 CVE-2023-53707)\n- commit 73d1a0a\n\n- Update\n  patches.suse/0086-dm-thin-Fix-UAF-in-run_timer_softirq.patch\n  (git-fixes CVE-2022-50563 bsc#1252480).\n- Update patches.suse/hfs-fix-OOB-Read-in-__hfs_brec_find.patch\n  (git-fixes CVE-2022-50581 bsc#1252549).\n- Update\n  patches.suse/md-raid1-fix-potential-OOB-in-raid1_remove_disk-8b04.patch\n  (git-fixes CVE-2023-53722 bsc#1252499).\n- Update\n  patches.suse/s390-netiucv-Fix-return-type-of-netiucv_tx.patch\n  (git-fixes bsc#1212175 CVE-2022-50564 bsc#1252538).\n- Update\n  patches.suse/scsi-qla2xxx-Fix-memory-leak-in-qla2x00_probe_one.patch\n  (git-fixes CVE-2023-53696 bsc#1252513).\n- Update\n  patches.suse/scsi-ses-Fix-possible-addl_desc_ptr-out-of-bounds-accesses.patch\n  (git-fixes CVE-2023-7324 bsc#1252893).\n- commit 6722787\n\n- fbcon: Fix OOB access in font allocation (bsc#1252033)\n- commit d696663\n\n- fbcon: fix integer overflow in fbcon_do_set_font (bsc#1252033 CVE-2025-39967)\n- commit ef5b27e\n\n- kABI fix for net: vlan: fix VLAN 0 refcount imbalance of\n  toggling filtering during runtime (CVE-2025-38470 bsc#1247288).\n- commit 589d82f\n\n- i2c: mux: reg: check return value after calling platform_get_resource() (CVE-2022-50364 bsc#1250083)\n- commit 2b2cffb\n\n- ALSA: usb-audio: fix race condition to UAF in snd_usbmidi_free\n  (CVE-2025-39997 bsc#1252056).\n- commit a51d8e6\n\n- iommu/amd: Fix pci device refcount leak in ppr_notifier() (CVE-2022-50505 bsc#1251086)\n- commit 8687154\n\n- drm/hisilicon/hibmc: fix the hibmc loaded failed bug (CVE-2025-39772 bsc#1249506)\n- commit d8e1da7\n\n- ipvs: Defer ip_vs_ftp unregister during netns cleanup\n  (CVE-2025-40018 bsc#1252688).\n- commit 69275ca\n\n- ext4: fix bug in extents parsing when eh_entries == 0 and\n  eh_depth \u0026gt; 0 (bsc#1223475 CVE-2022-48631).\n- commit 70236d6\n\n- tcp: Don't call reqsk_fastopen_remove() in tcp_conn_request()\n  (git-fixes).\n- commit 757a6b5\n\n- tcp: Clear tcp_sk(sk)-\u0026gt;fastopen_rsk in tcp_disconnect()\n  (CVE-2025-39955 bsc#1251804).\n- ipv6: Fix out-of-bounds access in ipv6_find_tlv()\n  (CVE-2023-53705 bsc#1252554).\n- commit 171d7f3\n\n- Revert \u0026quot;e1000e: fix heap overflow in e1000_set_eeprom (CVE-2025-39898\u0026quot;\n  This reverts commit 2836e8d8d652cc9b552b6399525f14e15353483b.\n- commit 0a9731b\n\n- Revert \u0026quot;Refresh\u0026quot;\n  This reverts commit 9531965fe99a2d5cc7f092699c30780cd95fe9e3.\n- Revert \u0026quot;Refresh\u0026quot;\n  This reverts commit bbde1b2cc3e31ca5dab4e71e08f50d277c0dcf13.\n- commit 1af8647\n\n- md: fix soft lockup in status_resync (bsc1251318,\n  CVE-2023-53620).\n- commit 8f3ae24\n\n- i40e: add max boundary check for VF filters (CVE-2025-39968\n  bsc#1252047).\n- i40e: fix idx validation in i40e_validate_queue_map\n  (CVE-2025-39972 bsc#1252039).\n- i40e: add validation for ring_len param (CVE-2025-39973\n  bsc#1252035).\n- qed: Don't collect too many protection override GRC elements\n  (CVE-2025-39949 bsc#1251177).\n- commit bc08ffd\n\n- lib: cpu_rmap: Fix potential use-after-free in\n  irq_cpu_rmap_release() (CVE-2023-53484 bsc#1250895).\n- commit d30b615\n\n- lib: cpu_rmap: Avoid use after free on rmap-\u0026gt;obj array entries\n  (CVE-2023-53484 bsc#1250895).\n- commit 3aa6f20\n\n- wifi: cfg80211: reject auth/assoc to AP with our address\n  (CVE-2023-53540 bsc#1251053).\n- commit ee3b008\n\n- wifi: brcmfmac: cfg80211: Pass the PMK in binary instead of hex\n  (CVE-2023-53715 bsc#1252545).\n- commit 9b29c92\n\n- i40e: fix idx validation in config queues msg (CVE-2025-39971 bsc#1252052)\n- commit c33db33\n\n- i40e: Add bounds check for ch[] array (CVE-2025-39971 bsc#1252052)\n- commit bf307ec\n\n- i40e: fix input validation logic for action_meta (CVE-2025-39970 bsc#1252051)\n- commit 4e82f01\n\n- i40e: Fix filter input checks to prevent config with invalid values (CVE-2025-39970 bsc#1252051)\n- commit 57297d8\n\n- net: sched: sfb: fix null pointer access issue when sfb_init()\n  fails (CVE-2022-50356 bsc#1250040).\n- commit 882fd64\n\n- tty: serial: samsung_tty: Fix a memory leak in\n  s3c24xx_serial_getclk() when iterating clk (CVE-2023-53687\n  bsc#1251772).\n- commit 653cf6a\n\n- cifs: Release folio lock on fscache read hit (CVE-2023-53593 bsc#1251132)\n- commit 6362ac3\n\n- dmaengine: qcom: bam_dma: Fix DT error handling for num-channels/ees (CVE-2025-39923 bsc#1250741)\n- commit fbf8fb9\n\n- net: fec: Fix possible NPD in fec_enet_phy_reset_after_clk_enable() (CVE-2025-39876 bsc#1250400)\n- commit bd6ed1f\n\n- net: hv_netvsc: fix loss of early receive events from host during channel open (bsc#1252265).\n- commit e2ece38\n\n- netfilter: conntrack: fix wrong ct-\u0026gt;timeout value\n  (CVE-2023-53635 bsc#1251524).\n- commit cb2dbc3\n\n- scsi: iscsi_tcp: Check that sock is valid before\n  iscsi_set_param() (git-fixes).\n- commit f85971b\n\n- Refresh\n  patches.suse/e1000e-fix-heap-overflow-in-e1000_set_eeprom.patch.\n  Let check_add_overflow perform its intended duty.\n- commit bbde1b2\n\n- smb: client: fix smbdirect_recv_io leak in smbd_negotiate() error path (CVE-2025-39929 bsc#1251036)\n- commit 33a9326\n\n- i40e: fix IRQ freeing in i40e_vsi_request_irq_msix error path (CVE-2025-39911 bsc#1250704)\n- commit 18ff544\n\n- sctp: initialize more fields in sctp_v6_from_sk() (CVE-2025-39812 bsc#1250202)\n- commit 262d224\n\n- integrity: Fix memory leakage in keyring allocation error path (CVE-2022-50395 bsc#1250211)\n- commit 89f3524\n\n- memory: of: Fix refcount leak bug in of_get_ddr_timings() (CVE-2022-50249 bsc#1249747)\n- commit a04f0d4\n\n- openvswitch: fix lockup on tx to unregistering netdev with carrier (bsc#1249854)\n- commit 5c8a374\n\n- net: openvswitch: fix race on port output (CVE-2023-53188 bsc#1249854)\n- commit 02a1cae\n\n- ipv6: sr: Fix MAC comparison to be constant-time (CVE-2025-39702 bsc#1249317)\n- commit 6728b5c\n\n- sctp: linearize cloned gso packets in sctp_rcv (CVE-2025-38718 bsc#1249161)\n- commit 084aea4\n\n- serial: 8250: fix panic due to PSLVERR (CVE-2025-39724 bsc#1249265)\n- commit 9d4bd1b\n\n- scsi: qla4xxx: Prevent a potential error pointer dereference (CVE-2025-39676 bsc#1249302)\n- commit a7b1238\n\n- media: uvcvideo: Fix 1-byte out-of-bounds read in uvc_parse_format() (CVE-2025-38680 bsc#1249203)\n- commit c6c8afe\n\n- scsi: iscsi: iscsi_tcp: Fix null-ptr-deref while calling\n  getpeername() (CVE-2022-50459 bsc#1250850).\n- commit 3807688\n\n- blk-mq: fix NULL dereference on q-\u0026gt;elevator in\n  blk_mq_elv_switch_none (CVE-2023-53292 bsc#1250163).\n- blk-mq: protect q-\u0026gt;elevator by -\u0026gt;sysfs_lock in\n  blk_mq_elv_switch_none (CVE-2023-53292 bsc#1250163).\n- commit f60e1b9\n\n- netfilter: conntrack: Avoid nf_ct_helper_hash uses after free\n  (CVE-2023-53619 bsc#1251743).\n- commit d9a3ca9\n\n- NFSv4.1: fix backchannel max_resp_sz verification check\n  (bsc#1247518).\n- commit 4f042cf\n\n- doc/README.SUSE: Correct the character used for TAINT_NO_SUPPORT\n  The character was previously 'N', but upstream used it for TAINT_TEST,\n  which prompted the change of TAINT_NO_SUPPORT to 'n'. This occurred in\n  commit c35dc3823d08 (\u0026quot;Update to 6.0-rc1\u0026quot;) on master and in d016c04d731d\n  (\u0026quot;Bump to 6.4 kernel (jsc#PED-4593)\u0026quot;) for SLE15-SP6 (and onwards).\n  Update the documentation to reflect this change.\n- commit f42ecf5\n\n- ALSA: ac97: Fix possible error value of *rac97 (CVE-2023-53648\n  bsc#1251750).\n- ALSA: ac97: Fix possible NULL dereference in snd_ac97_mixer\n  (CVE-2023-53648 bsc#1251750).\n- commit 3add5a8\n\n- tipc: add tipc_bearer_min_mtu to calculate min mtu\n  (CVE-2023-53517 bsc1250919).\n- commit af0b7c0\n\n- tipc: do not update mtu if msg_max is too small in mtu\n  negotiation (CVE-2023-53517 bsc#1250919).\n- commit 246819a\n\n- btrfs: do not BUG_ON() on ENOMEM when dropping extent items for a range (CVE-2022-50293 bsc#1249752)\n- commit 674444e\n\n- btrfs: exit gracefully if reloc roots don't match (CVE-2023-53183 bsc#1249863)\n- commit 5aefca3\n\n- btrfs: fix BUG_ON condition in btrfs_cancel_balance (CVE-2023-53339 bsc#1250329)\n- commit e64f98a\n\n- hfsplus: fix slab-out-of-bounds in hfsplus_bnode_read()\n  (bsc#1249260 CVE-2025-38714).\n- commit d550dcb\n\n- nfsd: handle get_client_locked() failure in\n  nfsd4_setclientid_confirm() (bsc#1249169 CVE-2025-38724).\n- commit 7ce8b22\n\n- net/sched: sch_fq: fix integer overflow of \u0026quot;credit\u0026quot;\n  (CVE-2023-53624 bsc#1251333).\n- commit 4033336\n\n- pNFS: Fix uninited ptr deref in block/scsi layout (bsc#1249215\n  CVE-2025-38691).\n- commit b3165ea\n\n- Update\n  patches.suse/0003-fbdev-omapfb-lcd_mipid-Fix-an-error-handling-path-in.patch\n  (bsc#1154048 CVE-2023-53650 bsc#1251283).\n- Update patches.suse/0087-dm-cache-Fix-UAF-in-destroy.patch\n  (git-fixes CVE-2022-50496 bsc#1251091).\n- Update\n  patches.suse/0088-dm-thin-Fix-ABBA-deadlock-between-shrink_slab-and-dm_pool_abort_metadata.patch\n  (git-fixes CVE-2022-50549 bsc#1251550).\n- Update\n  patches.suse/0092-dm-thin-Use-last-transaction-s-pmd-root-when-commit-failed.patch\n  (git-fixes CVE-2022-50534 bsc#1251292).\n- Update\n  patches.suse/Input-raspberrypi-ts-fix-refcount-leak-in-rpi_ts_pro.patch\n  (git-fixes CVE-2023-53533 bsc#1251080).\n- Update\n  patches.suse/NFSD-Protect-against-send-buffer-overflow-in-NFSv3-Rdir.patch\n  (bsc#1205128 CVE-2022-43945 bsc#1210124 CVE-2022-50487\n  bsc#1251208).\n- Update\n  patches.suse/bcache-Fix-__bch_btree_node_alloc-to-make-the-failur-80fc.patch\n  (git-fixes CVE-2023-53681 bsc#1251769).\n- Update\n  patches.suse/bpf-sockmap-Fix-repeated-calls-to-sock_put-when-msg-.patch\n  (bsc#1235485 CVE-2024-56633 CVE-2022-50536 bsc#1251293).\n- Update\n  patches.suse/btrfs-output-extra-debug-info-if-we-failed-to-find-a.patch\n  (bsc#1215136 CVE-2023-53672 bsc#1251780).\n- Update\n  patches.suse/dm-integrity-call-kmem_cache_destroy-in-dm_integrity-6b79.patch\n  (git-fixes CVE-2023-53604 bsc#1251210).\n- Update\n  patches.suse/firmware-raspberrypi-fix-possible-memory-leak-in-rpi.patch\n  (git-fixes CVE-2022-50537 bsc#1251294).\n- Update\n  patches.suse/fs-hfsplus-remove-WARN_ON-from-hfsplus_cat_-read-write-_inode.patch\n  (git-fixes CVE-2023-53683 bsc#1251329).\n- Update\n  patches.suse/gfs2-Fix-possible-data-races-in-gfs2_show_options.patch\n  (git-fixes CVE-2023-53622 bsc#1251777).\n- Update\n  patches.suse/ipmi-Cleanup-oops-on-initialization-failure.patch\n  (FATE#326156 CVE-2023-53611 bsc#1251123).\n- Update\n  patches.suse/media-coda-Add-check-for-dcoda_iram_alloc.patch\n  (git-fixes CVE-2022-50501 bsc#1251099).\n- Update patches.suse/media-coda-Add-check-for-kmalloc.patch\n  (git-fixes CVE-2022-50509 bsc#1251522).\n- Update patches.suse/media-radio-shark-Add-endpoint-checks.patch\n  (git-fixes CVE-2023-53644 bsc#1251736).\n- Update\n  patches.suse/msft-hv-2870-Drivers-hv-vmbus-Don-t-dereference-ACPI-root-object-.patch\n  (git-fixes CVE-2023-53647 bsc#1251732).\n- Update\n  patches.suse/net-cdc_ncm-Deal-with-too-low-values-of-dwNtbOutMaxS.patch\n  (git-fixes CVE-2023-53667 bsc#1251761).\n- Update\n  patches.suse/ocfs2-fix-defrag-path-triggering-jbd2-ASSERT.patch\n  (git-fixes CVE-2023-53564 bsc#1251072).\n- Update\n  patches.suse/powerpc-rtas-avoid-scheduling-in-rtas_os_term.patch\n  (bsc#1065729 CVE-2022-50504 bsc#1251182).\n- Update\n  patches.suse/ring-buffer-Fix-deadloop-issue-on-reading-trace_pipe.patch\n  (git-fixes CVE-2023-53668 bsc#1251286).\n- Update\n  patches.suse/ring-buffer-Sync-IRQ-works-before-buffer-destruction.patch\n  (git-fixes CVE-2023-53587 bsc#1251128).\n- Update\n  patches.suse/s390-zcrypt-don-t-leak-memory-if-dev_set_name-fails.patch\n  (git-fixes bsc#1215152 CVE-2023-53568 bsc#1251035).\n- Update\n  patches.suse/scsi-mpt3sas-Fix-possible-resource-leaks-in-mpt3sas_transport_port_add.patch\n  (git-fixes CVE-2022-50532 bsc#1251300).\n- Update\n  patches.suse/scsi-qla2xxx-Avoid-fcport-pointer-dereference.patch\n  (bsc#1213747 CVE-2023-53603 bsc#1251180).\n- Update\n  patches.suse/scsi-qla2xxx-Fix-crash-when-I-O-abort-times-out.patch\n  (jsc#PED-568 CVE-2022-50493 bsc#1251088).\n- Update\n  patches.suse/scsi-qla2xxx-Fix-deletion-race-condition.patch\n  (bsc#1213747 CVE-2023-53615 bsc#1251113).\n- Update\n  patches.suse/scsi-ses-Fix-possible-desc_ptr-out-of-bounds-accesses.patch\n  (git-fixes CVE-2023-53675 bsc#1251325).\n- Update\n  patches.suse/usb-host-xhci-Fix-potential-memory-leak-in-xhci_allo.patch\n  (git-fixes CVE-2022-50544 bsc#1251725).\n- Update\n  patches.suse/xhci-Remove-device-endpoints-from-bandwidth-list-whe.patch\n  (git-fixes CVE-2022-50470 bsc#1251202).\n- commit a902bff\n\n- fs: fix UAF/GPF bug in nilfs_mdt_destroy (CVE-2022-50367 bsc#1250277)\n- commit d8f49e5\n\n- cnic: Fix use-after-free bugs in cnic_delete_task\n  (CVE-2025-39945 bsc#1251230).\n- iavf: Fix use-after-free in free_netdev (CVE-2023-53556\n  bsc#1251059).\n- commit afb4745\n\n- wifi: iwlwifi: mvm: don't trust firmware n_channels\n  (CVE-2023-53589 bsc#1251129).\n- commit 988e8e2\n\n- driver core: fix resource leak in device_add() (CVE-2023-53594\n  bsc#1251166).\n- commit 5614ed9\n\n- wifi: brcmfmac: ensure CLM version is null-terminated to\n  prevent stack-out-of-bounds (CVE-2023-53582 bsc#1251061).\n- commit fad0717\n\n- tracing: Add down_write(trace_event_sem) when adding trace event\n  (bsc#1248211 CVE-2025-38539).\n- commit e8323f2\n\n- ftrace: Also allocate and copy hash for reading of filter files\n  (bsc#1250032 CVE-2025-39813).\n- commit fc74b08\n\n- ext4: add EXT4_IGET_BAD flag to prevent unexpected bad inode\n  (bsc#1251197 CVE-2022-50485).\n- commit e7befdc\n\n- fs: writeback: fix use-after-free in __mark_inode_dirty()\n  (bsc#1250455 CVE-2025-39866).\n- commit 71bbea8\n\n- fs: Prevent file descriptor table allocations exceeding INT_MAX\n  (bsc#1249512 CVE-2025-39756).\n- commit a3d8b0c\n\n- ftrace: Fix potential warning in trace_printk_seq during\n  ftrace_dump (bsc#1250032 CVE-2025-39813).\n- commit 4308207\n\n- trace/fgraph: Fix the warning caused by missing unregister\n  notifier (bsc#1248211 CVE-2025-38539).\n- commit 44bb2c8\n\n- ipv6: Add lwtunnel encap size of all siblings in nexthop\n  calculation (CVE-2023-53477 bsc#1250840).\n- commit 9c1503d\n\n- drivers: base: Free devm resources when unregistering a device\n  (CVE-2023-53596 bsc#1251161).\n- commit b016181\n\n- media: v4l2-mem2mem: add lock to protect parameter num_rdy\n  (CVE-2023-53519 bsc#1250964).\n- commit d68a51f\n\n- ip_vti: fix potential slab-use-after-free in decode_session6\n  (CVE-2023-53559 bsc#1251052).\n- commit 688b608\n\n- Refresh\n  patches.suse/e1000e-fix-heap-overflow-in-e1000_set_eeprom.patch.\n- commit 9531965\n\n- ACPICA: Fix use-after-free in\n  acpi_ut_copy_ipackage_to_ipackage() (CVE-2022-50423\n  bsc#1250784).\n- commit e5308a6\n\n- scsi: lpfc: Fix buffer free/clear order in deferred receive path\n  (CVE-2025-39841 bsc#1250274).\n- scsi: libiscsi: Initialize iscsi_conn-\u0026gt;dd_data only if memory\n  is allocated (CVE-2025-38700 bsc#1249182).\n- scsi: bfa: Double-free fix (CVE-2025-38699 bsc#1249224).\n- scsi: lpfc: Fix use-after-free KFENCE violation during sysfs\n  firmware write (CVE-2023-53282 bsc#1250311).\n- scsi: target: iscsi: Fix a race condition between login_work\n  and the login thread (CVE-2022-50350 bsc#1250261).\n- commit 204e345\n\n- net: usbnet: Fix WARNING in usbnet_start_xmit/usb_submit_urb\n  (CVE-2023-53548 bsc#1251066).\n- blacklist.conf: CVE unknown at the time\n- commit 7beb085\n\n- drm/rockchip: lvds: fix PM usage counter unbalance in poweron (bsc#1250768 CVE-2022-50443)\n- commit b56de15\n\n- fs: dlm: fix invalid derefence of sb_lvbptr (bsc#1251741\n  CVE-2022-50516).\n- commit 09e6897\n\n- af_unix: Fix data-races around user-\u0026gt;unix_inflight\n  (CVE-2023-53204 bsc#1249682).\n- commit 77897d4\n\n- media: si470x: Fix use-after-free in si470x_int_in_callback()\n  (CVE-2022-50542 bsc#1251330).\n- commit 29b7473\n\n- ACPI: processor: idle: Check acpi_fetch_acpi_dev() return value (CVE-2022-50327 bsc#1249859)\n- commit 18b9822\n\n- scsi: lpfc: Check for hdwq null ptr when cleaning up lpfc_vport\n  structure (CVE-2025-38695 bsc#1249285).\n- commit a538909\n\n- cxl: fix possible null-ptr-deref in cxl_guest_init_afu|adapter()\n  (CVE-2022-50481 bsc#1251051).\n- commit e12557d\n\n- lwt: Fix return values of BPF xmit ops (bsc#1250074\n  CVE-2023-53338).\n- commit 6dcc27e\n\n- i2c: ismt: Fix an out-of-bounds bug in ismt_access() (CVE-2022-50394 bsc#1250107)\n- commit 473df14\n\n- wifi: ath9k: don't allow to overwrite ENDPOINT0 attributes (CVE-2023-53185 bsc#1249820)\n- commit ee941e7\n\n- irqchip/alpine-msi: Fix refcount leak in alpine_msix_init_domains (CVE-2023-53191 bsc#1249721)\n- commit 3a22168\n\n- ubi: Fix unreferenced object reported by kmemleak in ubi_resize_volume() (CVE-2023-53271 bsc#1249916)\n- commit 0c5e1f7\n\n- media: bdisp: Add missing check for create_workqueue (CVE-2023-53289 bsc#1249941)\n- commit a94aab1\n\n- crypto: seqiv - Handle EBUSY correctly (CVE-2023-53373 bsc#1250137)\n- commit dd42b1d\n\n- iommu/mediatek: Fix crash on isr after kexec() (CVE-2022-50236\n  bsc#1249702).\n- commit 97b644f\n\n- iw_cxgb4: Fix potential NULL dereference in c4iw_fill_res_cm_id_entry() (CVE-2023-53476 bsc#1250839)\n- commit 04895ff\n\n- e1000e: fix heap overflow in e1000_set_eeprom (CVE-2025-39898\n  bsc#1250742).\n- net: add vlan_get_protocol_and_depth() helper (CVE-2023-53433\n  bsc#1250164).\n- commit 2836e8d\n\n- drivers: net: qlcnic: Fix potential memory leak in qlcnic_sriov_init() (CVE-2022-50242 bsc#1249696)\n- commit 2d1b74b\n\n- igb: Do not bring the device up after non-fatal error\n  (CVE-2023-53148 bsc#1249842).\n- commit d58ebba\n\n- net: If sock is dead don't access sock's sk_wq in\n  sk_stream_wait_memory (CVE-2022-50409 bsc#1250392).\n- commit d8d8ecd\n\n- ppp: fix memory leak in pad_compress_skb (CVE-2025-39847\n  bsc#1250292).\n- gve: prevent ethtool ops after shutdown (CVE-2025-38735\n  bsc#1249288).\n- igb: Fix igb_down hung on surprise removal (CVE-2023-53148\n  bsc#1249842).\n- qlcnic: prevent -\u0026gt;dcb use-after-free on qlcnic_dcb_enable()\n  failure (CVE-2022-50288 bsc#1249802).\n- igb: Do not free q_vector unless new one was allocated\n  (CVE-2022-50252 bsc#1249846).\n- commit 0b4ef82\n\n- Update\n  patches.suse/0001-media-dvb-usb-az6027-fix-null-ptr-deref-in-az6027_i2.patch\n  (bsc#1209291 CVE-2023-28328 CVE-2022-50272 bsc#1249808).\n- Update\n  patches.suse/0001-ubi-ensure-that-VID-header-offset-VID-header-size-al.patch\n  (bsc#1210584 CVE-2023-53265 bsc#1249908).\n- Update\n  patches.suse/0001-wifi-brcmfmac-slab-out-of-bounds-read-in-brcmf_get_a.patch\n  (bsc#1209287 CVE-2023-1380 CVE-2023-53213 bsc#1249918).\n- Update\n  patches.suse/0012-md-Replace-snprintf-with-scnprintf.patch\n  (git-fixes bsc#1164051 CVE-2022-50299 bsc#1249734).\n- Update patches.suse/NFS-Fix-an-Oops-in-nfs_d_automount.patch\n  (git-fixes CVE-2022-50385 bsc#1250131).\n- Update\n  patches.suse/NFSD-Protect-against-send-buffer-overflow-in-NFSv2-R.patch\n  (bsc#1205128 CVE-2022-43945 bsc#1210124 CVE-2022-50410\n  bsc#1250187).\n- Update\n  patches.suse/NFSD-Protect-against-send-buffer-overflow-in-NFSv2-Rdir.patch\n  (bsc#1205128 CVE-2022-43945 CVE-2022-50235 bsc#1249667).\n- Update\n  patches.suse/PCI-ASPM-Disable-ASPM-on-MFD-function-removal-to-avo.patch\n  (git-fixes CVE-2023-53446 bsc#1250145).\n- Update\n  patches.suse/blk-mq-fix-possible-memleak-when-register-hctx-failed-4b7a.patch\n  (git-fixes CVE-2022-50434 bsc#1250792).\n- Update\n  patches.suse/bpf-make-sure-skb-len-0-when-redirecting-to-a-tunnel.patch\n  (CVE-2022-49975 bsc#1245196 CVE-2022-50253 bsc#1249912).\n- Update\n  patches.suse/btrfs-fix-resolving-backrefs-for-inline-extent-follo.patch\n  (bsc#1213133 CVE-2022-50456 bsc#1250856).\n- Update\n  patches.suse/chardev-fix-error-handling-in-cdev_device_add.patch\n  (git-fixes CVE-2022-50282 bsc#1249739).\n- Update\n  patches.suse/cifs-Fix-memory-leak-when-build-ntlmssp-negotiate-blob-failed.patch\n  (bsc#1190317 CVE-2022-50372 bsc#1250052).\n- Update\n  patches.suse/cifs-Fix-warning-and-UAF-when-destroy-the-MR-list.patch\n  (bsc#1190317 CVE-2023-53427 bsc#1250168).\n- Update patches.suse/cifs-Fix-xid-leak-in-cifs_create-.patch\n  (bsc#1190317 CVE-2022-50351 bsc#1249925).\n- Update patches.suse/cifs-Fix-xid-leak-in-cifs_flock-.patch\n  (bsc#1190317 CVE-2022-50460 bsc#1250879).\n- Update\n  patches.suse/cifs-fix-DFS-traversal-oops-without-CONFIG_CIFS_DFS_UPCALL.patch\n  (bsc#1190317 CVE-2023-53246 bsc#1249867).\n- Update\n  patches.suse/drm-vmwgfx-Validate-the-box-size-for-the-snooped-cur.patch\n  (bsc#1203332 CVE-2022-36280 CVE-2022-50440 bsc#1250853).\n- Update\n  patches.suse/ext4-avoid-crash-when-inline-data-creation-follows-D.patch\n  (bsc#1206883 CVE-2022-50435 bsc#1250799).\n- Update\n  patches.suse/ext4-avoid-deadlock-in-fs-reclaim-with-page-writebac.patch\n  (bsc#1213016 CVE-2023-53149 bsc#1249882).\n- Update\n  patches.suse/ext4-fix-i_disksize-exceeding-i_size-problem-in-pari.patch\n  (bsc#1213015 CVE-2023-53270 bsc#1249872).\n- Update\n  patches.suse/ext4-fix-null-ptr-deref-in-ext4_write_info.patch\n  (bsc#1206884 CVE-2022-50344 bsc#1250014).\n- Update\n  patches.suse/ext4-init-quota-for-old.inode-in-ext4_rename.patch\n  (bsc#1207629 CVE-2022-50346 bsc#1250044).\n- Update\n  patches.suse/firmware-dmi-sysfs-Fix-null-ptr-deref-in-dmi_sysfs_r.patch\n  (bsc#1238467 CVE-2023-53250 bsc#1249727).\n- Update\n  patches.suse/genirq-ipi-Fix-NULL-pointer-deref-in-irq_data_get_af.patch\n  (git-fixes CVE-2023-53332 bsc#1249951).\n- Update\n  patches.suse/ipv6-addrconf-fix-a-potential-refcount-underflow-for.patch\n  (git-fixes CVE-2023-53189 bsc#1249894).\n- Update\n  patches.suse/jbd2-check-jh-b_transaction-before-removing-it-from-.patch\n  (bsc#1214953 CVE-2023-53526 bsc#1250928).\n- Update\n  patches.suse/kernfs-fix-use-after-free-in-__kernfs_remove.patch\n  (git-fixes CVE-2022-50432 bsc#1250851).\n- Update\n  patches.suse/kprobes-Fix-check-for-probe-enabled-in-kill_kprobe.patch\n  (git-fixes CVE-2022-50266 bsc#1249810).\n- Update patches.suse/md-fix-a-crash-in-mempool_free-3410.patch\n  (git-fixes CVE-2022-50381 bsc#1250257).\n- Update\n  patches.suse/md-raid10-check-slab-out-of-bounds-in-md_bitmap_get_-3018.patch\n  (git-fixes CVE-2023-53357 bsc#1249994).\n- Update\n  patches.suse/md-raid10-fix-leak-of-r10bio-remaining-for-recovery-2620.patch\n  (git-fixes CVE-2023-53299 bsc#1249927).\n- Update\n  patches.suse/md-raid10-fix-null-ptr-deref-of-mreplace-in-raid10_s-3481.patch\n  (git-fixes CVE-2023-53380 bsc#1250198).\n- Update\n  patches.suse/md-raid10-fix-wrong-setting-of-max_corr_read_errors-f8b2.patch\n  (git-fixes CVE-2023-53313 bsc#1249911).\n- Update\n  patches.suse/md-raid10-prevent-soft-lockup-while-flush-writes-0104.patch\n  (git-fixes CVE-2023-53151 bsc#1249865).\n- Update\n  patches.suse/msft-hv-2841-scsi-storvsc-Fix-handling-of-virtual-Fibre-Channel-t.patch\n  (git-fixes CVE-2023-53245 bsc#1249641).\n- Update\n  patches.suse/net-fec-Better-handle-pm_runtime_get-failing-in-.rem.patch\n  (git-fixes CVE-2023-53308 bsc#1250045).\n- Update\n  patches.suse/netfilter-conntrack-dccp-copy-entire-header-to-stack.patch\n  (CVE-2023-39197 bsc#1216976 CVE-2023-53333 bsc#1249949).\n- Update\n  patches.suse/netlink-avoid-infinite-retry-looping-in-netlink_unic.patch\n  (CVE-2025-38465 bsc#1247118 CVE-2025-38727 bsc#1249166).\n- Update\n  patches.suse/nfsd-under-NFSv4.1-fix-double-svc_xprt_put-on-rpc_cr.patch\n  (git-fixes CVE-2022-50401 bsc#1250140).\n- Update\n  patches.suse/ocfs2-fix-memory-leak-in-ocfs2_stack_glue_init.patch\n  (git-fixes CVE-2022-50289 bsc#1249981).\n- Update\n  patches.suse/powerpc-Don-t-try-to-copy-PPR-for-task-with-NULL-pt_.patch\n  (bsc#1065729 CVE-2023-53326 bsc#1250071).\n- Update\n  patches.suse/pstore-ram-Check-start-of-empty-przs-during-init.patch\n  (git-fixes CVE-2023-53331 bsc#1249950).\n- Update\n  patches.suse/rbd-avoid-use-after-free-in-do_rbd_add-when-rbd_dev_-f7c4.patch\n  (git-fixes CVE-2023-53307 bsc#1250043).\n- Update\n  patches.suse/sched-fair-Don-t-balance-task-to-its-current-running-CPU.patch\n  (git fixes (sched) CVE-2023-53215 bsc#1250397).\n- Update\n  patches.suse/scsi-core-Fix-possible-memory-leak-if-device_add-fails.patch\n  (git-fixes CVE-2023-53174 bsc#1250024).\n- Update\n  patches.suse/scsi-fcoe-Fix-transport-not-deattached-when-fcoe_if_init-fails.patch\n  (git-fixes CVE-2022-50414 bsc#1250183).\n- Update\n  patches.suse/scsi-libsas-Fix-use-after-free-bug-in-smp_execute_task_sg.patch\n  (git-fixes CVE-2022-50422 bsc#1250774).\n- Update patches.suse/scsi-mpt3sas-Fix-a-memory-leak.patch\n  (git-fixes CVE-2023-53512 bsc#1250915).\n- Update\n  patches.suse/scsi-qla2xxx-Fix-potential-NULL-pointer-dereference.patch\n  (bsc#1213747 CVE-2023-53451 bsc#1250831).\n- Update\n  patches.suse/scsi-qla2xxx-Pointer-may-be-dereferenced.patch\n  (bsc#1213747 CVE-2023-53150 bsc#1249853).\n- Update\n  patches.suse/scsi-qla2xxx-Remove-unused-nvme_ls_waitq-wait-queue.patch\n  (bsc#1213747 CVE-2023-53280 bsc#1249938).\n- Update\n  patches.suse/scsi-qla2xxx-Use-raw_smp_processor_id-instead-of-smp.patch\n  (git-fixes CVE-2023-53530 bsc#1250949).\n- Update\n  patches.suse/scsi-qla2xxx-Wait-for-io-return-on-terminate-rport.patch\n  (bsc#1211960 CVE-2023-53322 bsc#1250323).\n- Update\n  patches.suse/scsi-qla4xxx-Add-length-check-when-parsing-nlattrs.patch\n  (git-fixes CVE-2023-53456 bsc#1250765).\n- Update\n  patches.suse/scsi-ses-Fix-slab-out-of-bounds-in-ses_intf_remove.patch\n  (git-fixes CVE-2023-53521 bsc#1250965).\n- Update\n  patches.suse/scsi-snic-Fix-possible-memory-leak-if-device_add-fails.patch\n  (git-fixes CVE-2023-53436 bsc#1250156).\n- Update\n  patches.suse/tpm-tpm_crb-Add-the-missed-acpi_put_table-to-fix-mem.patch\n  (bsc#1082555 CVE-2022-50389 bsc#1250121).\n- Update\n  patches.suse/tracing-Fix-race-issue-between-cpu-buffer-write-and-swap.patch\n  (git-fixes CVE-2023-53368 bsc#1249979).\n- Update\n  patches.suse/udf-Do-not-bother-merging-very-long-extents.patch\n  (bsc#1213040 CVE-2023-53506 bsc#1250963).\n- Update\n  patches.suse/udf-Do-not-update-file-length-for-failed-writes-to-i.patch\n  (bsc#1213041 CVE-2023-53295 bsc#1250324).\n- Update\n  patches.suse/udf-Fix-uninitialized-array-access-for-some-pathname.patch\n  (bsc#1214967 CVE-2023-53165 bsc#1250395).\n- Update\n  patches.suse/vhost-vsock-Use-kvmalloc-kvfree-for-larger-packets.patch\n  (git-fixes CVE-2022-50271 bsc#1249740).\n- Update\n  patches.suse/virtio_net-Fix-error-unwinding-of-XDP-initialization.patch\n  (git-fixes CVE-2023-53499 bsc#1250818).\n- Update patches.suse/xen-gntdev-Prevent-leaking-grants.patch\n  (git-fixes CVE-2022-50257 bsc#1249743).\n- Update\n  patches.suse/xfrm-add-NULL-check-in-xfrm_update_ae_params.patch\n  (bsc#1213666 CVE-2023-3772 CVE-2023-53147 bsc#1249880).\n- commit f14b4f5\n\n- i40e: Fix potential invalid access when MAC list is empty (CVE-2025-39853 bsc#1250275)\n- commit 15849c1\n\n- x86/tsc: Append the 'tsc=' description for the 'tsc=unstable'\n  boot parameter (git-fixes).\n- Refresh\n  patches.suse/0004-x86-cpu-Add-a-tsx-cmdline-option-with-TSX-disabled-b.patch.\n- commit fc36e71\n\n- Bluetooth: Fix use-after-free in l2cap_sock_cleanup_listen()\n  (CVE-2025-39860 bsc#1250247).\n- commit db1f312\n\n- rpm/check-for-config-changes: ignore CONFIG_SCHED_PROXY_EXEC, too (bsc#1250946)\n  CONFIG_SCHED_PROXY_EXEC is set only when the debug is off, exclusive\n  to CONFIG_SCHED_CLASS_EXT.\n- commit ac06fa9\n\n- net: bridge: fix soft lockup in br_multicast_query_expired()\n  (CVE-2025-39773 bsc#1249504).\n- net: bridge: mcast: add and enforce startup query interval\n  minimum (CVE-2025-39773 bsc1249504).\n- net: bridge: mcast: add and enforce query interval minimum\n  (CVE-2025-39773 bsc1249504).\n- commit 86febde\n\n- HID: asus: fix UAF via HID_CLAIMED_INPUT validation\n  (CVE-2025-39824 bsc#1250007).\n- commit 74f7410\n\n- ip6mr: Fix skb_under_panic in ip6mr_cache_report()\n  (CVE-2023-53365 bsc#1249988).\n- commit 31b9909\n\n- dmaengine: ti: edma: Fix memory allocation size for\n  queue_priority_map (CVE-2025-39869 bsc#1250406).\n- commit 0c7b875\n\n- netfilter: ctnetlink: remove refcounting in expectation dumpers\n  (CVE-2025-39764 bsc#1249513).\n- commit 21919f3\n\n- net/sched: Fix backlog accounting in qdisc_dequeue_internal\n  (CVE-2025-39677 bsc#1249300).\n- commit 019e014\n\n- cifs: prevent NULL pointer dereference in UTF16 conversion\n  (bsc#1250365, CVE-2025-39838).\n- commit a653056\n\n- l2tp: remove unused list_head member in l2tp_tunnel (git-fixes).\n- commit a146724\n\n- Refresh\n  patches.suse/l2tp-prevent-lockdep-issue-in-l2tp_tunnel_register.patch.\n  Move the call to release_sock() to match upstream. This will make\n  future backports easier.\n- commit 7c5477e\n\n- Bluetooth: eir: Fix using strlen with\n  hdev-\u0026gt;{dev_name,short_name} (CVE-2022-50233 bsc#1246968).\n- commit 7861eb7\n\n- Update\n  patches.suse/ACPICA-Fix-error-code-path-in-acpi_ds_call_control_method.patch\n  (bsc#1250393 CVE-2022-50411).\n  Fix wrongly C\u0026amp;Ped bug and CVE number.\n- commit c1344a1\n\n- ocfs2: fix recursive semaphore deadlock in fiemap call\n  (bsc#1250407 CVE-2025-39885).\n- commit fa96337\n\n- mm/smaps: fix race between smaps_hugetlb_range and migration\n  (CVE-2025-39754 bsc#1249524).\n- commit c2c05c6\n\n- media: cx88: Fix a null-ptr-deref bug in buffer_prepare()\n  (CVE-2022-50359 bsc#1250269).\n- commit 680e9a1\n\n- mISDN: hfcpci: Fix warning when deleting uninitialized timer\n  (CVE-2025-39833 bsc#1250028).\n- commit 44dd6de\n\n- net: ena: fix shift-out-of-bounds in exponential backoff (CVE-2023-53272 bsc#1249917)\n- commit 79f3645\n\n- Refresh\n  patches.suse/btrfs-fix-deadlock-when-aborting-transaction-during-.patch.\n- Refresh\n  patches.suse/btrfs-prevent-ioctls-from-interfering-with-a-swap-file.patch.\n- commit df48fdf\n\n- wifi: brcmfmac: fix use-after-free when rescheduling\n  brcmf_btcoex_info work (CVE-2025-39863 bsc#1250281).\n- commit b50d5fe\n\n- serial: 8250: Fix oops for port-\u0026gt;pm on uart_change_pm()\n  (CVE-2023-53176 bsc#1249991).\n- commit ef178fc\n\n- Bluetooth: L2CAP: Fix user-after-free (CVE-2022-50386\n  bsc#1250301).\n- Refresh\n  patches.suse/Bluetooth-L2CAP-Fix-corrupted-list-in-hci_chan_del.patch.\n- commit ef8e23b\n\n- mm: zswap: fix missing folio cleanup in writeback race path\n  (CVE-2023-53178 bsc#1249827 git-fix).\n- commit 556f4d6\n\n- mm: fix zswap writeback race condition (CVE-2023-53178\n  bsc#1249827).\n- commit 58cd2c5\n\n- Bluetooth: hci_sysfs: Fix attempting to call device_add multiple\n  times (CVE-2022-50419 bsc#1250394).\n- commit b4e8638\n\n- wifi: brcmfmac: fix use-after-free bug in\n  brcmf_netdev_start_xmit() (CVE-2022-50408 bsc#1250391).\n- commit d1d8e28\n\n- ALSA: hda: Fix Oops by 9.1 surround channel names\n  (CVE-2023-53400 bsc#1250328).\n- commit ba820fb\n\n- wifi: mac80211_hwsim: drop short frames (CVE-2023-53321\n  bsc#1250313).\n- commit 6ddc75a\n\n- tee: fix NULL pointer dereference in tee_shm_put (CVE-2025-39865\n  bsc#1250294).\n- commit f721184\n\n- serial: 8250: Reinit port-\u0026gt;pm on port specific driver unbind\n  (CVE-2023-53176 bsc#1249991).\n- tty: serial: fsl_lpuart: disable dma rx/tx use flags in\n  lpuart_dma_shutdown (CVE-2022-50375 bsc#1250132).\n- Refresh\n  patches.suse/tty-serial-fsl_lpuart-fix-race-on-RX-DMA-shutdown.patch.\n- drivers: serial: jsm: fix some leaks in probe (CVE-2022-50312\n  bsc#1249716).\n- commit 1aca549\n\n- wifi: ath9k: verify the expected usb_endpoints are present\n  (CVE-2022-50297 bsc#1250250).\n- commit 6950b3a\n\n- wifi: iwl4965: Add missing check for\n  create_singlethread_workqueue() (CVE-2023-53302 bsc#1249958).\n- commit 8f88848\n\n- nfc: fix memory leak of se_io context in nfc_genl_se_io\n  (CVE-2023-53298 bsc#1249944).\n- Refresh\n  patches.suse/nfc-change-order-inside-nfc_se_io-error-path.patch.\n- commit d32133b\n\n- x86/MCE: Always save CS register on AMD Zen IF Poison errors\n  (CVE-2023-53438 bsc#1250180).\n- commit bf84e9b\n\n- wifi: mwifiex: avoid possible NULL skb pointer dereference\n  (CVE-2023-53384 bsc#1250127).\n- commit d34c18b\n\n- ALSA: usb-audio: Fix size validation in convert_chmap_v3()\n  (CVE-2025-39757 bsc#1249515).\n- commit 0ab86d7\n\n- HID: hid-ntrig: fix unable to handle page fault in\n  ntrig_report_version() (CVE-2025-39808 bsc#1250088).\n- commit 5536678\n\n- Bluetooth: L2CAP: Fix use-after-free (CVE-2023-53305\n  bsc#1250049).\n- Refresh\n  patches.suse/Bluetooth-L2CAP-Fix-corrupted-list-in-hci_chan_del.patch.\n- commit ac84db6\n\n- wifi: iwl3945: Add missing check for\n  create_singlethread_workqueue (CVE-2023-53277 bsc#1249936).\n- commit 4da361d\n\n- soc: qcom: mdt_loader: Deal with zero e_shentsize\n  (CVE-2025-39787 bsc#1249545).\n- soc: qcom: mdt_loader: Fix error return values in\n  mdt_header_valid() (CVE-2025-39787 bsc#1249545).\n- commit 529120f\n\n- ALSA: usb-audio: Validate UAC3 cluster segment descriptors\n  (CVE-2025-39757 bsc#1249515).\n- soc: qcom: mdt_loader: Ensure we don't read past the ELF header\n  (CVE-2025-39787 bsc#1249545).\n- commit 5d06f31\n\n- btrfs: abort transaction on unexpected eb generation at\n  btrfs_copy_root() (bsc#1250177 CVE-2025-39800).\n- Refresh\n  patches.suse/0001-btrfs-Introduce-support-for-FSID-change-without-meta.patch.\n- Refresh\n  patches.suse/0002-btrfs-Remove-fsid-metadata_fsid-fields-from-btrfs_in.patch.\n- commit ebb9819\n\n- kernel-source.spec: Depend on python3-base for build\n  Both kernel-binary and kernel-docs already have this dependency.\n  Adding it to kernel-source makes it possible to use python in shared\n  build scripts.\n- commit 72fdedd\n\n- kernel-source: Do not list mkspec and its inputs as sources\n  (bsc#1250522).\n  This excludes the files from the src.rpm. The next step is to remove\n  these files in tar-up so that they do not get uploaded to OBS either.\n  As there is only one version of tar-up these files need to be removed\n  from all kernels.\n- commit e72b8a2\n\n- bpf: cpumap: Fix memory leak in cpu_map_update_elem (bsc#1250150\n  CVE-2023-53441).\n- commit 77b4844\n\n- drivers/md/md-bitmap: check the return value of\n  md_bitmap_get_counter() (CVE-2022-50402, bsc#1250363).\n- commit b998cb4\n\n- ACPICA: Add AML_NO_OPERAND_RESOLVE flag to Timer (bsc#1250358\n  CVE-2023-53395).\n- commit 16cf2b4\n\n- ACPICA: Fix error code path in acpi_ds_call_control_method()\n  (bsc#1249615 CVE-2025-39763).\n- commit 00cd9ae\n\n- rpm: Link arch-symbols script from scripts directory.\n- commit 90b2abb\n\n- skbuff: Account for tail adjustment during pull operations\n  (CVE-2022-50365 bsc#1250084).\n- commit 2c0b58b\n\n- btrfs: fix deadlock when aborting transaction during relocation\n  with scrub (bsc#1250018 CVE-2023-53348).\n- commit 6970fda\n\n- use uniform permission checks for all mount propagation changes\n  (git-fixes).\n- commit 5972133\n\n- net/tunnel: wait until all sk_user_data reader finish before\n  releasing the sock (CVE-2022-50405 bsc#1250155).\n- commit aea82ac\n\n- rpm: Link guards script from scripts directory.\n- commit e19a893\n\n- usb: core: config: Prevent OOB read in SS endpoint companion\n  parsing (CVE-2025-39760 bsc#1249598).\n- commit ee5b3a5\n\n- can: bcm: bcm_tx_setup(): fix KMSAN uninit-value in vfs_write\n  (CVE-2023-53344 bsc#1250023).\n- net: sched: fix memory leak in tcindex_set_parms (CVE-2022-50396\n  bsc#1250104).\n- net: hns: fix possible memory leak in hnae_ae_register()\n  (CVE-2022-50352 bsc#1249922).\n- commit 10ff501\n\n- drm/client: Fix memory leak in drm_client_modeset_probe (bsc#1250058 CVE-2023-53288)\n- commit d2583cc\n\n- modpost: fix off by one in is_executable_section() (bsc#1250125\n  CVE-2023-53397).\n- commit 1e88ffb\n\n- dma-buf: add dma_fence_get_stub (bsc#1249779)\n- commit af3d574\n\n- drm/amdgpu: install stub fence into potential unused fence pointers (bsc#1249779 CVE-2023-53248)\n- commit 2f24c24\n\n- Refresh patches.kabi/blkg_policy_data-fix-kabi.patch.\n- Refresh\n  patches.kabi/xsk-Fix-race-condition-in-AF_XDP-generic-RX-path.patch.\n- commit aee218b\n\n- fixup patches.suse/ext4-fix-WARNING-in-mb_find_extent.patch\n- commit bc062c7\n\n- RDMA/mlx5: Fix mlx5_ib_get_hw_stats when used for device (CVE-2023-53393 bsc#1250114)\n- commit 3367be7\n\n- RDMA/cxgb4: Fix potential null-ptr-deref in pass_establish() (CVE-2023-53335 bsc#1250072)\n- commit de7e5a8\n\n- drm/radeon: Fix integer overflow in radeon_cs_parser_init\n  (CVE-2023-53309 bsc#1250055).\n- commit 0fc616d\n\n- Refresh patches.kabi/blkg_policy_data-fix-kabi.patch.\n- commit 5d9cd59\n\n- Update config files. (bsc#1249186)\n  Enable where we define KABI refs + rely on Kconfig deps.\n- commit a2cab75\n\n- Refresh patches.kabi/blkg_policy_data-fix-kabi.patch.\n- Refresh\n  patches.kabi/xsk-Fix-race-condition-in-AF_XDP-generic-RX-path.patch.\n  Semiautomatic\n  git grep -l BUILD_BUG_ON patches.kabi/ | xargs sed -i '/^+/s/\\\u0026lt;BUILD_BUG_ON\\\u0026gt;/suse_kabi_static_assert/'\n  plus manual drop of guard in blkg_policy_data-fix-kabi.patch.\n- commit 7689a50\n\n- build_bug.h: add wrapper for _Static_assert (bsc#1249186).\n- commit 55004e9\n\n- iomap: iomap: fix memory corruption when recording errors\n  during writeback (bsc#1250165 CVE-2022-50406).\n- commit 5a4f1a7\n\n- ext4: fix WARNING in mb_find_extent (bsc#1250081\n  CVE-2023-53317).\n- commit 85276b3\n\n- jbd2: prevent softlockup in jbd2_log_do_checkpoint()\n  (bsc#1249526 CVE-2025-39782).\n- commit 3659634\n\n- ext4: do not BUG when INLINE_DATA_FL lacks system.data xattr\n  (bsc#1249258 CVE-2025-38701).\n- commit a95c36d\n\n- fs/buffer: fix use-after-free when call bh_read() helper\n  (bsc#1249374 CVE-2025-39691).\n- commit f608a73\n\n- kcm: annotate data-races around kcm-\u0026gt;rx_wait (CVE-2022-50265\n  bsc#1249744).\n- kcm: annotate data-races around kcm-\u0026gt;rx_psock (CVE-2022-50291\n  bsc#1249798).\n- commit aaba982\n\n- hfsplus: don't use BUG_ON() in hfsplus_create_attributes_file()\n  (bsc#1249194 CVE-2025-38712).\n- commit 521eb34\n\n- hfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()\n  (bsc#1249200 CVE-2025-38713).\n- commit 91e012f\n\n- wifi: brcmfmac: Fix potential stack-out-of-bounds in\n  brcmf_c_preinit_dcmds() (CVE-2022-50258 bsc#1249947).\n- commit 5e60cf0\n\n- drivers: base: cacheinfo: Fix shared_cpu_map changes in event\n  of CPU hotplug (CVE-2023-53254 bsc#1249871).\n- commit d73f053\n\n- cacheinfo: Fix shared_cpu_map to handle shared caches at\n  different levels (CVE-2023-53254 bsc#1249871).\n- commit b2d75ed\n\n- wifi: mwifiex: Fix oob check condition in\n  mwifiex_process_rx_packet (CVE-2023-53226 bsc#1249658).\n- wifi: mwifiex: Fix missed return in oob checks failed path\n  (CVE-2023-53226 bsc#1249658).\n- wifi: cfg80211: Partial revert \u0026quot;wifi: cfg80211: Fix use after\n  free for wext\u0026quot; (CVE-2023-53153 bsc#1249877).\n- commit 01aaa87\n\n- wifi: mwifiex: Fix OOB and integer underflow when rx packets\n  (CVE-2023-53226 bsc#1249658).\n- wifi: cfg80211: Fix use after free for wext (CVE-2023-53153\n  bsc#1249877).\n- wifi: ath9k: hif_usb: clean up skbs if ath9k_hif_usb_rx_stream()\n  fails (CVE-2023-53199 bsc#1249683).\n- commit f427ccc\n\n- crypto: cavium - prevent integer overflow loading firmware\n  (CVE-2022-50330 bsc#1249700).\n- commit 489e575\n\n- crypto: cavium - add release_firmware to all return case\n  (CVE-2022-50330 bsc#1249700).\n- commit 372d22d\n\n- misc: tifm: fix possible memory leak in tifm_7xx1_switch_media()\n  (CVE-2022-50349 bsc#1249920).\n- commit 658f5fe\n\n- wifi: brcmfmac: fix potential memory leak in\n  brcmf_netdev_start_xmit() (CVE-2022-50321 bsc#1249706).\n- commit d3baaae\n\n- cxl: Fix refcount leak in cxl_calc_capp_routing (CVE-2022-50311\n  bsc#1249720).\n- commit 70f8a07\n\n- mm: export bdi_unregister (CVE-2022-50304 bsc#1249725).\n- commit 9420929\n\n- mtd: core: fix possible resource leak in init_mtd()\n  (CVE-2022-50304 bsc#1249725).\n- commit 191b4a8\n\n- mm,hugetlb: take hugetlb_lock before decrementing\n  h-\u0026gt;resv_huge_pages (CVE-2022-50285 bsc#1249803).\n- commit 53c2d88\n\n- RDMA/bnxt_re: wraparound mbox producer index (CVE-2023-53201 bsc#1249687)\n- commit 4aab7ab\n\n- wifi: libertas: fix memory leak in lbs_init_adapter()\n  (CVE-2022-50294 bsc#1249799).\n- cxl: fix possible null-ptr-deref in cxl_pci_init_afu|adapter()\n  (CVE-2022-50244 bsc#1249647).\n- PNP: fix name memory leak in pnp_alloc_dev() (CVE-2022-50278\n  bsc#1249715).\n- commit c3e3de7\n\n- drm/amd/pm: fix null pointer access (CVE-2025-38705\n  bsc#1249334).\n- commit 6b431f7\n\n- fbdev: fix potential buffer overflow in\n  do_register_framebuffer() (CVE-2025-38702 bsc#1249254).\n- commit 4004fc6\n\n- drm/amdkfd: Destroy KFD debugfs after destroy KFD wq\n  (CVE-2025-39706 bsc#1249413).\n- commit 83af3ba\n\n- Refresh\n  patches.suse/Bluetooth-Replace-BT_DBG-with-bt_dev_dbg-for-managem.patch.\n- commit c6ff1e0\n\n- ALSA: hda/ca0132: Fix buffer overflow in add_tuning_control\n  (CVE-2025-39751 bsc#1249538).\n- commit 8a44263\n\n- kABI fix after x86/vmscape: Add conditional IBPB mitigation\n  (bsc#1247483 CVE-2025-40300).\n- commit 0df5e36\n\n- drm/amd/display: fix a Null pointer dereference vulnerability (bsc#1249295 CVE-2025-39705)\n- commit 478e53d\n\n- Bluetooth: hci_core: Fix calling mgmt_device_connected\n  (git-fixes).\n- commit bd515e0\n\n- ALSA: usb-audio: Validate UAC3 power domain descriptors, too\n  (CVE-2025-38729 bsc#1249164).\n- commit 8b412cb\n\n- pptp: fix pptp_xmit() error path (git-fixes).\n- pptp: ensure minimal skb length in pptp_xmit() (CVE-2025-38574\n  bsc#1248365).\n- can: netlink: can_changelink(): fix NULL pointer deref of\n  struct can_priv::do_set_mode (CVE-2025-38665 bsc#1248648).\n- tls: separate no-async decryption request handling from async\n  (CVE-2024-58240 bsc#1248847).\n- commit cb8a609\n\n- Limit patch filenames to 100 characters (bsc#1249604).\n- commit e94c0ca\n\n- smb: client: fix use-after-free in cifs_oplock_break\n  (bsc#1248199, CVE-2025-38527).\n- commit e4dac9c\n\n- tipc: improve function tipc_wait_for_cond() (bsc#1249037).\n- commit 66b60a2\n\n- PCI: Fix use-after-free of slot-\u0026gt;bus on hot remove\n  (CVE-2024-53194 bsc#1235459).\n- commit 8ed6518\n\n- kernel-subpackage-build: Decompress ghost file when compressed version exists (bsc#1249346)\n- commit 40606b5\n\n- powerpc/eeh: Export eeh_unfreeze_pe() (CVE-2025-38623\n  bsc#1248610).\n- commit e1ab8da\n\n- pci/hotplug/pnv-php: Wrap warnings in macro (CVE-2025-38623\n  bsc#1248610).\n- commit fcff164\n\n- PCI: pnv_php: Fix surprise plug detection and recovery\n  (CVE-2025-38623 bsc#1248610).\n- commit 77a6e44\n\n- PCI: pnv_php: Clean up allocated IRQs on unplug (CVE-2025-38624\n  bsc#1248617).\n- commit f20bd36\n\n- netfilter: xt_nfacct: don't assume acct name is null-terminated (CVE-2025-38639 bsc#1248674)\n- commit 85e9df6\n\n- s390/ism: fix concurrency management in ism_cmd() (git-fixes\n  bsc#1249266 CVE-2025-39726).\n- commit 4cdfb37\n\n- fbdev: Fix vmalloc out-of-bounds write in fast_imageblit (bsc#1249220 CVE-2025-38685)\n- commit d40c5ad\n\n- pinmux: fix race causing mux_owner NULL with active mux_usecount\n  (CVE-2025-38632 bsc#1248669).\n- commit 417d30f\n\n- smb: client: fix use-after-free in crypt_message when using\n  async crypto (bsc#1247239, CVE-2025-38488).\n- commit f68b209\n\n- wifi: iwlwifi: Fix error code in iwl_op_mode_dvm_start()\n  (CVE-2025-38602 bsc#1248341).\n- commit 26c0123\n\n- iwlwifi: Add missing check for alloc_ordered_workqueue\n  (CVE-2025-38602 bsc#1248341).\n- commit 1f095f0\n\n- wifi: rtl818x: Kill URBs before clearing tx status queue (CVE-2025-38604 bsc#1248333)\n- commit 3582a16\n\n- ipv6: reject malicious packets in ipv6_gso_segment()\n  (CVE-2025-38572 bsc#1248399).\n- net/sched: Restrict conditions for adding duplicating netems\n  to qdisc tree (CVE-2025-38553 bsc#1248255).\n- commit edb7431\n\n- rpm: Configure KABI checkingness macro (bsc#1249186)\n  The value of the config should match presence of KABI reference data. If\n  it mismatches:\n- !CONFIG \u0026amp; reference  -\u0026gt; this is bug, immediate fail\n- CONFIG \u0026amp; no reference -\u0026gt; OK temporarily, must be resolved eventually\n- commit 23c1536\n\n- Kconfig.suse: Add KABI checkiness macro (config) (bsc#1249186)\n  The motivation: there are patches.kabi/ patches that restore KABI and\n  they check validity of the approach with static_assert()s to prevent\n  accidental KABI breakage.\n  These asserts are invoked on each arch-flavor and they may signal false\n  negatives -- that is KABI restoration patch could break KABI but the\n  given arch-flavor defines no KABI.\n  The intended use is to disable the compile time checks in patches.kabi/\n  (but not to be confused with __GENKSYMS__ that affects how reference is\n  calculated).\n  The name is chosen so that it mimics HAVE_* macros that are not\n  configured manually (but is selected by an arch). In our case it's\n  (un)selected by build script depending on whether KABI reference is\n  defined for given arch-flavor and whether check is really requested by\n  the user. Default value is 'n' so that people building merely via\n  Makefile (not RPM with KABI checking) obtain consistent config.\n- commit 75ce338\n\nPackage cups was updated:\n\n- cups-1.7.5-CVE-2025-61915.patch is based on  https://github.com/OpenPrinting/cups-ghsa-hxm8-vfpq-jrfc/pull/2\n  backported to CUPS 1.7.5 to fix CVE-2025-61915\n  \u0026quot;Local denial-of-service via cupsd.conf update\n  and related issues\u0026quot;\n  https://github.com/OpenPrinting/cups/security/advisories/GHSA-hxm8-vfpq-jrfc\n  bsc#1253783\n- In general regarding CUPS security issues and/or DoS issues see\n  https://en.opensuse.org/SDB:CUPS_and_SANE_Firewall_settings\n\nPackage pacemaker was updated:\n\n- fencer: improve self-fencing logs (bsc#1249419)  * bsc#1249419-0002-Log-fencer-improve-self-fencing-logs.patch\n- fenced: DC node fencing is unconditionally relayed. (bsc#1249419)\n  * bsc#1249419-0001-Mid-fenced-DC-node-fencing-is-unconditionally-relaye.patch\n\nPackage python3 was updated:\n\n- Add CVE-2025-13836-http-resp-cont-len.patch (bsc#1254400,  CVE-2025-13836) to prevent reading an HTTP response from\n  a server, if no read amount is specified, with using\n  Content-Length per default as the length.\n- Add CVE-2025-12084-minidom-quad-search.patch prevent quadratic\n  behavior in node ID cache clearing (CVE-2025-12084,\n  bsc#1254997).\n- Add CVE-2025-13837-plistlib-mailicious-length.patch protect\n  against OOM when loading malicious content (CVE-2025-13837,\n  bsc#1254401).\n\n- Fix the build system with two patches:\n  - spc-tab-Makefile-pre-in.patch there are space-indended lines\n    in the Makefile.pre.in in tarball (!!!), fix that\n  - Modules_Setup.patch, Modules/makesetup script is kind of\n    broken (gh#python/cpython!4338 among others)\n  - time-static.patch make time module statically built into the\n    interpreter\n- Add s390-build.patch to skip failing test on s390.\n\n- Add CVE-2025-6075-expandvars-perf-degrad.patch avoid simple\n  quadratic complexity vulnerabilities of os.path.expandvars()\n  (CVE-2025-6075, bsc#1252974).\n- Add also two small patches:\n  - lchmod-non-support.patch adding @requires_lchmod operator\n    for skipping tests on platforms were changing the mode of\n    symbolic links is supported (which it isnt in SLE-12,\n    apparently).\n  - locale-test_float_with_commad.patch for decoding byte strings\n    in localeconv() for consistent output\n- Update pip wheel to pip-20.2.3-py2.py3-none-any.whl.\n\n- Add CVE-2025-8291-consistency-zip64.patch which checks\n  consistency of the zip64 end of central directory record, and\n  preventing obfuscation of the payload, i.e., you scanning for\n  malicious content in a ZIP file with one ZIP parser (let's say\n  a Rust one) then unpack it in production with another (e.g.,\n  the Python one) and get malicious content that the other parser\n  did not see (CVE-2025-8291, bsc#1251305)\n- Readjust patches while synchronizing between openSUSE and SLE trees:\n  - 99366-patch.dict-can-decorate-async.patch\n  - CVE-2007-4559-filter-tarfile_extractall.patch\n  - CVE-2020-10735-DoS-no-limit-int-size.patch\n  - CVE-2024-6232-ReDOS-backtrack-tarfile.patch\n  - CVE-2025-4435-normalize-lnk-trgts-tarfile.patch\n  - CVE-2025-8194-tarfile-no-neg-offsets.patch\n  - python-3.6.0-multilib-new.patch\n  - python3-sorted_tar.patch\n\nPackage tiff was updated:\n\n- security update:  * CVE-2025-8851 [bsc#1248278]\n    Fix stack-based buffer overflow vulnerability in\n    tools/tiffcrop.c function readSeparateStripsIntoBuffer() by\n    implementing additional error handling.\n    + tiff-CVE-2025-8851.patch\n\n- security update:\n  * CVE-2025-9900 [bsc#1250413]\n    Fix Write-What-Where in libtiff via TIFFReadRGBAImageOriented\n    + tiff-CVE-2025-9900.patch\n\nPackage expat was updated:\n\n- Fix CVE-2025-59375 / bsc#1249584.- Add patch file:\n  * CVE-2025-59375.patch\n\nPackage krb5 was updated:\n\n- Remove des3-cbc-sha1 and arcfour-hmac-md5 from permitted  enctypes unless new special options \u0026quot;allow_des3\u0026quot; or \u0026quot;allow_rc4\u0026quot;\n  are set; (CVE-2025-3576); (bsc#1241219).\n- Add patch 0018-prep-CVE-2025-3576.patch\n- Add patch 0019-CVE-2025-3576.patch\n\nPackage mozilla-nss was updated:\n\n- Add bmo1990242.patch to move NSS DB password hash away from SHA-1\n- update to NSS 3.112.2\n  * bmo#1970079 - Prevent leaks during pkcs12 decoding.\n  * bmo#1988046 - SEC_ASN1Decode* should ensure it has read as many bytes as each length field indicates\n- Adding patch bmo1980465.patch to fix bug on s390x (bmo#1980465)\n- Adding patch bmo1956754.patch to fix possible undefined behaviour (bmo#1956754)\n\n- update to NSS 3.112.1\n  * bmo#1982742 - restore support for finding certificates by decoded serial number.\n\nPackage mozilla-nspr was updated:\n\n- update to NSPR 4.36.2  * Fixed a syntax error in test file parsetm.c,\n    which was introduced in 4.36.1\n- update to NSPR 4.36.1\n  * Incorrect time value produced by PR_ParseTimeString and\n    PR_ParseTimeStringToExplodedTime if input string doesn't\n    specify seconds.\n\nPackage bind was updated:\n\n- Security Fixes:  * Address various spoofing attacks.\n    [CVE-2025-40778, bsc#1252379, bind-9.11-CVE-2025-40778.patch]\n\nPackage google-cloud-sap-agent was updated:\n\n- Update to version 3.9 (bsc#1248452, bsc#1249003)  * Use correct version comparison to support double digit minor versions\n  * Reduce Process Metrics collection frequency.\n  * Update event topic message structure\n  * Fix network stats skipped metrics\n  * fixing a typo\n  * PubSub Log Collection Unit Tests\n  * Reduce info log volume with default agent config\n  * fix typo in action workflow\n  * Use a github token when adding the workloadagentplatform submodule to avoid rate limits\n  * Add executable permission check for /usr/sap in Status OTE\n  * Delete aianalyzer from SAP Agent - we have moved to a new agent in platform\n  * Update CheckTopology to call sapcontrol as sidadm user correctly\n  * bump oauth2 version to v0.27.0\n  * Auto updated compiled protocol buffers\n  * Log collection streaming to pub/sub\n  * Version fix and improved LVMRename error handling\n  * Add todo for archive snapshot in hanadiskbackup and hanadiskrestore.\n  * Use snapshot group workflow for version 3.9+\n  * Add Rename LVM step to restore with Snapshot Group Workflow\n  * Agent for SAP: Add functionality to wait for snapshot group creation\n    till it's status is not 'CREATING'\n  * Modify hanadiskbackup for sidadm user\n  * Implement bulk insert for snapshot group in multidisk restore.\n  * Populate instance uri in agent status\n  * Add `ListDisksFromSnapshot` function to snapshot group utils.\n  * Use Snapshot Group for snapshot validation.\n  * Added method to list snapshots from snapshot group.\n  * Adding snapshot group flag to hanadiskrestore OTE.\n  * Fixes the link to the cloud console for upgrading the storage bucket\n  * Implement function to create disks from snapshot group via bulk insert API.\n  * SAP Agent - HANA Disk Snapshot - Add SG Workflow\n  * Implement WaitForSGUploadCompletionWithRetry function to wait\n    for Snapshot group upload completion.\n  * Implement `ListSGs` function in `snapshotgroup` utils.\n  * Implement get snapshot groups functionality.\n  * Implement CreateSG method.\n  * Add Snapshot group utility library\n  * Auto updated compiled protocol buffers\n  * Remove lastHostChangeTimestamp field from host metrics\n- Drop CVE-2025-22868.patch, merged upstream\n\nPackage samba was updated:\n\n- CVE-2025-9640: fix vfs_streams_xattr uninitialized memory write;  (bsc#1251279);(bso#15885).\n- CVE-2025-10230: fix command Injection in WINS Server Hook Script;\n  (bsc#1251280);(bso#15903).\n\nPackage python36 was updated:\n\n- Add CVE-2025-13836-http-resp-cont-len.patch (bsc#1254400,  CVE-2025-13836) to prevent reading an HTTP response from\n  a server, if no read amount is specified, with using\n  Content-Length per default as the length.\n- Add CVE-2025-12084-minidom-quad-search.patch prevent quadratic\n  behavior in node ID cache clearing (CVE-2025-12084,\n  bsc#1254997).\n- Add CVE-2025-13837-plistlib-mailicious-length.patch protect\n  against OOM when loading malicious content (CVE-2025-13837,\n  bsc#1254401).\n\n- Add CVE-2025-6075-expandvars-perf-degrad.patch avoid simple\n  quadratic complexity vulnerabilities of os.path.expandvars()\n  (CVE-2025-6075, bsc#1252974).\n- Skip test_curses on ppc64le (gh#python/cpython#141534)\n\n- Add CVE-2025-8291-consistency-zip64.patch which checks\n  consistency of the zip64 end of central directory record, and\n  preventing obfuscation of the payload, i.e., you scanning for\n  malicious content in a ZIP file with one ZIP parser (let's say\n  a Rust one) then unpack it in production with another (e.g.,\n  the Python one) and get malicious content that the other parser\n  did not see (CVE-2025-8291, bsc#1251305)\n- Readjust patches while synchronizing between openSUSE and SLE trees:\n  - F00251-change-user-install-location.patch\n  - doc-py38-to-py36.patch\n  - gh126985-mv-pyvenv.cfg2getpath.patch\n\nPackage vim was updated:\n\n- Fix for bsc#1229750.- nocompatible must be set before the syntax highlighting is turned on.\n\nPackage rsync was updated:\n\n- Security update (CVE-2025-10158, bsc#1254441): rsync: Out of  bounds array access via negative index\n  - Add rsync-CVE-2025-10158.patch\n\nPackage bash was updated:\n\n- Add patch bsc1245199.patch  * Fix histfile missing timestamp for the oldest record (bsc#1245199)\n\nPackage curl was updated:\n\n- Security fixes:  * [bsc#1255731, CVE-2025-14524] bearer token leak on cross-protocol redirect\n  * [bsc#1255733, CVE-2025-15079] set both knownhosts options to the same file\n  * [bsc#1255732, CVE-2025-14819] toggling CURLSSLOPT_NO_PARTIALCHAIN makes a different CA cache\n  * Add patches:\n  - curl-CVE-2025-14524.patch\n  - curl-CVE-2025-15079.patch\n  - curl-CVE-2025-14819.patch\n\nPackage libxml2 was updated:\n\n- security update- added patches\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/852c93a2dc2224f020aab55a9702f992db404836\n  * libxml2-CVE-2025-9714-0.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/5153c7baceca65f575efdcbb0244860d97031f96\n  * libxml2-CVE-2025-9714-1.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/64115ed62dd01dab81a9157a54738523fe117333\n  * libxml2-CVE-2025-9714-2.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/2d97a97aa515f1bd3efc35c8ea2aa68676c6f8e1\n  * libxml2-CVE-2025-9714-3.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/012f8e92847a4e5ff684e7bd8e81a0b1ad104e32\n  * libxml2-CVE-2025-9714-4.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/949eced484520bdde3348e55eba048501b809127\n  * libxml2-CVE-2025-9714-5.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/390f05e7033fa8658f310dce9704f4f88e84b7fe\n  * libxml2-CVE-2025-9714-6.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/429d4ecaae5d61d591f279220125a583836fb84e\n  * libxml2-CVE-2025-9714-7.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/6f1470a5d6e3e369fe93f52d5760ba7c947f0cd1\n  * libxml2-CVE-2025-9714-8.patch\n  https://gitlab.gnome.org/GNOME/libxml2/-/commit/677a42645ef22b5a50741bad5facf9d8a8bc6d21\n  * libxml2-CVE-2025-9714.patch\n\n- security update\n- added patches\n  CVE-2025-8732 [bsc#1247850], infinite recursion in catalog parsing functions when processing malformed SGML catalog files\n  * libxml2-CVE-2025-8732.patch\n\n",
      "Title": "Details",
      "Type": "General"
    },
    {
      "Text": "The CVRF data is provided by SUSE under the Creative Commons License 4.0 with Attribution (CC-BY-4.0).",
      "Title": "Terms of Use",
      "Type": "Legal Disclaimer"
    }
  ],
  "ProductTree": {
    "Relationships": [
      {
        "ProductReference": "bash-4.3-83.36.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "bind-utils-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cluster-md-kmp-default-4.12.14-122.283.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "ctdb-4.15.13+git.664.e8416d8d213-3.99.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cups-libs-1.7.5-20.57.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "curl-8.0.1-11.111.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cyrus-sasl-2.1.26-14.7.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cyrus-sasl-digestmd5-2.1.26-14.7.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cyrus-sasl-gssapi-2.1.26-14.7.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cyrus-sasl-plain-2.1.26-14.7.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "cyrus-sasl-saslauthd-2.1.26-14.7.8",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "db48-utils-4.8.30-38.2",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "dlm-kmp-default-4.12.14-122.283.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "expat-2.7.1-21.46.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "gfs2-kmp-default-4.12.14-122.283.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "glib2-tools-2.48.2-12.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "google-cloud-sap-agent-3.9-6.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "grub2-2.02-193.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "grub2-i386-pc-2.02-193.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "grub2-x86_64-efi-2.02-193.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "kernel-default-4.12.14-122.283.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "krb5-1.16.3-46.21.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "krb5-client-1.16.3-46.21.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libbind9-161-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libcurl4-8.0.1-11.111.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libdb-4_8-4.8.30-38.2",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libdns1110-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libexpat1-2.7.1-21.46.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libfreebl3-3.112.2-58.133.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libgio-2_0-0-2.48.2-12.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libglib-2_0-0-2.48.2-12.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libgmodule-2_0-0-2.48.2-12.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libgnutls28-3.3.27-3.15.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libgobject-2_0-0-2.48.2-12.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libgthread-2_0-0-2.48.2-12.52.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libirs161-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libisc1107-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libisccc161-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libisccfg163-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libldap-2_4-2-2.4.41-22.26.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "liblwres161-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpacemaker3-1.1.24+20210811.f5abda0ee-3.49.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpcap1-1.8.1-10.9.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpci3-3.5.6-11.12.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpng12-0-1.2.50-20.6.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpng16-16-1.6.8-15.12.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpython3_4m1_0-3.4.10-25.166.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libpython3_6m1_0-3.6.15-97.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libreadline6-6.3-83.36.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libsasl2-3-2.1.26-14.7.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libsoftokn3-3.112.2-58.133.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libtiff5-4.0.9-44.106.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libxml2-2-2.9.4-46.93.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libxml2-tools-2.9.4-46.93.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libxslt-tools-1.1.28-17.21.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libxslt1-1.1.28-17.21.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "libyui-ncurses7-2.48.3-7.3.6",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "mozilla-nspr-4.36.2-19.36.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "mozilla-nss-3.112.2-58.133.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "mozilla-nss-certs-3.112.2-58.133.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "ocfs2-kmp-default-4.12.14-122.283.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "openldap2-client-2.4.41-22.26.9",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "openssh-7.2p2-81.34.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "pacemaker-1.1.24+20210811.f5abda0ee-3.49.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "pacemaker-cli-1.1.24+20210811.f5abda0ee-3.49.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "pciutils-3.5.6-11.12.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "python-bind-9.11.22-3.65.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "python3-3.4.10-25.166.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "python3-base-3.4.10-25.166.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "python3-curses-3.4.10-25.166.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "python36-base-3.6.15-97.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "rsync-3.1.3-3.34.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "samba-client-libs-4.15.13+git.664.e8416d8d213-3.99.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "samba-libs-4.15.13+git.664.e8416d8d213-3.99.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "vim-9.1.1629-17.54.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "vim-data-common-9.1.1629-17.54.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      },
      {
        "ProductReference": "xkbcomp-1.2.4-11.3.1",
        "RelatesToProductReference": "Public Cloud Image google/sles-sap-12-sp5-byos-v20260111-x86-64",
        "RelationType": "Default Component Of"
      }
    ]
  },
  "References": [
    {
      "URL": "https://publiccloudimagechangeinfo.suse.com/google/sles-sap-12-sp5-byos-v20260111-x86-64/",
      "Description": "Public Cloud Image Info"
    },
    {
      "URL": "https://www.suse.com/support/security/rating/",
      "Description": "SUSE Security Ratings"
    }
  ],
  "Vulnerabilities": [
    {
      "CVE": "CVE-2007-4559",
      "Description": "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "6.8",
        "Vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P"
      }
    },
    {
      "CVE": "CVE-2013-7353",
      "Description": "Integer overflow in the png_set_unknown_chunks function in libpng/pngset.c in libpng before 1.5.14beta08 allows context-dependent attackers to cause a denial of service (segmentation fault and crash) via a crafted image, which triggers a heap-based buffer overflow.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5",
        "Vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2013-7354",
      "Description": "Multiple integer overflows in libpng before 1.5.14rc03 allow remote attackers to cause a denial of service (crash) via a crafted image to the (1) png_set_sPLT or (2) png_set_text_2 function, which triggers a heap-based buffer overflow.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5",
        "Vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2014-0333",
      "Description": "The png_push_read_chunk function in pngpread.c in the progressive decoder in libpng 1.6.x through 1.6.9 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an IDAT chunk with a length of zero.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5",
        "Vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2014-9495",
      "Description": "Heap-based buffer overflow in the png_combine_row function in libpng before 1.5.21 and 1.6.x before 1.6.16, when running on 64-bit systems, might allow context-dependent attackers to execute arbitrary code via a \"very wide interlaced\" PNG image.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "critical"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "10",
        "Vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C"
      }
    },
    {
      "CVE": "CVE-2015-0973",
      "Description": "Buffer overflow in the png_read_IDAT_data function in pngrutil.c in libpng before 1.5.21 and 1.6.x before 1.6.16 allows context-dependent attackers to execute arbitrary code via IDAT data with a large width, a different vulnerability than CVE-2014-9495.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.5",
        "Vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P"
      }
    },
    {
      "CVE": "CVE-2015-7981",
      "Description": "The png_convert_to_rfc1123 function in png.c in libpng 1.0.x before 1.0.64, 1.2.x before 1.2.54, and 1.4.x before 1.4.17 allows remote attackers to obtain sensitive process memory information via crafted tIME chunk data in an image file, which triggers an out-of-bounds read.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5",
        "Vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N"
      }
    },
    {
      "CVE": "CVE-2015-8126",
      "Description": "Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.5",
        "Vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P"
      }
    },
    {
      "CVE": "CVE-2018-15853",
      "Description": "Endless recursion exists in xkbcomp/expr.c in xkbcommon and libxkbcommon before 0.8.1, which could be used by local attackers to crash xkbcommon users by supplying a crafted keymap file that triggers boolean negation.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "2.1",
        "Vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2018-15859",
      "Description": "Unchecked NULL pointer usage when parsing invalid atoms in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because lookup failures are mishandled.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "2.1",
        "Vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2018-15861",
      "Description": "Unchecked NULL pointer usage in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file that triggers an xkb_intern_atom failure.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "2.1",
        "Vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2018-15863",
      "Description": "Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "2.1",
        "Vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P"
      }
    },
    {
      "CVE": "CVE-2020-10735",
      "Description": "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2021-4460",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: Fix UBSAN shift-out-of-bounds warning\n\nIf get_num_sdma_queues or get_num_xgmi_sdma_queues is 0, we end up\ndoing a shift operation where the number of bits shifted equals\nnumber of bits in the operand. This behaviour is undefined.\n\nSet num_sdma_queues or num_xgmi_sdma_queues to ULLONG_MAX, if the\ncount is \u003e= number of bits in the operand.\n\nBug: https://gitlab.freedesktop.org/drm/amd/-/issues/1472",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-36280",
      "Description": "An out-of-bounds(OOB) memory access vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_kms.c in GPU component in the Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-43945",
      "Description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-48631",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix bug in extents parsing when eh_entries == 0 and eh_depth \u003e 0\n\nWhen walking through an inode extents, the ext4_ext_binsearch_idx() function\nassumes that the extent header has been previously validated.  However, there\nare no checks that verify that the number of entries (eh-\u003eeh_entries) is\nnon-zero when depth is \u003e 0.  And this will lead to problems because the\nEXT_FIRST_INDEX() and EXT_LAST_INDEX() will return garbage and result in this:\n\n[  135.245946] ------------[ cut here ]------------\n[  135.247579] kernel BUG at fs/ext4/extents.c:2258!\n[  135.249045] invalid opcode: 0000 [#1] PREEMPT SMP\n[  135.250320] CPU: 2 PID: 238 Comm: tmp118 Not tainted 5.19.0-rc8+ #4\n[  135.252067] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.15.0-0-g2dd4b9b-rebuilt.opensuse.org 04/01/2014\n[  135.255065] RIP: 0010:ext4_ext_map_blocks+0xc20/0xcb0\n[  135.256475] Code:\n[  135.261433] RSP: 0018:ffffc900005939f8 EFLAGS: 00010246\n[  135.262847] RAX: 0000000000000024 RBX: ffffc90000593b70 RCX: 0000000000000023\n[  135.264765] RDX: ffff8880038e5f10 RSI: 0000000000000003 RDI: ffff8880046e922c\n[  135.266670] RBP: ffff8880046e9348 R08: 0000000000000001 R09: ffff888002ca580c\n[  135.268576] R10: 0000000000002602 R11: 0000000000000000 R12: 0000000000000024\n[  135.270477] R13: 0000000000000000 R14: 0000000000000024 R15: 0000000000000000\n[  135.272394] FS:  00007fdabdc56740(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000\n[  135.274510] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  135.276075] CR2: 00007ffc26bd4f00 CR3: 0000000006261004 CR4: 0000000000170ea0\n[  135.277952] Call Trace:\n[  135.278635]  \u003cTASK\u003e\n[  135.279247]  ? preempt_count_add+0x6d/0xa0\n[  135.280358]  ? percpu_counter_add_batch+0x55/0xb0\n[  135.281612]  ? _raw_read_unlock+0x18/0x30\n[  135.282704]  ext4_map_blocks+0x294/0x5a0\n[  135.283745]  ? xa_load+0x6f/0xa0\n[  135.284562]  ext4_mpage_readpages+0x3d6/0x770\n[  135.285646]  read_pages+0x67/0x1d0\n[  135.286492]  ? folio_add_lru+0x51/0x80\n[  135.287441]  page_cache_ra_unbounded+0x124/0x170\n[  135.288510]  filemap_get_pages+0x23d/0x5a0\n[  135.289457]  ? path_openat+0xa72/0xdd0\n[  135.290332]  filemap_read+0xbf/0x300\n[  135.291158]  ? _raw_spin_lock_irqsave+0x17/0x40\n[  135.292192]  new_sync_read+0x103/0x170\n[  135.293014]  vfs_read+0x15d/0x180\n[  135.293745]  ksys_read+0xa1/0xe0\n[  135.294461]  do_syscall_64+0x3c/0x80\n[  135.295284]  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis patch simply adds an extra check in __ext4_ext_check(), verifying that\neh_entries is not 0 when eh_depth is \u003e 0.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-49975",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Don't redirect packets with invalid pkt_len\n\nSyzbot found an issue [1]: fq_codel_drop() try to drop a flow whitout any\nskbs, that is, the flow-\u003ehead is null.\nThe root cause, as the [2] says, is because that bpf_prog_test_run_skb()\nrun a bpf prog which redirects empty skbs.\nSo we should determine whether the length of the packet modified by bpf\nprog or others like bpf_prog_test is valid before forwarding it directly.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50233",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: eir: Fix using strlen with hdev-\u003e{dev_name,short_name}\n\nBoth dev_name and short_name are not guaranteed to be NULL terminated so\nthis instead use strnlen and then attempt to determine if the resulting\nstring needs to be truncated or not.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50236",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/mediatek: Fix crash on isr after kexec()\n\nIf the system is rebooted via isr(), the IRQ handler might\nbe triggered before the domain is initialized. Resulting on\nan invalid memory access error.\n\nFix:\n[    0.500930] Unable to handle kernel read from unreadable memory at virtual address 0000000000000070\n[    0.501166] Call trace:\n[    0.501174]  report_iommu_fault+0x28/0xfc\n[    0.501180]  mtk_iommu_isr+0x10c/0x1c0\n\n[ joro: Fixed spelling in commit message ]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50242",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: net: qlcnic: Fix potential memory leak in qlcnic_sriov_init()\n\nIf vp alloc failed in qlcnic_sriov_init(), all previously allocated vp\nneeds to be freed.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50244",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxl: fix possible null-ptr-deref in cxl_pci_init_afu|adapter()\n\nIf device_register() fails in cxl_pci_afu|adapter(), the device\nis not added, device_unregister() can not be called in the error\npath, otherwise it will cause a null-ptr-deref because of removing\nnot added device.\n\nAs comment of device_register() says, it should use put_device() to give\nup the reference in the error path. So split device_unregister() into\ndevice_del() and put_device(), then goes to put dev when register fails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50249",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemory: of: Fix refcount leak bug in of_get_ddr_timings()\n\nWe should add the of_node_put() when breaking out of\nfor_each_child_of_node() as it will automatically increase\nand decrease the refcount.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50252",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Do not free q_vector unless new one was allocated\n\nAvoid potential use-after-free condition under memory pressure. If the\nkzalloc() fails, q_vector will be freed but left in the original\nadapter-\u003eq_vector[v_idx] array position.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50257",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen/gntdev: Prevent leaking grants\n\nPrior to this commit, if a grant mapping operation failed partially,\nsome of the entries in the map_ops array would be invalid, whereas all\nof the entries in the kmap_ops array would be valid. This in turn would\ncause the following logic in gntdev_map_grant_pages to become invalid:\n\n  for (i = 0; i \u003c map-\u003ecount; i++) {\n    if (map-\u003emap_ops[i].status == GNTST_okay) {\n      map-\u003eunmap_ops[i].handle = map-\u003emap_ops[i].handle;\n      if (!use_ptemod)\n        alloced++;\n    }\n    if (use_ptemod) {\n      if (map-\u003ekmap_ops[i].status == GNTST_okay) {\n        if (map-\u003emap_ops[i].status == GNTST_okay)\n          alloced++;\n        map-\u003ekunmap_ops[i].handle = map-\u003ekmap_ops[i].handle;\n      }\n    }\n  }\n  ...\n  atomic_add(alloced, \u0026map-\u003elive_grants);\n\nAssume that use_ptemod is true (i.e., the domain mapping the granted\npages is a paravirtualized domain). In the code excerpt above, note that\nthe \"alloced\" variable is only incremented when both kmap_ops[i].status\nand map_ops[i].status are set to GNTST_okay (i.e., both mapping\noperations are successful).  However, as also noted above, there are\ncases where a grant mapping operation fails partially, breaking the\nassumption of the code excerpt above.\n\nThe aforementioned causes map-\u003elive_grants to be incorrectly set. In\nsome cases, all of the map_ops mappings fail, but all of the kmap_ops\nmappings succeed, meaning that live_grants may remain zero. This in turn\nmakes it impossible to unmap the successfully grant-mapped pages pointed\nto by kmap_ops, because unmap_grant_pages has the following snippet of\ncode at its beginning:\n\n  if (atomic_read(\u0026map-\u003elive_grants) == 0)\n    return; /* Nothing to do */\n\nIn other cases where only some of the map_ops mappings fail but all\nkmap_ops mappings succeed, live_grants is made positive, but when the\nuser requests unmapping the grant-mapped pages, __unmap_grant_pages_done\nwill then make map-\u003elive_grants negative, because the latter function\ndoes not check if all of the pages that were requested to be unmapped\nwere actually unmapped, and the same function unconditionally subtracts\n\"data-\u003ecount\" (i.e., a value that can be greater than map-\u003elive_grants)\nfrom map-\u003elive_grants. The side effects of a negative live_grants value\nhave not been studied.\n\nThe net effect of all of this is that grant references are leaked in one\nof the above conditions. In Qubes OS v4.1 (which uses Xen's grant\nmechanism extensively for X11 GUI isolation), this issue manifests\nitself with warning messages like the following to be printed out by the\nLinux kernel in the VM that had granted pages (that contain X11 GUI\nwindow data) to dom0: \"g.e. 0x1234 still pending\", especially after the\nuser rapidly resizes GUI VM windows (causing some grant-mapping\noperations to partially or completely fail, due to the fact that the VM\nunshares some of the pages as part of the window resizing, making the\npages impossible to grant-map from dom0).\n\nThe fix for this issue involves counting all successful map_ops and\nkmap_ops mappings separately, and then adding the sum to live_grants.\nDuring unmapping, only the number of successfully unmapped grants is\nsubtracted from live_grants. The code is also modified to check for\nnegative live_grants values after the subtraction and warn the user.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50258",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: Fix potential stack-out-of-bounds in brcmf_c_preinit_dcmds()\n\nThis patch fixes a stack-out-of-bounds read in brcmfmac that occurs\nwhen 'buf' that is not null-terminated is passed as an argument of\nstrsep() in brcmf_c_preinit_dcmds(). This buffer is filled with a firmware\nversion string by memcpy() in brcmf_fil_iovar_data_get().\nThe patch ensures buf is null-terminated.\n\nFound by a modified version of syzkaller.\n\n[   47.569679][ T1897] brcmfmac: brcmf_fw_alloc_request: using brcm/brcmfmac43236b for chip BCM43236/3\n[   47.582839][ T1897] brcmfmac: brcmf_c_process_clm_blob: no clm_blob available (err=-2), device may have limited channels available\n[   47.601565][ T1897] ==================================================================\n[   47.602574][ T1897] BUG: KASAN: stack-out-of-bounds in strsep+0x1b2/0x1f0\n[   47.603447][ T1897] Read of size 1 at addr ffffc90001f6f000 by task kworker/0:2/1897\n[   47.604336][ T1897]\n[   47.604621][ T1897] CPU: 0 PID: 1897 Comm: kworker/0:2 Tainted: G           O      5.14.0+ #131\n[   47.605617][ T1897] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\n[   47.606907][ T1897] Workqueue: usb_hub_wq hub_event\n[   47.607453][ T1897] Call Trace:\n[   47.607801][ T1897]  dump_stack_lvl+0x8e/0xd1\n[   47.608295][ T1897]  print_address_description.constprop.0.cold+0xf/0x334\n[   47.609009][ T1897]  ? strsep+0x1b2/0x1f0\n[   47.609434][ T1897]  ? strsep+0x1b2/0x1f0\n[   47.609863][ T1897]  kasan_report.cold+0x83/0xdf\n[   47.610366][ T1897]  ? strsep+0x1b2/0x1f0\n[   47.610882][ T1897]  strsep+0x1b2/0x1f0\n[   47.611300][ T1897]  ? brcmf_fil_iovar_data_get+0x3a/0xf0\n[   47.611883][ T1897]  brcmf_c_preinit_dcmds+0x995/0xc40\n[   47.612434][ T1897]  ? brcmf_c_set_joinpref_default+0x100/0x100\n[   47.613078][ T1897]  ? rcu_read_lock_sched_held+0xa1/0xd0\n[   47.613662][ T1897]  ? rcu_read_lock_bh_held+0xb0/0xb0\n[   47.614208][ T1897]  ? lock_acquire+0x19d/0x4e0\n[   47.614704][ T1897]  ? find_held_lock+0x2d/0x110\n[   47.615236][ T1897]  ? brcmf_usb_deq+0x1a7/0x260\n[   47.615741][ T1897]  ? brcmf_usb_rx_fill_all+0x5a/0xf0\n[   47.616288][ T1897]  brcmf_attach+0x246/0xd40\n[   47.616758][ T1897]  ? wiphy_new_nm+0x1703/0x1dd0\n[   47.617280][ T1897]  ? kmemdup+0x43/0x50\n[   47.617720][ T1897]  brcmf_usb_probe+0x12de/0x1690\n[   47.618244][ T1897]  ? brcmf_usbdev_qinit.constprop.0+0x470/0x470\n[   47.618901][ T1897]  usb_probe_interface+0x2aa/0x760\n[   47.619429][ T1897]  ? usb_probe_device+0x250/0x250\n[   47.619950][ T1897]  really_probe+0x205/0xb70\n[   47.620435][ T1897]  ? driver_allows_async_probing+0x130/0x130\n[   47.621048][ T1897]  __driver_probe_device+0x311/0x4b0\n[   47.621595][ T1897]  ? driver_allows_async_probing+0x130/0x130\n[   47.622209][ T1897]  driver_probe_device+0x4e/0x150\n[   47.622739][ T1897]  __device_attach_driver+0x1cc/0x2a0\n[   47.623287][ T1897]  bus_for_each_drv+0x156/0x1d0\n[   47.623796][ T1897]  ? bus_rescan_devices+0x30/0x30\n[   47.624309][ T1897]  ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n[   47.624907][ T1897]  ? trace_hardirqs_on+0x46/0x160\n[   47.625437][ T1897]  __device_attach+0x23f/0x3a0\n[   47.625924][ T1897]  ? device_bind_driver+0xd0/0xd0\n[   47.626433][ T1897]  ? kobject_uevent_env+0x287/0x14b0\n[   47.627057][ T1897]  bus_probe_device+0x1da/0x290\n[   47.627557][ T1897]  device_add+0xb7b/0x1eb0\n[   47.628027][ T1897]  ? wait_for_completion+0x290/0x290\n[   47.628593][ T1897]  ? __fw_devlink_link_to_suppliers+0x5a0/0x5a0\n[   47.629249][ T1897]  usb_set_configuration+0xf59/0x16f0\n[   47.629829][ T1897]  usb_generic_driver_probe+0x82/0xa0\n[   47.630385][ T1897]  usb_probe_device+0xbb/0x250\n[   47.630927][ T1897]  ? usb_suspend+0x590/0x590\n[   47.631397][ T1897]  really_probe+0x205/0xb70\n[   47.631855][ T1897]  ? driver_allows_async_probing+0x130/0x130\n[   47.632469][ T1897]  __driver_probe_device+0x311/0x4b0\n[   47.633002][ \n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50265",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkcm: annotate data-races around kcm-\u003erx_wait\n\nkcm-\u003erx_psock can be read locklessly in kcm_rfree().\nAnnotate the read and writes accordingly.\n\nsyzbot reported:\n\nBUG: KCSAN: data-race in kcm_rcv_strparser / kcm_rfree\n\nwrite to 0xffff88810784e3d0 of 1 bytes by task 1823 on cpu 1:\nreserve_rx_kcm net/kcm/kcmsock.c:283 [inline]\nkcm_rcv_strparser+0x250/0x3a0 net/kcm/kcmsock.c:363\n__strp_recv+0x64c/0xd20 net/strparser/strparser.c:301\nstrp_recv+0x6d/0x80 net/strparser/strparser.c:335\ntcp_read_sock+0x13e/0x5a0 net/ipv4/tcp.c:1703\nstrp_read_sock net/strparser/strparser.c:358 [inline]\ndo_strp_work net/strparser/strparser.c:406 [inline]\nstrp_work+0xe8/0x180 net/strparser/strparser.c:415\nprocess_one_work+0x3d3/0x720 kernel/workqueue.c:2289\nworker_thread+0x618/0xa70 kernel/workqueue.c:2436\nkthread+0x1a9/0x1e0 kernel/kthread.c:376\nret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n\nread to 0xffff88810784e3d0 of 1 bytes by task 17869 on cpu 0:\nkcm_rfree+0x121/0x220 net/kcm/kcmsock.c:181\nskb_release_head_state+0x8e/0x160 net/core/skbuff.c:841\nskb_release_all net/core/skbuff.c:852 [inline]\n__kfree_skb net/core/skbuff.c:868 [inline]\nkfree_skb_reason+0x5c/0x260 net/core/skbuff.c:891\nkfree_skb include/linux/skbuff.h:1216 [inline]\nkcm_recvmsg+0x226/0x2b0 net/kcm/kcmsock.c:1161\n____sys_recvmsg+0x16c/0x2e0\n___sys_recvmsg net/socket.c:2743 [inline]\ndo_recvmmsg+0x2f1/0x710 net/socket.c:2837\n__sys_recvmmsg net/socket.c:2916 [inline]\n__do_sys_recvmmsg net/socket.c:2939 [inline]\n__se_sys_recvmmsg net/socket.c:2932 [inline]\n__x64_sys_recvmmsg+0xde/0x160 net/socket.c:2932\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nvalue changed: 0x01 -\u003e 0x00\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 17869 Comm: syz-executor.2 Not tainted 6.1.0-rc1-syzkaller-00010-gbb1a1146467a-dirty #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50266",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkprobes: Fix check for probe enabled in kill_kprobe()\n\nIn kill_kprobe(), the check whether disarm_kprobe_ftrace() needs to be\ncalled always fails. This is because before that we set the\nKPROBE_FLAG_GONE flag for kprobe so that \"!kprobe_disabled(p)\" is always\nfalse.\n\nThe disarm_kprobe_ftrace() call introduced by commit:\n\n  0cb2f1372baa (\"kprobes: Fix NULL pointer dereference at kprobe_ftrace_handler\")\n\nto fix the NULL pointer reference problem. When the probe is enabled, if\nwe do not disarm it, this problem still exists.\n\nFix it by putting the probe enabled check before setting the\nKPROBE_FLAG_GONE flag.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50271",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvhost/vsock: Use kvmalloc/kvfree for larger packets.\n\nWhen copying a large file over sftp over vsock, data size is usually 32kB,\nand kmalloc seems to fail to try to allocate 32 32kB regions.\n\n vhost-5837: page allocation failure: order:4, mode:0x24040c0\n Call Trace:\n  [\u003cffffffffb6a0df64\u003e] dump_stack+0x97/0xdb\n  [\u003cffffffffb68d6aed\u003e] warn_alloc_failed+0x10f/0x138\n  [\u003cffffffffb68d868a\u003e] ? __alloc_pages_direct_compact+0x38/0xc8\n  [\u003cffffffffb664619f\u003e] __alloc_pages_nodemask+0x84c/0x90d\n  [\u003cffffffffb6646e56\u003e] alloc_kmem_pages+0x17/0x19\n  [\u003cffffffffb6653a26\u003e] kmalloc_order_trace+0x2b/0xdb\n  [\u003cffffffffb66682f3\u003e] __kmalloc+0x177/0x1f7\n  [\u003cffffffffb66e0d94\u003e] ? copy_from_iter+0x8d/0x31d\n  [\u003cffffffffc0689ab7\u003e] vhost_vsock_handle_tx_kick+0x1fa/0x301 [vhost_vsock]\n  [\u003cffffffffc06828d9\u003e] vhost_worker+0xf7/0x157 [vhost]\n  [\u003cffffffffb683ddce\u003e] kthread+0xfd/0x105\n  [\u003cffffffffc06827e2\u003e] ? vhost_dev_set_owner+0x22e/0x22e [vhost]\n  [\u003cffffffffb683dcd1\u003e] ? flush_kthread_worker+0xf3/0xf3\n  [\u003cffffffffb6eb332e\u003e] ret_from_fork+0x4e/0x80\n  [\u003cffffffffb683dcd1\u003e] ? flush_kthread_worker+0xf3/0xf3\n\nWork around by doing kvmalloc instead.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50278",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPNP: fix name memory leak in pnp_alloc_dev()\n\nAfter commit 1fa5ae857bb1 (\"driver core: get rid of struct device's\nbus_id string array\"), the name of device is allocated dynamically,\nmove dev_set_name() after pnp_add_id() to avoid memory leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50280",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npnode: terminate at peers of source\n\nThe propagate_mnt() function handles mount propagation when creating\nmounts and propagates the source mount tree @source_mnt to all\napplicable nodes of the destination propagation mount tree headed by\n@dest_mnt.\n\nUnfortunately it contains a bug where it fails to terminate at peers of\n@source_mnt when looking up copies of the source mount that become\nmasters for copies of the source mount tree mounted on top of slaves in\nthe destination propagation tree causing a NULL dereference.\n\nOnce the mechanics of the bug are understood it's easy to trigger.\nBecause of unprivileged user namespaces it is available to unprivileged\nusers.\n\nWhile fixing this bug we've gotten confused multiple times due to\nunclear terminology or missing concepts. So let's start this with some\nclarifications:\n\n* The terms \"master\" or \"peer\" denote a shared mount. A shared mount\n  belongs to a peer group.\n\n* A peer group is a set of shared mounts that propagate to each other.\n  They are identified by a peer group id. The peer group id is available\n  in @shared_mnt-\u003emnt_group_id.\n  Shared mounts within the same peer group have the same peer group id.\n  The peers in a peer group can be reached via @shared_mnt-\u003emnt_share.\n\n* The terms \"slave mount\" or \"dependent mount\" denote a mount that\n  receives propagation from a peer in a peer group. IOW, shared mounts\n  may have slave mounts and slave mounts have shared mounts as their\n  master. Slave mounts of a given peer in a peer group are listed on\n  that peers slave list available at @shared_mnt-\u003emnt_slave_list.\n\n* The term \"master mount\" denotes a mount in a peer group. IOW, it\n  denotes a shared mount or a peer mount in a peer group. The term\n  \"master mount\" - or \"master\" for short - is mostly used when talking\n  in the context of slave mounts that receive propagation from a master\n  mount. A master mount of a slave identifies the closest peer group a\n  slave mount receives propagation from. The master mount of a slave can\n  be identified via @slave_mount-\u003emnt_master. Different slaves may point\n  to different masters in the same peer group.\n\n* Multiple peers in a peer group can have non-empty -\u003emnt_slave_lists.\n  Non-empty -\u003emnt_slave_lists of peers don't intersect. Consequently, to\n  ensure all slave mounts of a peer group are visited the\n  -\u003emnt_slave_lists of all peers in a peer group have to be walked.\n\n* Slave mounts point to a peer in the closest peer group they receive\n  propagation from via @slave_mnt-\u003emnt_master (see above). Together with\n  these peers they form a propagation group (see below). The closest\n  peer group can thus be identified through the peer group id\n  @slave_mnt-\u003emnt_master-\u003emnt_group_id of the peer/master that a slave\n  mount receives propagation from.\n\n* A shared-slave mount is a slave mount to a peer group pg1 while also\n  a peer in another peer group pg2. IOW, a peer group may receive\n  propagation from another peer group.\n\n  If a peer group pg1 is a slave to another peer group pg2 then all\n  peers in peer group pg1 point to the same peer in peer group pg2 via\n  -\u003emnt_master. IOW, all peers in peer group pg1 appear on the same\n  -\u003emnt_slave_list. IOW, they cannot be slaves to different peer groups.\n\n* A pure slave mount is a slave mount that is a slave to a peer group\n  but is not a peer in another peer group.\n\n* A propagation group denotes the set of mounts consisting of a single\n  peer group pg1 and all slave mounts and shared-slave mounts that point\n  to a peer in that peer group via -\u003emnt_master. IOW, all slave mounts\n  such that @slave_mnt-\u003emnt_master-\u003emnt_group_id is equal to\n  @shared_mnt-\u003emnt_group_id.\n\n  The concept of a propagation group makes it easier to talk about a\n  single propagation level in a propagation tree.\n\n  For example, in propagate_mnt() the immediate peers of @dest_mnt and\n  all slaves of @dest_mnt's peer group form a propagation group pr\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50282",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nchardev: fix error handling in cdev_device_add()\n\nWhile doing fault injection test, I got the following report:\n\n------------[ cut here ]------------\nkobject: '(null)' (0000000039956980): is not initialized, yet kobject_put() is being called.\nWARNING: CPU: 3 PID: 6306 at kobject_put+0x23d/0x4e0\nCPU: 3 PID: 6306 Comm: 283 Tainted: G        W          6.1.0-rc2-00005-g307c1086d7c9 #1253\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nRIP: 0010:kobject_put+0x23d/0x4e0\nCall Trace:\n \u003cTASK\u003e\n cdev_device_add+0x15e/0x1b0\n __iio_device_register+0x13b4/0x1af0 [industrialio]\n __devm_iio_device_register+0x22/0x90 [industrialio]\n max517_probe+0x3d8/0x6b4 [max517]\n i2c_device_probe+0xa81/0xc00\n\nWhen device_add() is injected fault and returns error, if dev-\u003edevt is not set,\ncdev_add() is not called, cdev_del() is not needed. Fix this by checking dev-\u003edevt\nin error path.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50285",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm,hugetlb: take hugetlb_lock before decrementing h-\u003eresv_huge_pages\n\nThe h-\u003e*_huge_pages counters are protected by the hugetlb_lock, but\nalloc_huge_page has a corner case where it can decrement the counter\noutside of the lock.\n\nThis could lead to a corrupted value of h-\u003eresv_huge_pages, which we have\nobserved on our systems.\n\nTake the hugetlb_lock before decrementing h-\u003eresv_huge_pages to avoid a\npotential race.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50288",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nqlcnic: prevent -\u003edcb use-after-free on qlcnic_dcb_enable() failure\n\nadapter-\u003edcb would get silently freed inside qlcnic_dcb_enable() in\ncase qlcnic_dcb_attach() would return an error, which always happens\nunder OOM conditions. This would lead to use-after-free because both\nof the existing callers invoke qlcnic_dcb_get_info() on the obtained\npointer, which is potentially freed at that point.\n\nPropagate errors from qlcnic_dcb_enable(), and instead free the dcb\npointer at callsite using qlcnic_dcb_free(). This also removes the now\nunused qlcnic_clear_dcb_ops() helper, which was a simple wrapper around\nkfree() also causing memory leaks for partially initialized dcb.\n\nFound by Linux Verification Center (linuxtesting.org) with the SVACE\nstatic analysis tool.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50289",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix memory leak in ocfs2_stack_glue_init()\n\nocfs2_table_header should be free in ocfs2_stack_glue_init() if\nocfs2_sysfs_init() failed, otherwise kmemleak will report memleak.\n\nBUG: memory leak\nunreferenced object 0xffff88810eeb5800 (size 128):\n  comm \"modprobe\", pid 4507, jiffies 4296182506 (age 55.888s)\n  hex dump (first 32 bytes):\n    c0 40 14 a0 ff ff ff ff 00 00 00 00 01 00 00 00  .@..............\n    01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [\u003c000000001e59e1cd\u003e] __register_sysctl_table+0xca/0xef0\n    [\u003c00000000c04f70f7\u003e] 0xffffffffa0050037\n    [\u003c000000001bd12912\u003e] do_one_initcall+0xdb/0x480\n    [\u003c0000000064f766c9\u003e] do_init_module+0x1cf/0x680\n    [\u003c000000002ba52db0\u003e] load_module+0x6441/0x6f20\n    [\u003c000000009772580d\u003e] __do_sys_finit_module+0x12f/0x1c0\n    [\u003c00000000380c1f22\u003e] do_syscall_64+0x3f/0x90\n    [\u003c000000004cf473bc\u003e] entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50291",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkcm: annotate data-races around kcm-\u003erx_psock\n\nkcm-\u003erx_psock can be read locklessly in kcm_rfree().\nAnnotate the read and writes accordingly.\n\nWe do the same for kcm-\u003erx_wait in the following patch.\n\nsyzbot reported:\nBUG: KCSAN: data-race in kcm_rfree / unreserve_rx_kcm\n\nwrite to 0xffff888123d827b8 of 8 bytes by task 2758 on cpu 1:\nunreserve_rx_kcm+0x72/0x1f0 net/kcm/kcmsock.c:313\nkcm_rcv_strparser+0x2b5/0x3a0 net/kcm/kcmsock.c:373\n__strp_recv+0x64c/0xd20 net/strparser/strparser.c:301\nstrp_recv+0x6d/0x80 net/strparser/strparser.c:335\ntcp_read_sock+0x13e/0x5a0 net/ipv4/tcp.c:1703\nstrp_read_sock net/strparser/strparser.c:358 [inline]\ndo_strp_work net/strparser/strparser.c:406 [inline]\nstrp_work+0xe8/0x180 net/strparser/strparser.c:415\nprocess_one_work+0x3d3/0x720 kernel/workqueue.c:2289\nworker_thread+0x618/0xa70 kernel/workqueue.c:2436\nkthread+0x1a9/0x1e0 kernel/kthread.c:376\nret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n\nread to 0xffff888123d827b8 of 8 bytes by task 5859 on cpu 0:\nkcm_rfree+0x14c/0x220 net/kcm/kcmsock.c:181\nskb_release_head_state+0x8e/0x160 net/core/skbuff.c:841\nskb_release_all net/core/skbuff.c:852 [inline]\n__kfree_skb net/core/skbuff.c:868 [inline]\nkfree_skb_reason+0x5c/0x260 net/core/skbuff.c:891\nkfree_skb include/linux/skbuff.h:1216 [inline]\nkcm_recvmsg+0x226/0x2b0 net/kcm/kcmsock.c:1161\n____sys_recvmsg+0x16c/0x2e0\n___sys_recvmsg net/socket.c:2743 [inline]\ndo_recvmmsg+0x2f1/0x710 net/socket.c:2837\n__sys_recvmmsg net/socket.c:2916 [inline]\n__do_sys_recvmmsg net/socket.c:2939 [inline]\n__se_sys_recvmmsg net/socket.c:2932 [inline]\n__x64_sys_recvmmsg+0xde/0x160 net/socket.c:2932\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nvalue changed: 0xffff88812971ce00 -\u003e 0x0000000000000000\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 5859 Comm: syz-executor.3 Not tainted 6.0.0-syzkaller-12189-g19d17ab7c68b-dirty #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50293",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do not BUG_ON() on ENOMEM when dropping extent items for a range\n\nIf we get -ENOMEM while dropping file extent items in a given range, at\nbtrfs_drop_extents(), due to failure to allocate memory when attempting to\nincrement the reference count for an extent or drop the reference count,\nwe handle it with a BUG_ON(). This is excessive, instead we can simply\nabort the transaction and return the error to the caller. In fact most\ncallers of btrfs_drop_extents(), directly or indirectly, already abort\nthe transaction if btrfs_drop_extents() returns any error.\n\nAlso, we already have error paths at btrfs_drop_extents() that may return\n-ENOMEM and in those cases we abort the transaction, like for example\nanything that changes the b+tree may return -ENOMEM due to a failure to\nallocate a new extent buffer when COWing an existing extent buffer, such\nas a call to btrfs_duplicate_item() for example.\n\nSo replace the BUG_ON() calls with proper logic to abort the transaction\nand return the error.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50294",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: libertas: fix memory leak in lbs_init_adapter()\n\nWhen kfifo_alloc() failed in lbs_init_adapter(), cmd buffer is not\nreleased. Add free memory to processing error path.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50297",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: verify the expected usb_endpoints are present\n\nThe bug arises when a USB device claims to be an ATH9K but doesn't\nhave the expected endpoints. (In this case there was an interrupt\nendpoint where the driver expected a bulk endpoint.) The kernel\nneeds to be able to handle such devices without getting an internal error.\n\nusb 1-1: BOGUS urb xfer, pipe 3 != type 1\nWARNING: CPU: 3 PID: 500 at drivers/usb/core/urb.c:493 usb_submit_urb+0xce2/0x1430 drivers/usb/core/urb.c:493\nModules linked in:\nCPU: 3 PID: 500 Comm: kworker/3:2 Not tainted 5.10.135-syzkaller #0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nWorkqueue: events request_firmware_work_func\nRIP: 0010:usb_submit_urb+0xce2/0x1430 drivers/usb/core/urb.c:493\nCall Trace:\n ath9k_hif_usb_alloc_rx_urbs drivers/net/wireless/ath/ath9k/hif_usb.c:908 [inline]\n ath9k_hif_usb_alloc_urbs+0x75e/0x1010 drivers/net/wireless/ath/ath9k/hif_usb.c:1019\n ath9k_hif_usb_dev_init drivers/net/wireless/ath/ath9k/hif_usb.c:1109 [inline]\n ath9k_hif_usb_firmware_cb+0x142/0x530 drivers/net/wireless/ath/ath9k/hif_usb.c:1242\n request_firmware_work_func+0x12e/0x240 drivers/base/firmware_loader/main.c:1097\n process_one_work+0x9af/0x1600 kernel/workqueue.c:2279\n worker_thread+0x61d/0x12f0 kernel/workqueue.c:2425\n kthread+0x3b4/0x4a0 kernel/kthread.c:313\n ret_from_fork+0x22/0x30 arch/x86/entry/entry_64.S:299\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50299",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: Replace snprintf with scnprintf\n\nCurrent code produces a warning as shown below when total characters\nin the constituent block device names plus the slashes exceeds 200.\nsnprintf() returns the number of characters generated from the given\ninput, which could cause the expression \"200 - len\" to wrap around\nto a large positive number. Fix this by using scnprintf() instead,\nwhich returns the actual number of characters written into the buffer.\n\n[ 1513.267938] ------------[ cut here ]------------\n[ 1513.267943] WARNING: CPU: 15 PID: 37247 at \u003csnip\u003e/lib/vsprintf.c:2509 vsnprintf+0x2c8/0x510\n[ 1513.267944] Modules linked in:  \u003csnip\u003e\n[ 1513.267969] CPU: 15 PID: 37247 Comm: mdadm Not tainted 5.4.0-1085-azure #90~18.04.1-Ubuntu\n[ 1513.267969] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 05/09/2022\n[ 1513.267971] RIP: 0010:vsnprintf+0x2c8/0x510\n\u003c-snip-\u003e\n[ 1513.267982] Call Trace:\n[ 1513.267986]  snprintf+0x45/0x70\n[ 1513.267990]  ? disk_name+0x71/0xa0\n[ 1513.267993]  dump_zones+0x114/0x240 [raid0]\n[ 1513.267996]  ? _cond_resched+0x19/0x40\n[ 1513.267998]  raid0_run+0x19e/0x270 [raid0]\n[ 1513.268000]  md_run+0x5e0/0xc50\n[ 1513.268003]  ? security_capable+0x3f/0x60\n[ 1513.268005]  do_md_run+0x19/0x110\n[ 1513.268006]  md_ioctl+0x195e/0x1f90\n[ 1513.268007]  blkdev_ioctl+0x91f/0x9f0\n[ 1513.268010]  block_ioctl+0x3d/0x50\n[ 1513.268012]  do_vfs_ioctl+0xa9/0x640\n[ 1513.268014]  ? __fput+0x162/0x260\n[ 1513.268016]  ksys_ioctl+0x75/0x80\n[ 1513.268017]  __x64_sys_ioctl+0x1a/0x20\n[ 1513.268019]  do_syscall_64+0x5e/0x200\n[ 1513.268021]  entry_SYSCALL_64_after_hwframe+0x44/0xa9",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50304",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: core: fix possible resource leak in init_mtd()\n\nI got the error report while inject fault in init_mtd():\n\nsysfs: cannot create duplicate filename '/devices/virtual/bdi/mtd-0'\nCall Trace:\n \u003cTASK\u003e\n dump_stack_lvl+0x67/0x83\n sysfs_warn_dup+0x60/0x70\n sysfs_create_dir_ns+0x109/0x120\n kobject_add_internal+0xce/0x2f0\n kobject_add+0x98/0x110\n device_add+0x179/0xc00\n device_create_groups_vargs+0xf4/0x100\n device_create+0x7b/0xb0\n bdi_register_va.part.13+0x58/0x2d0\n bdi_register+0x9b/0xb0\n init_mtd+0x62/0x171 [mtd]\n do_one_initcall+0x6c/0x3c0\n do_init_module+0x58/0x222\n load_module+0x268e/0x27d0\n __do_sys_finit_module+0xd5/0x140\n do_syscall_64+0x37/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n \u003c/TASK\u003e\nkobject_add_internal failed for mtd-0 with -EEXIST, don't try to register\n\tthings with the same name in the same directory.\nError registering mtd class or bdi: -17\n\nIf init_mtdchar() fails in init_mtd(), mtd_bdi will not be unregistered,\nas a result, we can't load the mtd module again, to fix this by calling\nbdi_unregister(mtd_bdi) after out_procfs label.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50311",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxl: Fix refcount leak in cxl_calc_capp_routing\n\nof_get_next_parent() returns a node pointer with refcount incremented,\nwe should use of_node_put() on it when not need anymore.\nThis function only calls of_node_put() in normal path,\nmissing it in the error path.\nAdd missing of_node_put() to avoid refcount leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50312",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: serial: jsm: fix some leaks in probe\n\nThis error path needs to unwind instead of just returning directly.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50321",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix potential memory leak in brcmf_netdev_start_xmit()\n\nThe brcmf_netdev_start_xmit() returns NETDEV_TX_OK without freeing skb\nin case of pskb_expand_head() fails, add dev_kfree_skb() to fix it.\nCompile tested only.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50327",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: processor: idle: Check acpi_fetch_acpi_dev() return value\n\nThe return value of acpi_fetch_acpi_dev() could be NULL, which would\ncause a NULL pointer dereference to occur in acpi_device_hid().\n\n[ rjw: Subject and changelog edits, added empty line after if () ]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50330",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: cavium - prevent integer overflow loading firmware\n\nThe \"code_length\" value comes from the firmware file.  If your firmware\nis untrusted realistically there is probably very little you can do to\nprotect yourself.  Still we try to limit the damage as much as possible.\nAlso Smatch marks any data read from the filesystem as untrusted and\nprints warnings if it not capped correctly.\n\nThe \"ntohl(ucode-\u003ecode_length) * 2\" multiplication can have an\ninteger overflow.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50344",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix null-ptr-deref in ext4_write_info\n\nI caught a null-ptr-deref bug as follows:\n==================================================================\nKASAN: null-ptr-deref in range [0x0000000000000068-0x000000000000006f]\nCPU: 1 PID: 1589 Comm: umount Not tainted 5.10.0-02219-dirty #339\nRIP: 0010:ext4_write_info+0x53/0x1b0\n[...]\nCall Trace:\n dquot_writeback_dquots+0x341/0x9a0\n ext4_sync_fs+0x19e/0x800\n __sync_filesystem+0x83/0x100\n sync_filesystem+0x89/0xf0\n generic_shutdown_super+0x79/0x3e0\n kill_block_super+0xa1/0x110\n deactivate_locked_super+0xac/0x130\n deactivate_super+0xb6/0xd0\n cleanup_mnt+0x289/0x400\n __cleanup_mnt+0x16/0x20\n task_work_run+0x11c/0x1c0\n exit_to_user_mode_prepare+0x203/0x210\n syscall_exit_to_user_mode+0x5b/0x3a0\n do_syscall_64+0x59/0x70\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n ==================================================================\n\nAbove issue may happen as follows:\n-------------------------------------\nexit_to_user_mode_prepare\n task_work_run\n  __cleanup_mnt\n   cleanup_mnt\n    deactivate_super\n     deactivate_locked_super\n      kill_block_super\n       generic_shutdown_super\n        shrink_dcache_for_umount\n         dentry = sb-\u003es_root\n         sb-\u003es_root = NULL              \u003c--- Here set NULL\n        sync_filesystem\n         __sync_filesystem\n          sb-\u003es_op-\u003esync_fs \u003e ext4_sync_fs\n           dquot_writeback_dquots\n            sb-\u003edq_op-\u003ewrite_info \u003e ext4_write_info\n             ext4_journal_start(d_inode(sb-\u003es_root), EXT4_HT_QUOTA, 2)\n              d_inode(sb-\u003es_root)\n               s_root-\u003ed_inode          \u003c--- Null pointer dereference\n\nTo solve this problem, we use ext4_journal_start_sb directly\nto avoid s_root being used.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50346",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: init quota for 'old.inode' in 'ext4_rename'\n\nSyzbot found the following issue:\next4_parse_param: s_want_extra_isize=128\next4_inode_info_init: s_want_extra_isize=32\next4_rename: old.inode=ffff88823869a2c8 old.dir=ffff888238699828 new.inode=ffff88823869d7e8 new.dir=ffff888238699828\n__ext4_mark_inode_dirty: inode=ffff888238699828 ea_isize=32 want_ea_size=128\n__ext4_mark_inode_dirty: inode=ffff88823869a2c8 ea_isize=32 want_ea_size=128\next4_xattr_block_set: inode=ffff88823869a2c8\n------------[ cut here ]------------\nWARNING: CPU: 13 PID: 2234 at fs/ext4/xattr.c:2070 ext4_xattr_block_set.cold+0x22/0x980\nModules linked in:\nRIP: 0010:ext4_xattr_block_set.cold+0x22/0x980\nRSP: 0018:ffff888227d3f3b0 EFLAGS: 00010202\nRAX: 0000000000000001 RBX: ffff88823007a000 RCX: 0000000000000000\nRDX: 0000000000000a03 RSI: 0000000000000040 RDI: ffff888230078178\nRBP: 0000000000000000 R08: 000000000000002c R09: ffffed1075c7df8e\nR10: ffff8883ae3efc6b R11: ffffed1075c7df8d R12: 0000000000000000\nR13: ffff88823869a2c8 R14: ffff8881012e0460 R15: dffffc0000000000\nFS:  00007f350ac1f740(0000) GS:ffff8883ae200000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f350a6ed6a0 CR3: 0000000237456000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n \u003cTASK\u003e\n ? ext4_xattr_set_entry+0x3b7/0x2320\n ? ext4_xattr_block_set+0x0/0x2020\n ? ext4_xattr_set_entry+0x0/0x2320\n ? ext4_xattr_check_entries+0x77/0x310\n ? ext4_xattr_ibody_set+0x23b/0x340\n ext4_xattr_move_to_block+0x594/0x720\n ext4_expand_extra_isize_ea+0x59a/0x10f0\n __ext4_expand_extra_isize+0x278/0x3f0\n __ext4_mark_inode_dirty.cold+0x347/0x410\n ext4_rename+0xed3/0x174f\n vfs_rename+0x13a7/0x2510\n do_renameat2+0x55d/0x920\n __x64_sys_rename+0x7d/0xb0\n do_syscall_64+0x3b/0xa0\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nAs 'ext4_rename' will modify 'old.inode' ctime and mark inode dirty,\nwhich may trigger expand 'extra_isize' and allocate block. If inode\ndidn't init quota will lead to warning.  To solve above issue, init\n'old.inode' firstly in 'ext4_rename'.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50349",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: tifm: fix possible memory leak in tifm_7xx1_switch_media()\n\nIf device_register() returns error in tifm_7xx1_switch_media(),\nname of kobject which is allocated in dev_set_name() called in device_add()\nis leaked.\n\nNever directly free @dev after calling device_register(), even\nif it returned an error! Always use put_device() to give up the\nreference initialized.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50350",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: iscsi: Fix a race condition between login_work and the login thread\n\nIn case a malicious initiator sends some random data immediately after a\nlogin PDU; the iscsi_target_sk_data_ready() callback will schedule the\nlogin_work and, at the same time, the negotiation may end without clearing\nthe LOGIN_FLAGS_INITIAL_PDU flag (because no additional PDU exchanges are\nrequired to complete the login).\n\nThe login has been completed but the login_work function will find the\nLOGIN_FLAGS_INITIAL_PDU flag set and will never stop from rescheduling\nitself; at this point, if the initiator drops the connection, the\niscsit_conn structure will be freed, login_work will dereference a released\nsocket structure and the kernel crashes.\n\nBUG: kernel NULL pointer dereference, address: 0000000000000230\nPF: supervisor write access in kernel mode\nPF: error_code(0x0002) - not-present page\nWorkqueue: events iscsi_target_do_login_rx [iscsi_target_mod]\nRIP: 0010:_raw_read_lock_bh+0x15/0x30\nCall trace:\n iscsi_target_do_login_rx+0x75/0x3f0 [iscsi_target_mod]\n process_one_work+0x1e8/0x3c0\n\nFix this bug by forcing login_work to stop after the login has been\ncompleted and the socket callbacks have been restored.\n\nAdd a comment to clearify the return values of iscsi_target_do_login()",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50351",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix xid leak in cifs_create()\n\nIf the cifs already shutdown, we should free the xid before return,\notherwise, the xid will be leaked.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50352",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hns: fix possible memory leak in hnae_ae_register()\n\nInject fault while probing module, if device_register() fails,\nbut the refcount of kobject is not decreased to 0, the name\nallocated in dev_set_name() is leaked. Fix this by calling\nput_device(), so that name can be freed in callback function\nkobject_cleanup().\n\nunreferenced object 0xffff00c01aba2100 (size 128):\n  comm \"systemd-udevd\", pid 1259, jiffies 4294903284 (age 294.152s)\n  hex dump (first 32 bytes):\n    68 6e 61 65 30 00 00 00 18 21 ba 1a c0 00 ff ff  hnae0....!......\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [\u003c0000000034783f26\u003e] slab_post_alloc_hook+0xa0/0x3e0\n    [\u003c00000000748188f2\u003e] __kmem_cache_alloc_node+0x164/0x2b0\n    [\u003c00000000ab0743e8\u003e] __kmalloc_node_track_caller+0x6c/0x390\n    [\u003c000000006c0ffb13\u003e] kvasprintf+0x8c/0x118\n    [\u003c00000000fa27bfe1\u003e] kvasprintf_const+0x60/0xc8\n    [\u003c0000000083e10ed7\u003e] kobject_set_name_vargs+0x3c/0xc0\n    [\u003c000000000b87affc\u003e] dev_set_name+0x7c/0xa0\n    [\u003c000000003fd8fe26\u003e] hnae_ae_register+0xcc/0x190 [hnae]\n    [\u003c00000000fe97edc9\u003e] hns_dsaf_ae_init+0x9c/0x108 [hns_dsaf]\n    [\u003c00000000c36ff1eb\u003e] hns_dsaf_probe+0x548/0x748 [hns_dsaf]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50356",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: sfb: fix null pointer access issue when sfb_init() fails\n\nWhen the default qdisc is sfb, if the qdisc of dev_queue fails to be\ninited during mqprio_init(), sfb_reset() is invoked to clear resources.\nIn this case, the q-\u003eqdisc is NULL, and it will cause gpf issue.\n\nThe process is as follows:\nqdisc_create_dflt()\n\tsfb_init()\n\t\ttcf_block_get()          ---\u003efailed, q-\u003eqdisc is NULL\n\t...\n\tqdisc_put()\n\t\t...\n\t\tsfb_reset()\n\t\t\tqdisc_reset(q-\u003eqdisc)    ---\u003eq-\u003eqdisc is NULL\n\t\t\t\tops = qdisc-\u003eops\n\nThe following is the Call Trace information:\ngeneral protection fault, probably for non-canonical address\n0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f]\nRIP: 0010:qdisc_reset+0x2b/0x6f0\nCall Trace:\n\u003cTASK\u003e\nsfb_reset+0x37/0xd0\nqdisc_reset+0xed/0x6f0\nqdisc_destroy+0x82/0x4c0\nqdisc_put+0x9e/0xb0\nqdisc_create_dflt+0x2c3/0x4a0\nmqprio_init+0xa71/0x1760\nqdisc_create+0x3eb/0x1000\ntc_modify_qdisc+0x408/0x1720\nrtnetlink_rcv_msg+0x38e/0xac0\nnetlink_rcv_skb+0x12d/0x3a0\nnetlink_unicast+0x4a2/0x740\nnetlink_sendmsg+0x826/0xcc0\nsock_sendmsg+0xc5/0x100\n____sys_sendmsg+0x583/0x690\n___sys_sendmsg+0xe8/0x160\n__sys_sendmsg+0xbf/0x160\ndo_syscall_64+0x35/0x80\nentry_SYSCALL_64_after_hwframe+0x46/0xb0\nRIP: 0033:0x7f2164122d04\n\u003c/TASK\u003e",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50359",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: cx88: Fix a null-ptr-deref bug in buffer_prepare()\n\nWhen the driver calls cx88_risc_buffer() to prepare the buffer, the\nfunction call may fail, resulting in a empty buffer and null-ptr-deref\nlater in buffer_queue().\n\nThe following log can reveal it:\n\n[   41.822762] general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI\n[   41.824488] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n[   41.828027] RIP: 0010:buffer_queue+0xc2/0x500\n[   41.836311] Call Trace:\n[   41.836945]  __enqueue_in_driver+0x141/0x360\n[   41.837262]  vb2_start_streaming+0x62/0x4a0\n[   41.838216]  vb2_core_streamon+0x1da/0x2c0\n[   41.838516]  __vb2_init_fileio+0x981/0xbc0\n[   41.839141]  __vb2_perform_fileio+0xbf9/0x1120\n[   41.840072]  vb2_fop_read+0x20e/0x400\n[   41.840346]  v4l2_read+0x215/0x290\n[   41.840603]  vfs_read+0x162/0x4c0\n\nFix this by checking the return value of cx88_risc_buffer()\n\n[hverkuil: fix coding style issues]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50364",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: mux: reg: check return value after calling platform_get_resource()\n\nIt will cause null-ptr-deref in resource_size(), if platform_get_resource()\nreturns NULL, move calling resource_size() after devm_ioremap_resource() that\nwill check 'res' to avoid null-ptr-deref.\nAnd use devm_platform_get_and_ioremap_resource() to simplify code.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50365",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nskbuff: Account for tail adjustment during pull operations\n\nExtending the tail can have some unexpected side effects if a program uses\na helper like BPF_FUNC_skb_pull_data to read partial content beyond the\nhead skb headlen when all the skbs in the gso frag_list are linear with no\nhead_frag -\n\n  kernel BUG at net/core/skbuff.c:4219!\n  pc : skb_segment+0xcf4/0xd2c\n  lr : skb_segment+0x63c/0xd2c\n  Call trace:\n   skb_segment+0xcf4/0xd2c\n   __udp_gso_segment+0xa4/0x544\n   udp4_ufo_fragment+0x184/0x1c0\n   inet_gso_segment+0x16c/0x3a4\n   skb_mac_gso_segment+0xd4/0x1b0\n   __skb_gso_segment+0xcc/0x12c\n   udp_rcv_segment+0x54/0x16c\n   udp_queue_rcv_skb+0x78/0x144\n   udp_unicast_rcv_skb+0x8c/0xa4\n   __udp4_lib_rcv+0x490/0x68c\n   udp_rcv+0x20/0x30\n   ip_protocol_deliver_rcu+0x1b0/0x33c\n   ip_local_deliver+0xd8/0x1f0\n   ip_rcv+0x98/0x1a4\n   deliver_ptype_list_skb+0x98/0x1ec\n   __netif_receive_skb_core+0x978/0xc60\n\nFix this by marking these skbs as GSO_DODGY so segmentation can handle\nthe tail updates accordingly.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50367",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: fix UAF/GPF bug in nilfs_mdt_destroy\n\nIn alloc_inode, inode_init_always() could return -ENOMEM if\nsecurity_inode_alloc() fails, which causes inode-\u003ei_private\nuninitialized. Then nilfs_is_metadata_file_inode() returns\ntrue and nilfs_free_inode() wrongly calls nilfs_mdt_destroy(),\nwhich frees the uninitialized inode-\u003ei_private\nand leads to crashes(e.g., UAF/GPF).\n\nFix this by moving security_inode_alloc just prior to\nthis_cpu_inc(nr_inodes)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50368",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm/dsi: fix memory corruption with too many bridges\n\nAdd the missing sanity check on the bridge counter to avoid corrupting\ndata beyond the fixed-sized bridge array in case there are ever more\nthan eight bridges.\n\nPatchwork: https://patchwork.freedesktop.org/patch/502668/",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50372",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix memory leak when build ntlmssp negotiate blob failed\n\nThere is a memory leak when mount cifs:\n  unreferenced object 0xffff888166059600 (size 448):\n    comm \"mount.cifs\", pid 51391, jiffies 4295596373 (age 330.596s)\n    hex dump (first 32 bytes):\n      fe 53 4d 42 40 00 00 00 00 00 00 00 01 00 82 00  .SMB@...........\n      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    backtrace:\n      [\u003c0000000060609a61\u003e] mempool_alloc+0xe1/0x260\n      [\u003c00000000adfa6c63\u003e] cifs_small_buf_get+0x24/0x60\n      [\u003c00000000ebb404c7\u003e] __smb2_plain_req_init+0x32/0x460\n      [\u003c00000000bcf875b4\u003e] SMB2_sess_alloc_buffer+0xa4/0x3f0\n      [\u003c00000000753a2987\u003e] SMB2_sess_auth_rawntlmssp_negotiate+0xf5/0x480\n      [\u003c00000000f0c1f4f9\u003e] SMB2_sess_setup+0x253/0x410\n      [\u003c00000000a8b83303\u003e] cifs_setup_session+0x18f/0x4c0\n      [\u003c00000000854bd16d\u003e] cifs_get_smb_ses+0xae7/0x13c0\n      [\u003c000000006cbc43d9\u003e] mount_get_conns+0x7a/0x730\n      [\u003c000000005922d816\u003e] cifs_mount+0x103/0xd10\n      [\u003c00000000e33def3b\u003e] cifs_smb3_do_mount+0x1dd/0xc90\n      [\u003c0000000078034979\u003e] smb3_get_tree+0x1d5/0x300\n      [\u003c000000004371f980\u003e] vfs_get_tree+0x41/0xf0\n      [\u003c00000000b670d8a7\u003e] path_mount+0x9b3/0xdd0\n      [\u003c000000005e839a7d\u003e] __x64_sys_mount+0x190/0x1d0\n      [\u003c000000009404c3b9\u003e] do_syscall_64+0x35/0x80\n\nWhen build ntlmssp negotiate blob failed, the session setup request\nshould be freed.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50375",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: serial: fsl_lpuart: disable dma rx/tx use flags in lpuart_dma_shutdown\n\nlpuart_dma_shutdown tears down lpuart dma, but lpuart_flush_buffer can\nstill occur which in turn tries to access dma apis if lpuart_dma_tx_use\nflag is true. At this point since dma is torn down, these dma apis can\nabort. Set lpuart_dma_tx_use and the corresponding rx flag\nlpuart_dma_rx_use to false in lpuart_dma_shutdown so that dmas are not\naccessed after they are relinquished.\n\nOtherwise, when try to kill btattach, kernel may panic. This patch may\nfix this issue.\nroot@imx8ulpevk:~# btattach -B /dev/ttyLP2 -S 115200\n^C[   90.182296] Internal error: synchronous external abort: 96000210 [#1] PREEMPT SMP\n[   90.189806] Modules linked in: moal(O) mlan(O)\n[   90.194258] CPU: 0 PID: 503 Comm: btattach Tainted: G           O      5.15.32-06136-g34eecdf2f9e4 #37\n[   90.203554] Hardware name: NXP i.MX8ULP 9X9 EVK (DT)\n[   90.208513] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   90.215470] pc : fsl_edma3_disable_request+0x8/0x60\n[   90.220358] lr : fsl_edma3_terminate_all+0x34/0x20c\n[   90.225237] sp : ffff800013f0bac0\n[   90.228548] x29: ffff800013f0bac0 x28: 0000000000000001 x27: ffff000008404800\n[   90.235681] x26: ffff000008404960 x25: ffff000008404a08 x24: ffff000008404a00\n[   90.242813] x23: ffff000008404a60 x22: 0000000000000002 x21: 0000000000000000\n[   90.249946] x20: ffff800013f0baf8 x19: ffff00000559c800 x18: 0000000000000000\n[   90.257078] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[   90.264211] x14: 0000000000000003 x13: 0000000000000000 x12: 0000000000000040\n[   90.271344] x11: ffff00000600c248 x10: ffff800013f0bb10 x9 : ffff000057bcb090\n[   90.278477] x8 : fffffc0000241a08 x7 : ffff00000534ee00 x6 : ffff000008404804\n[   90.285609] x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff0000055b3480\n[   90.292742] x2 : ffff8000135c0000 x1 : ffff00000534ee00 x0 : ffff00000559c800\n[   90.299876] Call trace:\n[   90.302321]  fsl_edma3_disable_request+0x8/0x60\n[   90.306851]  lpuart_flush_buffer+0x40/0x160\n[   90.311037]  uart_flush_buffer+0x88/0x120\n[   90.315050]  tty_driver_flush_buffer+0x20/0x30\n[   90.319496]  hci_uart_flush+0x44/0x90\n[   90.323162]  +0x34/0x12c\n[   90.327253]  tty_ldisc_close+0x38/0x70\n[   90.331005]  tty_ldisc_release+0xa8/0x190\n[   90.335018]  tty_release_struct+0x24/0x8c\n[   90.339022]  tty_release+0x3ec/0x4c0\n[   90.342593]  __fput+0x70/0x234\n[   90.345652]  ____fput+0x14/0x20\n[   90.348790]  task_work_run+0x84/0x17c\n[   90.352455]  do_exit+0x310/0x96c\n[   90.355688]  do_group_exit+0x3c/0xa0\n[   90.359259]  __arm64_sys_exit_group+0x1c/0x20\n[   90.363609]  invoke_syscall+0x48/0x114\n[   90.367362]  el0_svc_common.constprop.0+0xd4/0xfc\n[   90.372068]  do_el0_svc+0x2c/0x94\n[   90.375379]  el0_svc+0x28/0x80\n[   90.378438]  el0t_64_sync_handler+0xa8/0x130\n[   90.382711]  el0t_64_sync+0x1a0/0x1a4\n[   90.386376] Code: 17ffffda d503201f d503233f f9409802 (b9400041)\n[   90.392467] ---[ end trace 2f60524b4a43f1f6 ]---\n[   90.397073] note: btattach[503] exited with preempt_count 1\n[   90.402636] Fixing recursive fault but reboot is needed!",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50381",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: fix a crash in mempool_free\n\nThere's a crash in mempool_free when running the lvm test\nshell/lvchange-rebuild-raid.sh.\n\nThe reason for the crash is this:\n* super_written calls atomic_dec_and_test(\u0026mddev-\u003epending_writes) and\n  wake_up(\u0026mddev-\u003esb_wait). Then it calls rdev_dec_pending(rdev, mddev)\n  and bio_put(bio).\n* so, the process that waited on sb_wait and that is woken up is racing\n  with bio_put(bio).\n* if the process wins the race, it calls bioset_exit before bio_put(bio)\n  is executed.\n* bio_put(bio) attempts to free a bio into a destroyed bio set - causing\n  a crash in mempool_free.\n\nWe fix this bug by moving bio_put before atomic_dec_and_test.\n\nWe also move rdev_dec_pending before atomic_dec_and_test as suggested by\nNeil Brown.\n\nThe function md_end_flush has a similar bug - we must call bio_put before\nwe decrement the number of in-progress bios.\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor write access in kernel mode\n #PF: error_code(0x0002) - not-present page\n PGD 11557f0067 P4D 11557f0067 PUD 0\n Oops: 0002 [#1] PREEMPT SMP\n CPU: 0 PID: 73 Comm: kworker/0:1 Not tainted 6.1.0-rc3 #5\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014\n Workqueue: kdelayd flush_expired_bios [dm_delay]\n RIP: 0010:mempool_free+0x47/0x80\n Code: 48 89 ef 5b 5d ff e0 f3 c3 48 89 f7 e8 32 45 3f 00 48 63 53 08 48 89 c6 3b 53 04 7d 2d 48 8b 43 10 8d 4a 01 48 89 df 89 4b 08 \u003c48\u003e 89 2c d0 e8 b0 45 3f 00 48 8d 7b 30 5b 5d 31 c9 ba 01 00 00 00\n RSP: 0018:ffff88910036bda8 EFLAGS: 00010093\n RAX: 0000000000000000 RBX: ffff8891037b65d8 RCX: 0000000000000001\n RDX: 0000000000000000 RSI: 0000000000000202 RDI: ffff8891037b65d8\n RBP: ffff8891447ba240 R08: 0000000000012908 R09: 00000000003d0900\n R10: 0000000000000000 R11: 0000000000173544 R12: ffff889101a14000\n R13: ffff8891562ac300 R14: ffff889102b41440 R15: ffffe8ffffa00d05\n FS:  0000000000000000(0000) GS:ffff88942fa00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 0000001102e99000 CR4: 00000000000006b0\n Call Trace:\n  \u003cTASK\u003e\n  clone_endio+0xf4/0x1c0 [dm_mod]\n  clone_endio+0xf4/0x1c0 [dm_mod]\n  __submit_bio+0x76/0x120\n  submit_bio_noacct_nocheck+0xb6/0x2a0\n  flush_expired_bios+0x28/0x2f [dm_delay]\n  process_one_work+0x1b4/0x300\n  worker_thread+0x45/0x3e0\n  ? rescuer_thread+0x380/0x380\n  kthread+0xc2/0x100\n  ? kthread_complete_and_exit+0x20/0x20\n  ret_from_fork+0x1f/0x30\n  \u003c/TASK\u003e\n Modules linked in: brd dm_delay dm_raid dm_mod af_packet uvesafb cfbfillrect cfbimgblt cn cfbcopyarea fb font fbdev tun autofs4 binfmt_misc configfs ipv6 virtio_rng virtio_balloon rng_core virtio_net pcspkr net_failover failover qemu_fw_cfg button mousedev raid10 raid456 libcrc32c async_raid6_recov async_memcpy async_pq raid6_pq async_xor xor async_tx raid1 raid0 md_mod sd_mod t10_pi crc64_rocksoft crc64 virtio_scsi scsi_mod evdev psmouse bsg scsi_common [last unloaded: brd]\n CR2: 0000000000000000\n ---[ end trace 0000000000000000 ]---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50385",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix an Oops in nfs_d_automount()\n\nWhen mounting from a NFSv4 referral, path-\u003edentry can end up being a\nnegative dentry, so derive the struct nfs_server from the dentry\nitself instead.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50386",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix user-after-free\n\nThis uses l2cap_chan_hold_unless_zero() after calling\n__l2cap_get_chan_blah() to prevent the following trace:\n\nBluetooth: l2cap_core.c:static void l2cap_chan_destroy(struct kref\n*kref)\nBluetooth: chan 0000000023c4974d\nBluetooth: parent 00000000ae861c08\n==================================================================\nBUG: KASAN: use-after-free in __mutex_waiter_is_first\nkernel/locking/mutex.c:191 [inline]\nBUG: KASAN: use-after-free in __mutex_lock_common\nkernel/locking/mutex.c:671 [inline]\nBUG: KASAN: use-after-free in __mutex_lock+0x278/0x400\nkernel/locking/mutex.c:729\nRead of size 8 at addr ffff888006a49b08 by task kworker/u3:2/389",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50389",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntpm: tpm_crb: Add the missed acpi_put_table() to fix memory leak\n\nIn crb_acpi_add(), we get the TPM2 table to retrieve information\nlike start method, and then assign them to the priv data, so the\nTPM2 table is not used after the init, should be freed, call\nacpi_put_table() to fix the memory leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50394",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: ismt: Fix an out-of-bounds bug in ismt_access()\n\nWhen the driver does not check the data from the user, the variable\n'data-\u003eblock[0]' may be very large to cause an out-of-bounds bug.\n\nThe following log can reveal it:\n\n[   33.995542] i2c i2c-1: ioctl, cmd=0x720, arg=0x7ffcb3dc3a20\n[   33.995978] ismt_smbus 0000:00:05.0: I2C_SMBUS_BLOCK_DATA:  WRITE\n[   33.996475] ==================================================================\n[   33.996995] BUG: KASAN: out-of-bounds in ismt_access.cold+0x374/0x214b\n[   33.997473] Read of size 18446744073709551615 at addr ffff88810efcfdb1 by task ismt_poc/485\n[   33.999450] Call Trace:\n[   34.001849]  memcpy+0x20/0x60\n[   34.002077]  ismt_access.cold+0x374/0x214b\n[   34.003382]  __i2c_smbus_xfer+0x44f/0xfb0\n[   34.004007]  i2c_smbus_xfer+0x10a/0x390\n[   34.004291]  i2cdev_ioctl_smbus+0x2c8/0x710\n[   34.005196]  i2cdev_ioctl+0x5ec/0x74c\n\nFix this bug by checking the size of 'data-\u003eblock[0]' first.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50395",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nintegrity: Fix memory leakage in keyring allocation error path\n\nKey restriction is allocated in integrity_init_keyring(). However, if\nkeyring allocation failed, it is not freed, causing memory leaks.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50396",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix memory leak in tcindex_set_parms\n\nSyzkaller reports a memory leak as follows:\n====================================\nBUG: memory leak\nunreferenced object 0xffff88810c287f00 (size 256):\n  comm \"syz-executor105\", pid 3600, jiffies 4294943292 (age 12.990s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [\u003cffffffff814cf9f0\u003e] kmalloc_trace+0x20/0x90 mm/slab_common.c:1046\n    [\u003cffffffff839c9e07\u003e] kmalloc include/linux/slab.h:576 [inline]\n    [\u003cffffffff839c9e07\u003e] kmalloc_array include/linux/slab.h:627 [inline]\n    [\u003cffffffff839c9e07\u003e] kcalloc include/linux/slab.h:659 [inline]\n    [\u003cffffffff839c9e07\u003e] tcf_exts_init include/net/pkt_cls.h:250 [inline]\n    [\u003cffffffff839c9e07\u003e] tcindex_set_parms+0xa7/0xbe0 net/sched/cls_tcindex.c:342\n    [\u003cffffffff839caa1f\u003e] tcindex_change+0xdf/0x120 net/sched/cls_tcindex.c:553\n    [\u003cffffffff8394db62\u003e] tc_new_tfilter+0x4f2/0x1100 net/sched/cls_api.c:2147\n    [\u003cffffffff8389e91c\u003e] rtnetlink_rcv_msg+0x4dc/0x5d0 net/core/rtnetlink.c:6082\n    [\u003cffffffff839eba67\u003e] netlink_rcv_skb+0x87/0x1d0 net/netlink/af_netlink.c:2540\n    [\u003cffffffff839eab87\u003e] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n    [\u003cffffffff839eab87\u003e] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345\n    [\u003cffffffff839eb046\u003e] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921\n    [\u003cffffffff8383e796\u003e] sock_sendmsg_nosec net/socket.c:714 [inline]\n    [\u003cffffffff8383e796\u003e] sock_sendmsg+0x56/0x80 net/socket.c:734\n    [\u003cffffffff8383eb08\u003e] ____sys_sendmsg+0x178/0x410 net/socket.c:2482\n    [\u003cffffffff83843678\u003e] ___sys_sendmsg+0xa8/0x110 net/socket.c:2536\n    [\u003cffffffff838439c5\u003e] __sys_sendmmsg+0x105/0x330 net/socket.c:2622\n    [\u003cffffffff83843c14\u003e] __do_sys_sendmmsg net/socket.c:2651 [inline]\n    [\u003cffffffff83843c14\u003e] __se_sys_sendmmsg net/socket.c:2648 [inline]\n    [\u003cffffffff83843c14\u003e] __x64_sys_sendmmsg+0x24/0x30 net/socket.c:2648\n    [\u003cffffffff84605fd5\u003e] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n    [\u003cffffffff84605fd5\u003e] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n    [\u003cffffffff84800087\u003e] entry_SYSCALL_64_after_hwframe+0x63/0xcd\n====================================\n\nKernel uses tcindex_change() to change an existing\nfilter properties.\n\nYet the problem is that, during the process of changing,\nif `old_r` is retrieved from `p-\u003eperfect`, then\nkernel uses tcindex_alloc_perfect_hash() to newly\nallocate filter results, uses tcindex_filter_result_init()\nto clear the old filter result, without destroying\nits tcf_exts structure, which triggers the above memory leak.\n\nTo be more specific, there are only two source for the `old_r`,\naccording to the tcindex_lookup(). `old_r` is retrieved from\n`p-\u003eperfect`, or `old_r` is retrieved from `p-\u003eh`.\n\n  * If `old_r` is retrieved from `p-\u003eperfect`, kernel uses\ntcindex_alloc_perfect_hash() to newly allocate the\nfilter results. Then `r` is assigned with `cp-\u003eperfect + handle`,\nwhich is newly allocated. So condition `old_r \u0026\u0026 old_r != r` is\ntrue in this situation, and kernel uses tcindex_filter_result_init()\nto clear the old filter result, without destroying\nits tcf_exts structure\n\n  * If `old_r` is retrieved from `p-\u003eh`, then `p-\u003eperfect` is NULL\naccording to the tcindex_lookup(). Considering that `cp-\u003eh`\nis directly copied from `p-\u003eh` and `p-\u003eperfect` is NULL,\n`r` is assigned with `tcindex_lookup(cp, handle)`, whose value\nshould be the same as `old_r`, so condition `old_r \u0026\u0026 old_r != r`\nis false in this situation, kernel ignores using\ntcindex_filter_result_init() to clear the old filter result.\n\nSo only when `old_r` is retrieved from `p-\u003eperfect` does kernel use\ntcindex_filter_result_init() to clear the old filter result, which\ntriggers the above memory leak.\n\nConsidering that there already exists a tc_filter_wq workqueue\nto destroy the old tcindex_d\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50401",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: under NFSv4.1, fix double svc_xprt_put on rpc_create failure\n\nOn error situation `clp-\u003ecl_cb_conn.cb_xprt` should not be given\na reference to the xprt otherwise both client cleanup and the\nerror handling path of the caller call to put it. Better to\ndelay handing over the reference to a later branch.\n\n[   72.530665] refcount_t: underflow; use-after-free.\n[   72.531933] WARNING: CPU: 0 PID: 173 at lib/refcount.c:28 refcount_warn_saturate+0xcf/0x120\n[   72.533075] Modules linked in: nfsd(OE) nfsv4(OE) nfsv3(OE) nfs(OE) lockd(OE) compat_nfs_ssc(OE) nfs_acl(OE) rpcsec_gss_krb5(OE) auth_rpcgss(OE) rpcrdma(OE) dns_resolver fscache netfs grace rdma_cm iw_cm ib_cm sunrpc(OE) mlx5_ib mlx5_core mlxfw pci_hyperv_intf ib_uverbs ib_core xt_MASQUERADE nf_conntrack_netlink nft_counter xt_addrtype nft_compat br_netfilter bridge stp llc nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set overlay nf_tables nfnetlink crct10dif_pclmul crc32_pclmul ghash_clmulni_intel xfs serio_raw virtio_net virtio_blk net_failover failover fuse [last unloaded: sunrpc]\n[   72.540389] CPU: 0 PID: 173 Comm: kworker/u16:5 Tainted: G           OE     5.15.82-dan #1\n[   72.541511] Hardware name: Red Hat KVM/RHEL-AV, BIOS 1.16.0-3.module+el8.7.0+1084+97b81f61 04/01/2014\n[   72.542717] Workqueue: nfsd4_callbacks nfsd4_run_cb_work [nfsd]\n[   72.543575] RIP: 0010:refcount_warn_saturate+0xcf/0x120\n[   72.544299] Code: 55 00 0f 0b 5d e9 01 50 98 00 80 3d 75 9e 39 08 00 0f 85 74 ff ff ff 48 c7 c7 e8 d1 60 8e c6 05 61 9e 39 08 01 e8 f6 51 55 00 \u003c0f\u003e 0b 5d e9 d9 4f 98 00 80 3d 4b 9e 39 08 00 0f 85 4c ff ff ff 48\n[   72.546666] RSP: 0018:ffffb3f841157cf0 EFLAGS: 00010286\n[   72.547393] RAX: 0000000000000026 RBX: ffff89ac6231d478 RCX: 0000000000000000\n[   72.548324] RDX: ffff89adb7c2c2c0 RSI: ffff89adb7c205c0 RDI: ffff89adb7c205c0\n[   72.549271] RBP: ffffb3f841157cf0 R08: 0000000000000000 R09: c0000000ffefffff\n[   72.550209] R10: 0000000000000001 R11: ffffb3f841157ad0 R12: ffff89ac6231d180\n[   72.551142] R13: ffff89ac6231d478 R14: ffff89ac40c06180 R15: ffff89ac6231d4b0\n[   72.552089] FS:  0000000000000000(0000) GS:ffff89adb7c00000(0000) knlGS:0000000000000000\n[   72.553175] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   72.553934] CR2: 0000563a310506a8 CR3: 0000000109a66000 CR4: 0000000000350ef0\n[   72.554874] Call Trace:\n[   72.555278]  \u003cTASK\u003e\n[   72.555614]  svc_xprt_put+0xaf/0xe0 [sunrpc]\n[   72.556276]  nfsd4_process_cb_update.isra.11+0xb7/0x410 [nfsd]\n[   72.557087]  ? update_load_avg+0x82/0x610\n[   72.557652]  ? cpuacct_charge+0x60/0x70\n[   72.558212]  ? dequeue_entity+0xdb/0x3e0\n[   72.558765]  ? queued_spin_unlock+0x9/0x20\n[   72.559358]  nfsd4_run_cb_work+0xfc/0x270 [nfsd]\n[   72.560031]  process_one_work+0x1df/0x390\n[   72.560600]  worker_thread+0x37/0x3b0\n[   72.561644]  ? process_one_work+0x390/0x390\n[   72.562247]  kthread+0x12f/0x150\n[   72.562710]  ? set_kthread_struct+0x50/0x50\n[   72.563309]  ret_from_fork+0x22/0x30\n[   72.563818]  \u003c/TASK\u003e\n[   72.564189] ---[ end trace 031117b1c72ec616 ]---\n[   72.566019] list_add corruption. next-\u003eprev should be prev (ffff89ac4977e538), but was ffff89ac4763e018. (next=ffff89ac4763e018).\n[   72.567647] ------------[ cut here ]------------",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50402",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers/md/md-bitmap: check the return value of md_bitmap_get_counter()\n\nCheck the return value of md_bitmap_get_counter() in case it returns\nNULL pointer, which will result in a null pointer dereference.\n\nv2: update the check to include other dereference",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50405",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/tunnel: wait until all sk_user_data reader finish before releasing the sock\n\nThere is a race condition in vxlan that when deleting a vxlan device\nduring receiving packets, there is a possibility that the sock is\nreleased after getting vxlan_sock vs from sk_user_data. Then in\nlater vxlan_ecn_decapsulate(), vxlan_get_sk_family() we will got\nNULL pointer dereference. e.g.\n\n   #0 [ffffa25ec6978a38] machine_kexec at ffffffff8c669757\n   #1 [ffffa25ec6978a90] __crash_kexec at ffffffff8c7c0a4d\n   #2 [ffffa25ec6978b58] crash_kexec at ffffffff8c7c1c48\n   #3 [ffffa25ec6978b60] oops_end at ffffffff8c627f2b\n   #4 [ffffa25ec6978b80] page_fault_oops at ffffffff8c678fcb\n   #5 [ffffa25ec6978bd8] exc_page_fault at ffffffff8d109542\n   #6 [ffffa25ec6978c00] asm_exc_page_fault at ffffffff8d200b62\n      [exception RIP: vxlan_ecn_decapsulate+0x3b]\n      RIP: ffffffffc1014e7b  RSP: ffffa25ec6978cb0  RFLAGS: 00010246\n      RAX: 0000000000000008  RBX: ffff8aa000888000  RCX: 0000000000000000\n      RDX: 000000000000000e  RSI: ffff8a9fc7ab803e  RDI: ffff8a9fd1168700\n      RBP: ffff8a9fc7ab803e   R8: 0000000000700000   R9: 00000000000010ae\n      R10: ffff8a9fcb748980  R11: 0000000000000000  R12: ffff8a9fd1168700\n      R13: ffff8aa000888000  R14: 00000000002a0000  R15: 00000000000010ae\n      ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n   #7 [ffffa25ec6978ce8] vxlan_rcv at ffffffffc10189cd [vxlan]\n   #8 [ffffa25ec6978d90] udp_queue_rcv_one_skb at ffffffff8cfb6507\n   #9 [ffffa25ec6978dc0] udp_unicast_rcv_skb at ffffffff8cfb6e45\n  #10 [ffffa25ec6978dc8] __udp4_lib_rcv at ffffffff8cfb8807\n  #11 [ffffa25ec6978e20] ip_protocol_deliver_rcu at ffffffff8cf76951\n  #12 [ffffa25ec6978e48] ip_local_deliver at ffffffff8cf76bde\n  #13 [ffffa25ec6978ea0] __netif_receive_skb_one_core at ffffffff8cecde9b\n  #14 [ffffa25ec6978ec8] process_backlog at ffffffff8cece139\n  #15 [ffffa25ec6978f00] __napi_poll at ffffffff8ceced1a\n  #16 [ffffa25ec6978f28] net_rx_action at ffffffff8cecf1f3\n  #17 [ffffa25ec6978fa0] __softirqentry_text_start at ffffffff8d4000ca\n  #18 [ffffa25ec6978ff0] do_softirq at ffffffff8c6fbdc3\n\nReproducer: https://github.com/Mellanox/ovs-tests/blob/master/test-ovs-vxlan-remove-tunnel-during-traffic.sh\n\nFix this by waiting for all sk_user_data reader to finish before\nreleasing the sock.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50406",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niomap: iomap: fix memory corruption when recording errors during writeback\n\nEvery now and then I see this crash on arm64:\n\nUnable to handle kernel NULL pointer dereference at virtual address 00000000000000f8\nBuffer I/O error on dev dm-0, logical block 8733687, async page read\nMem abort info:\n  ESR = 0x0000000096000006\n  EC = 0x25: DABT (current EL), IL = 32 bits\n  SET = 0, FnV = 0\n  EA = 0, S1PTW = 0\n  FSC = 0x06: level 2 translation fault\nData abort info:\n  ISV = 0, ISS = 0x00000006\n  CM = 0, WnR = 0\nuser pgtable: 64k pages, 42-bit VAs, pgdp=0000000139750000\n[00000000000000f8] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000, pmd=0000000000000000\nInternal error: Oops: 96000006 [#1] PREEMPT SMP\nBuffer I/O error on dev dm-0, logical block 8733688, async page read\nDumping ftrace buffer:\nBuffer I/O error on dev dm-0, logical block 8733689, async page read\n   (ftrace buffer empty)\nXFS (dm-0): log I/O error -5\nModules linked in: dm_thin_pool dm_persistent_data\nXFS (dm-0): Metadata I/O Error (0x1) detected at xfs_trans_read_buf_map+0x1ec/0x590 [xfs] (fs/xfs/xfs_trans_buf.c:296).\n dm_bio_prison\nXFS (dm-0): Please unmount the filesystem and rectify the problem(s)\nXFS (dm-0): xfs_imap_lookup: xfs_ialloc_read_agi() returned error -5, agno 0\n dm_bufio dm_log_writes xfs nft_chain_nat xt_REDIRECT nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip6t_REJECT\npotentially unexpected fatal signal 6.\n nf_reject_ipv6\npotentially unexpected fatal signal 6.\n ipt_REJECT nf_reject_ipv4\nCPU: 1 PID: 122166 Comm: fsstress Tainted: G        W          6.0.0-rc5-djwa #rc5 3004c9f1de887ebae86015f2677638ce51ee7\n rpcsec_gss_krb5 auth_rpcgss xt_tcpudp ip_set_hash_ip ip_set_hash_net xt_set nft_compat ip_set_hash_mac ip_set nf_tables\nHardware name: QEMU KVM Virtual Machine, BIOS 1.5.1 06/16/2021\npstate: 60001000 (nZCv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--)\n ip_tables\npc : 000003fd6d7df200\n x_tables\nlr : 000003fd6d7df1ec\n overlay nfsv4\nCPU: 0 PID: 54031 Comm: u4:3 Tainted: G        W          6.0.0-rc5-djwa #rc5 3004c9f1de887ebae86015f2677638ce51ee7405\nHardware name: QEMU KVM Virtual Machine, BIOS 1.5.1 06/16/2021\nWorkqueue: writeback wb_workfn\nsp : 000003ffd9522fd0\n (flush-253:0)\npstate: 60401005 (nZCv daif +PAN -UAO -TCO -DIT +SSBS BTYPE=--)\npc : errseq_set+0x1c/0x100\nx29: 000003ffd9522fd0 x28: 0000000000000023 x27: 000002acefeb6780\nx26: 0000000000000005 x25: 0000000000000001 x24: 0000000000000000\nx23: 00000000ffffffff x22: 0000000000000005\nlr : __filemap_set_wb_err+0x24/0xe0\n x21: 0000000000000006\nsp : fffffe000f80f760\nx29: fffffe000f80f760 x28: 0000000000000003 x27: fffffe000f80f9f8\nx26: 0000000002523000 x25: 00000000fffffffb x24: fffffe000f80f868\nx23: fffffe000f80fbb0 x22: fffffc0180c26a78 x21: 0000000002530000\nx20: 0000000000000000 x19: 0000000000000000 x18: 0000000000000000\n\nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\nx14: 0000000000000001 x13: 0000000000470af3 x12: fffffc0058f70000\nx11: 0000000000000040 x10: 0000000000001b20 x9 : fffffe000836b288\nx8 : fffffc00eb9fd480 x7 : 0000000000f83659 x6 : 0000000000000000\nx5 : 0000000000000869 x4 : 0000000000000005 x3 : 00000000000000f8\nx20: 000003fd6d740020 x19: 000000000001dd36 x18: 0000000000000001\nx17: 000003fd6d78704c x16: 0000000000000001 x15: 000002acfac87668\nx2 : 0000000000000ffa x1 : 00000000fffffffb x0 : 00000000000000f8\nCall trace:\n errseq_set+0x1c/0x100\n __filemap_set_wb_err+0x24/0xe0\n iomap_do_writepage+0x5e4/0xd5c\n write_cache_pages+0x208/0x674\n iomap_writepages+0x34/0x60\n xfs_vm_writepages+0x8c/0xcc [xfs 7a861f39c43631f15d3a5884246ba5035d4ca78b]\nx14: 0000000000000000 x13: 2064656e72757465 x12: 0000000000002180\nx11: 000003fd6d8a82d0 x10: 0000000000000000 x9 : 000003fd6d8ae288\nx8 : 0000000000000083 x7 : 00000000ffffffff x6 : 00000000ffffffee\nx5 : 00000000fbad2887 x4 : 000003fd6d9abb58 x3 : 000003fd6d740020\nx2 : 0000000000000006 x1 : 000000000001dd36 x0 : 0000000000000000\nCPU: \n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50408",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix use-after-free bug in brcmf_netdev_start_xmit()\n\n\u003e ret = brcmf_proto_tx_queue_data(drvr, ifp-\u003eifidx, skb);\n\nmay be schedule, and then complete before the line\n\n\u003e ndev-\u003estats.tx_bytes += skb-\u003elen;\n\n[   46.912801] ==================================================================\n[   46.920552] BUG: KASAN: use-after-free in brcmf_netdev_start_xmit+0x718/0x8c8 [brcmfmac]\n[   46.928673] Read of size 4 at addr ffffff803f5882e8 by task systemd-resolve/328\n[   46.935991]\n[   46.937514] CPU: 1 PID: 328 Comm: systemd-resolve Tainted: G           O      5.4.199-[REDACTED] #1\n[   46.947255] Hardware name: [REDACTED]\n[   46.954568] Call trace:\n[   46.957037]  dump_backtrace+0x0/0x2b8\n[   46.960719]  show_stack+0x24/0x30\n[   46.964052]  dump_stack+0x128/0x194\n[   46.967557]  print_address_description.isra.0+0x64/0x380\n[   46.972877]  __kasan_report+0x1d4/0x240\n[   46.976723]  kasan_report+0xc/0x18\n[   46.980138]  __asan_report_load4_noabort+0x18/0x20\n[   46.985027]  brcmf_netdev_start_xmit+0x718/0x8c8 [brcmfmac]\n[   46.990613]  dev_hard_start_xmit+0x1bc/0xda0\n[   46.994894]  sch_direct_xmit+0x198/0xd08\n[   46.998827]  __qdisc_run+0x37c/0x1dc0\n[   47.002500]  __dev_queue_xmit+0x1528/0x21f8\n[   47.006692]  dev_queue_xmit+0x24/0x30\n[   47.010366]  neigh_resolve_output+0x37c/0x678\n[   47.014734]  ip_finish_output2+0x598/0x2458\n[   47.018927]  __ip_finish_output+0x300/0x730\n[   47.023118]  ip_output+0x2e0/0x430\n[   47.026530]  ip_local_out+0x90/0x140\n[   47.030117]  igmpv3_sendpack+0x14c/0x228\n[   47.034049]  igmpv3_send_cr+0x384/0x6b8\n[   47.037895]  igmp_ifc_timer_expire+0x4c/0x118\n[   47.042262]  call_timer_fn+0x1cc/0xbe8\n[   47.046021]  __run_timers+0x4d8/0xb28\n[   47.049693]  run_timer_softirq+0x24/0x40\n[   47.053626]  __do_softirq+0x2c0/0x117c\n[   47.057387]  irq_exit+0x2dc/0x388\n[   47.060715]  __handle_domain_irq+0xb4/0x158\n[   47.064908]  gic_handle_irq+0x58/0xb0\n[   47.068581]  el0_irq_naked+0x50/0x5c\n[   47.072162]\n[   47.073665] Allocated by task 328:\n[   47.077083]  save_stack+0x24/0xb0\n[   47.080410]  __kasan_kmalloc.isra.0+0xc0/0xe0\n[   47.084776]  kasan_slab_alloc+0x14/0x20\n[   47.088622]  kmem_cache_alloc+0x15c/0x468\n[   47.092643]  __alloc_skb+0xa4/0x498\n[   47.096142]  igmpv3_newpack+0x158/0xd78\n[   47.099987]  add_grhead+0x210/0x288\n[   47.103485]  add_grec+0x6b0/0xb70\n[   47.106811]  igmpv3_send_cr+0x2e0/0x6b8\n[   47.110657]  igmp_ifc_timer_expire+0x4c/0x118\n[   47.115027]  call_timer_fn+0x1cc/0xbe8\n[   47.118785]  __run_timers+0x4d8/0xb28\n[   47.122457]  run_timer_softirq+0x24/0x40\n[   47.126389]  __do_softirq+0x2c0/0x117c\n[   47.130142]\n[   47.131643] Freed by task 180:\n[   47.134712]  save_stack+0x24/0xb0\n[   47.138041]  __kasan_slab_free+0x108/0x180\n[   47.142146]  kasan_slab_free+0x10/0x18\n[   47.145904]  slab_free_freelist_hook+0xa4/0x1b0\n[   47.150444]  kmem_cache_free+0x8c/0x528\n[   47.154292]  kfree_skbmem+0x94/0x108\n[   47.157880]  consume_skb+0x10c/0x5a8\n[   47.161466]  __dev_kfree_skb_any+0x88/0xa0\n[   47.165598]  brcmu_pkt_buf_free_skb+0x44/0x68 [brcmutil]\n[   47.171023]  brcmf_txfinalize+0xec/0x190 [brcmfmac]\n[   47.176016]  brcmf_proto_bcdc_txcomplete+0x1c0/0x210 [brcmfmac]\n[   47.182056]  brcmf_sdio_sendfromq+0x8dc/0x1e80 [brcmfmac]\n[   47.187568]  brcmf_sdio_dpc+0xb48/0x2108 [brcmfmac]\n[   47.192529]  brcmf_sdio_dataworker+0xc8/0x238 [brcmfmac]\n[   47.197859]  process_one_work+0x7fc/0x1a80\n[   47.201965]  worker_thread+0x31c/0xc40\n[   47.205726]  kthread+0x2d8/0x370\n[   47.208967]  ret_from_fork+0x10/0x18\n[   47.212546]\n[   47.214051] The buggy address belongs to the object at ffffff803f588280\n[   47.214051]  which belongs to the cache skbuff_head_cache of size 208\n[   47.227086] The buggy address is located 104 bytes inside of\n[   47.227086]  208-byte region [ffffff803f588280, ffffff803f588350)\n[   47.238814] The buggy address belongs to the page:\n[   47.243618] page:ffffffff00dd6200 refcount:1 mapcou\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50409",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: If sock is dead don't access sock's sk_wq in sk_stream_wait_memory\n\nFixes the below NULL pointer dereference:\n\n  [...]\n  [   14.471200] Call Trace:\n  [   14.471562]  \u003cTASK\u003e\n  [   14.471882]  lock_acquire+0x245/0x2e0\n  [   14.472416]  ? remove_wait_queue+0x12/0x50\n  [   14.473014]  ? _raw_spin_lock_irqsave+0x17/0x50\n  [   14.473681]  _raw_spin_lock_irqsave+0x3d/0x50\n  [   14.474318]  ? remove_wait_queue+0x12/0x50\n  [   14.474907]  remove_wait_queue+0x12/0x50\n  [   14.475480]  sk_stream_wait_memory+0x20d/0x340\n  [   14.476127]  ? do_wait_intr_irq+0x80/0x80\n  [   14.476704]  do_tcp_sendpages+0x287/0x600\n  [   14.477283]  tcp_bpf_push+0xab/0x260\n  [   14.477817]  tcp_bpf_sendmsg_redir+0x297/0x500\n  [   14.478461]  ? __local_bh_enable_ip+0x77/0xe0\n  [   14.479096]  tcp_bpf_send_verdict+0x105/0x470\n  [   14.479729]  tcp_bpf_sendmsg+0x318/0x4f0\n  [   14.480311]  sock_sendmsg+0x2d/0x40\n  [   14.480822]  ____sys_sendmsg+0x1b4/0x1c0\n  [   14.481390]  ? copy_msghdr_from_user+0x62/0x80\n  [   14.482048]  ___sys_sendmsg+0x78/0xb0\n  [   14.482580]  ? vmf_insert_pfn_prot+0x91/0x150\n  [   14.483215]  ? __do_fault+0x2a/0x1a0\n  [   14.483738]  ? do_fault+0x15e/0x5d0\n  [   14.484246]  ? __handle_mm_fault+0x56b/0x1040\n  [   14.484874]  ? lock_is_held_type+0xdf/0x130\n  [   14.485474]  ? find_held_lock+0x2d/0x90\n  [   14.486046]  ? __sys_sendmsg+0x41/0x70\n  [   14.486587]  __sys_sendmsg+0x41/0x70\n  [   14.487105]  ? intel_pmu_drain_pebs_core+0x350/0x350\n  [   14.487822]  do_syscall_64+0x34/0x80\n  [   14.488345]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  [...]\n\nThe test scenario has the following flow:\n\nthread1                               thread2\n-----------                           ---------------\n tcp_bpf_sendmsg\n  tcp_bpf_send_verdict\n   tcp_bpf_sendmsg_redir              sock_close\n    tcp_bpf_push_locked                 __sock_release\n     tcp_bpf_push                         //inet_release\n      do_tcp_sendpages                    sock-\u003eops-\u003erelease\n       sk_stream_wait_memory          \t   // tcp_close\n          sk_wait_event                      sk-\u003esk_prot-\u003eclose\n           release_sock(__sk);\n            ***\n                                                lock_sock(sk);\n                                                  __tcp_close\n                                                    sock_orphan(sk)\n                                                      sk-\u003esk_wq  = NULL\n                                                release_sock\n            ****\n           lock_sock(__sk);\n          remove_wait_queue(sk_sleep(sk), \u0026wait);\n             sk_sleep(sk)\n             //NULL pointer dereference\n             \u0026rcu_dereference_raw(sk-\u003esk_wq)-\u003ewait\n\nWhile waiting for memory in thread1, the socket is released with its wait\nqueue because thread2 has closed it. This caused by tcp_bpf_send_verdict\ndidn't increase the f_count of psock-\u003esk_redir-\u003esk_socket-\u003efile in thread1.\n\nWe should check if SOCK_DEAD flag is set on wakeup in sk_stream_wait_memory\nbefore accessing the wait queue.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50411",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Fix error code path in acpi_ds_call_control_method()\n\nA use-after-free in acpi_ps_parse_aml() after a failing invocaion of\nacpi_ds_call_control_method() is reported by KASAN [1] and code\ninspection reveals that next_walk_state pushed to the thread by\nacpi_ds_create_walk_state() is freed on errors, but it is not popped\nfrom the thread beforehand.  Thus acpi_ds_get_current_walk_state()\ncalled by acpi_ps_parse_aml() subsequently returns it as the new\nwalk state which is incorrect.\n\nTo address this, make acpi_ds_call_control_method() call\nacpi_ds_pop_walk_state() to pop next_walk_state from the thread before\nreturning an error.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50414",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: fcoe: Fix transport not deattached when fcoe_if_init() fails\n\nfcoe_init() calls fcoe_transport_attach(\u0026fcoe_sw_transport), but when\nfcoe_if_init() fails, \u0026fcoe_sw_transport is not detached and leaves freed\n\u0026fcoe_sw_transport on fcoe_transports list. This causes panic when\nreinserting module.\n\n BUG: unable to handle page fault for address: fffffbfff82e2213\n RIP: 0010:fcoe_transport_attach+0xe1/0x230 [libfcoe]\n Call Trace:\n  \u003cTASK\u003e\n  do_one_initcall+0xd0/0x4e0\n  load_module+0x5eee/0x7210\n  ...",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50419",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_sysfs: Fix attempting to call device_add multiple times\n\ndevice_add shall not be called multiple times as stated in its\ndocumentation:\n\n 'Do not call this routine or device_register() more than once for\n any device structure'\n\nSyzkaller reports a bug as follows [1]:\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:33!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\n[...]\nCall Trace:\n \u003cTASK\u003e\n __list_add include/linux/list.h:69 [inline]\n list_add_tail include/linux/list.h:102 [inline]\n kobj_kset_join lib/kobject.c:164 [inline]\n kobject_add_internal+0x18f/0x8f0 lib/kobject.c:214\n kobject_add_varg lib/kobject.c:358 [inline]\n kobject_add+0x150/0x1c0 lib/kobject.c:410\n device_add+0x368/0x1e90 drivers/base/core.c:3452\n hci_conn_add_sysfs+0x9b/0x1b0 net/bluetooth/hci_sysfs.c:53\n hci_le_cis_estabilished_evt+0x57c/0xae0 net/bluetooth/hci_event.c:6799\n hci_le_meta_evt+0x2b8/0x510 net/bluetooth/hci_event.c:7110\n hci_event_func net/bluetooth/hci_event.c:7440 [inline]\n hci_event_packet+0x63d/0xfd0 net/bluetooth/hci_event.c:7495\n hci_rx_work+0xae7/0x1230 net/bluetooth/hci_core.c:4007\n process_one_work+0x991/0x1610 kernel/workqueue.c:2289\n worker_thread+0x665/0x1080 kernel/workqueue.c:2436\n kthread+0x2e4/0x3a0 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n \u003c/TASK\u003e",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50422",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libsas: Fix use-after-free bug in smp_execute_task_sg()\n\nWhen executing SMP task failed, the smp_execute_task_sg() calls del_timer()\nto delete \"slow_task-\u003etimer\". However, if the timer handler\nsas_task_internal_timedout() is running, the del_timer() in\nsmp_execute_task_sg() will not stop it and a UAF will happen. The process\nis shown below:\n\n      (thread 1)               |        (thread 2)\nsmp_execute_task_sg()          | sas_task_internal_timedout()\n ...                           |\n del_timer()                   |\n ...                           |  ...\n sas_free_task(task)           |\n  kfree(task-\u003eslow_task) //FREE|\n                               |  task-\u003eslow_task-\u003e... //USE\n\nFix by calling del_timer_sync() in smp_execute_task_sg(), which makes sure\nthe timer handler have finished before the \"task-\u003eslow_task\" is\ndeallocated.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50423",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Fix use-after-free in acpi_ut_copy_ipackage_to_ipackage()\n\nThere is an use-after-free reported by KASAN:\n\n  BUG: KASAN: use-after-free in acpi_ut_remove_reference+0x3b/0x82\n  Read of size 1 at addr ffff888112afc460 by task modprobe/2111\n  CPU: 0 PID: 2111 Comm: modprobe Not tainted 6.1.0-rc7-dirty\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),\n  Call Trace:\n   \u003cTASK\u003e\n   kasan_report+0xae/0xe0\n   acpi_ut_remove_reference+0x3b/0x82\n   acpi_ut_copy_iobject_to_iobject+0x3be/0x3d5\n   acpi_ds_store_object_to_local+0x15d/0x3a0\n   acpi_ex_store+0x78d/0x7fd\n   acpi_ex_opcode_1A_1T_1R+0xbe4/0xf9b\n   acpi_ps_parse_aml+0x217/0x8d5\n   ...\n   \u003c/TASK\u003e\n\nThe root cause of the problem is that the acpi_operand_object\nis freed when acpi_ut_walk_package_tree() fails in\nacpi_ut_copy_ipackage_to_ipackage(), lead to repeated release in\nacpi_ut_copy_iobject_to_iobject(). The problem was introduced\nby \"8aa5e56eeb61\" commit, this commit is to fix memory leak in\nacpi_ut_copy_iobject_to_iobject(), repeatedly adding remove\noperation, lead to \"acpi_operand_object\" used after free.\n\nFix it by removing acpi_ut_remove_reference() in\nacpi_ut_copy_ipackage_to_ipackage(). acpi_ut_copy_ipackage_to_ipackage()\nis called to copy an internal package object into another internal\npackage object, when it fails, the memory of acpi_operand_object\nshould be freed by the caller.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50432",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkernfs: fix use-after-free in __kernfs_remove\n\nSyzkaller managed to trigger concurrent calls to\nkernfs_remove_by_name_ns() for the same file resulting in\na KASAN detected use-after-free. The race occurs when the root\nnode is freed during kernfs_drain().\n\nTo prevent this acquire an additional reference for the root\nof the tree that is removed before calling __kernfs_remove().\n\nFound by syzkaller with the following reproducer (slab_nomerge is\nrequired):\n\nsyz_mount_image$ext4(0x0, \u0026(0x7f0000000100)='./file0\\x00', 0x100000, 0x0, 0x0, 0x0, 0x0)\nr0 = openat(0xffffffffffffff9c, \u0026(0x7f0000000080)='/proc/self/exe\\x00', 0x0, 0x0)\nclose(r0)\npipe2(\u0026(0x7f0000000140)={0xffffffffffffffff, \u003cr1=\u003e0xffffffffffffffff}, 0x800)\nmount$9p_fd(0x0, \u0026(0x7f0000000040)='./file0\\x00', \u0026(0x7f00000000c0), 0x408, \u0026(0x7f0000000280)={'trans=fd,', {'rfdno', 0x3d, r0}, 0x2c, {'wfdno', 0x3d, r1}, 0x2c, {[{@cache_loose}, {@mmap}, {@loose}, {@loose}, {@mmap}], [{@mask={'mask', 0x3d, '^MAY_EXEC'}}, {@fsmagic={'fsmagic', 0x3d, 0x10001}}, {@dont_hash}]}})\n\nSample report:\n\n==================================================================\nBUG: KASAN: use-after-free in kernfs_type include/linux/kernfs.h:335 [inline]\nBUG: KASAN: use-after-free in kernfs_leftmost_descendant fs/kernfs/dir.c:1261 [inline]\nBUG: KASAN: use-after-free in __kernfs_remove.part.0+0x843/0x960 fs/kernfs/dir.c:1369\nRead of size 2 at addr ffff8880088807f0 by task syz-executor.2/857\n\nCPU: 0 PID: 857 Comm: syz-executor.2 Not tainted 6.0.0-rc3-00363-g7726d4c3e60b #5\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x6e/0x91 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:317 [inline]\n print_report.cold+0x5e/0x5e5 mm/kasan/report.c:433\n kasan_report+0xa3/0x130 mm/kasan/report.c:495\n kernfs_type include/linux/kernfs.h:335 [inline]\n kernfs_leftmost_descendant fs/kernfs/dir.c:1261 [inline]\n __kernfs_remove.part.0+0x843/0x960 fs/kernfs/dir.c:1369\n __kernfs_remove fs/kernfs/dir.c:1356 [inline]\n kernfs_remove_by_name_ns+0x108/0x190 fs/kernfs/dir.c:1589\n sysfs_slab_add+0x133/0x1e0 mm/slub.c:5943\n __kmem_cache_create+0x3e0/0x550 mm/slub.c:4899\n create_cache mm/slab_common.c:229 [inline]\n kmem_cache_create_usercopy+0x167/0x2a0 mm/slab_common.c:335\n p9_client_create+0xd4d/0x1190 net/9p/client.c:993\n v9fs_session_init+0x1e6/0x13c0 fs/9p/v9fs.c:408\n v9fs_mount+0xb9/0xbd0 fs/9p/vfs_super.c:126\n legacy_get_tree+0xf1/0x200 fs/fs_context.c:610\n vfs_get_tree+0x85/0x2e0 fs/super.c:1530\n do_new_mount fs/namespace.c:3040 [inline]\n path_mount+0x675/0x1d00 fs/namespace.c:3370\n do_mount fs/namespace.c:3383 [inline]\n __do_sys_mount fs/namespace.c:3591 [inline]\n __se_sys_mount fs/namespace.c:3568 [inline]\n __x64_sys_mount+0x282/0x300 fs/namespace.c:3568\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x38/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7f725f983aed\nCode: 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f725f0f7028 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5\nRAX: ffffffffffffffda RBX: 00007f725faa3f80 RCX: 00007f725f983aed\nRDX: 00000000200000c0 RSI: 0000000020000040 RDI: 0000000000000000\nRBP: 00007f725f9f419c R08: 0000000020000280 R09: 0000000000000000\nR10: 0000000000000408 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000006 R14: 00007f725faa3f80 R15: 00007f725f0d7000\n \u003c/TASK\u003e\n\nAllocated by task 855:\n kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38\n kasan_set_track mm/kasan/common.c:45 [inline]\n set_alloc_info mm/kasan/common.c:437 [inline]\n __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:470\n kasan_slab_alloc include/linux/kasan.h:224 [inline]\n slab_post_alloc_hook mm/slab.h:7\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50434",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: fix possible memleak when register 'hctx' failed\n\nThere's issue as follows when do fault injection test:\nunreferenced object 0xffff888132a9f400 (size 512):\n  comm \"insmod\", pid 308021, jiffies 4324277909 (age 509.733s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 08 f4 a9 32 81 88 ff ff  ...........2....\n    08 f4 a9 32 81 88 ff ff 00 00 00 00 00 00 00 00  ...2............\n  backtrace:\n    [\u003c00000000e8952bb4\u003e] kmalloc_node_trace+0x22/0xa0\n    [\u003c00000000f9980e0f\u003e] blk_mq_alloc_and_init_hctx+0x3f1/0x7e0\n    [\u003c000000002e719efa\u003e] blk_mq_realloc_hw_ctxs+0x1e6/0x230\n    [\u003c000000004f1fda40\u003e] blk_mq_init_allocated_queue+0x27e/0x910\n    [\u003c00000000287123ec\u003e] __blk_mq_alloc_disk+0x67/0xf0\n    [\u003c00000000a2a34657\u003e] 0xffffffffa2ad310f\n    [\u003c00000000b173f718\u003e] 0xffffffffa2af824a\n    [\u003c0000000095a1dabb\u003e] do_one_initcall+0x87/0x2a0\n    [\u003c00000000f32fdf93\u003e] do_init_module+0xdf/0x320\n    [\u003c00000000cbe8541e\u003e] load_module+0x3006/0x3390\n    [\u003c0000000069ed1bdb\u003e] __do_sys_finit_module+0x113/0x1b0\n    [\u003c00000000a1a29ae8\u003e] do_syscall_64+0x35/0x80\n    [\u003c000000009cd878b0\u003e] entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nFault injection context as follows:\n kobject_add\n blk_mq_register_hctx\n blk_mq_sysfs_register\n blk_register_queue\n device_add_disk\n null_add_dev.part.0 [null_blk]\n\nAs 'blk_mq_register_hctx' may already add some objects when failed halfway,\nbut there isn't do fallback, caller don't know which objects add failed.\nTo solve above issue just do fallback when add objects failed halfway in\n'blk_mq_register_hctx'.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50435",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid crash when inline data creation follows DIO write\n\nWhen inode is created and written to using direct IO, there is nothing\nto clear the EXT4_STATE_MAY_INLINE_DATA flag. Thus when inode gets\ntruncated later to say 1 byte and written using normal write, we will\ntry to store the data as inline data. This confuses the code later\nbecause the inode now has both normal block and inline data allocated\nand the confusion manifests for example as:\n\nkernel BUG at fs/ext4/inode.c:2721!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\nCPU: 0 PID: 359 Comm: repro Not tainted 5.19.0-rc8-00001-g31ba1e3b8305-dirty #15\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-1.fc36 04/01/2014\nRIP: 0010:ext4_writepages+0x363d/0x3660\nRSP: 0018:ffffc90000ccf260 EFLAGS: 00010293\nRAX: ffffffff81e1abcd RBX: 0000008000000000 RCX: ffff88810842a180\nRDX: 0000000000000000 RSI: 0000008000000000 RDI: 0000000000000000\nRBP: ffffc90000ccf650 R08: ffffffff81e17d58 R09: ffffed10222c680b\nR10: dfffe910222c680c R11: 1ffff110222c680a R12: ffff888111634128\nR13: ffffc90000ccf880 R14: 0000008410000000 R15: 0000000000000001\nFS:  00007f72635d2640(0000) GS:ffff88811b000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000565243379180 CR3: 000000010aa74000 CR4: 0000000000150eb0\nCall Trace:\n \u003cTASK\u003e\n do_writepages+0x397/0x640\n filemap_fdatawrite_wbc+0x151/0x1b0\n file_write_and_wait_range+0x1c9/0x2b0\n ext4_sync_file+0x19e/0xa00\n vfs_fsync_range+0x17b/0x190\n ext4_buffered_write_iter+0x488/0x530\n ext4_file_write_iter+0x449/0x1b90\n vfs_write+0xbcd/0xf40\n ksys_write+0x198/0x2c0\n __x64_sys_write+0x7b/0x90\n do_syscall_64+0x3d/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n \u003c/TASK\u003e\n\nFix the problem by clearing EXT4_STATE_MAY_INLINE_DATA when we are doing\ndirect IO write to a file.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50443",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/rockchip: lvds: fix PM usage counter unbalance in poweron\n\npm_runtime_get_sync will increment pm usage counter even it failed.\nForgetting to putting operation will result in reference leak here.\nWe fix it by replacing it with the newest pm_runtime_resume_and_get\nto keep usage counter balanced.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50456",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix resolving backrefs for inline extent followed by prealloc\n\nIf a file consists of an inline extent followed by a regular or prealloc\nextent, then a legitimate attempt to resolve a logical address in the\nnon-inline region will result in add_all_parents reading the invalid\noffset field of the inline extent. If the inline extent item is placed\nin the leaf eb s.t. it is the first item, attempting to access the\noffset field will not only be meaningless, it will go past the end of\nthe eb and cause this panic:\n\n  [17.626048] BTRFS warning (device dm-2): bad eb member end: ptr 0x3fd4 start 30834688 member offset 16377 size 8\n  [17.631693] general protection fault, probably for non-canonical address 0x5088000000000: 0000 [#1] SMP PTI\n  [17.635041] CPU: 2 PID: 1267 Comm: btrfs Not tainted 5.12.0-07246-g75175d5adc74-dirty #199\n  [17.637969] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\n  [17.641995] RIP: 0010:btrfs_get_64+0xe7/0x110\n  [17.649890] RSP: 0018:ffffc90001f73a08 EFLAGS: 00010202\n  [17.651652] RAX: 0000000000000001 RBX: ffff88810c42d000 RCX: 0000000000000000\n  [17.653921] RDX: 0005088000000000 RSI: ffffc90001f73a0f RDI: 0000000000000001\n  [17.656174] RBP: 0000000000000ff9 R08: 0000000000000007 R09: c0000000fffeffff\n  [17.658441] R10: ffffc90001f73790 R11: ffffc90001f73788 R12: ffff888106afe918\n  [17.661070] R13: 0000000000003fd4 R14: 0000000000003f6f R15: cdcdcdcdcdcdcdcd\n  [17.663617] FS:  00007f64e7627d80(0000) GS:ffff888237c80000(0000) knlGS:0000000000000000\n  [17.666525] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [17.668664] CR2: 000055d4a39152e8 CR3: 000000010c596002 CR4: 0000000000770ee0\n  [17.671253] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  [17.673634] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  [17.676034] PKRU: 55555554\n  [17.677004] Call Trace:\n  [17.677877]  add_all_parents+0x276/0x480\n  [17.679325]  find_parent_nodes+0xfae/0x1590\n  [17.680771]  btrfs_find_all_leafs+0x5e/0xa0\n  [17.682217]  iterate_extent_inodes+0xce/0x260\n  [17.683809]  ? btrfs_inode_flags_to_xflags+0x50/0x50\n  [17.685597]  ? iterate_inodes_from_logical+0xa1/0xd0\n  [17.687404]  iterate_inodes_from_logical+0xa1/0xd0\n  [17.689121]  ? btrfs_inode_flags_to_xflags+0x50/0x50\n  [17.691010]  btrfs_ioctl_logical_to_ino+0x131/0x190\n  [17.692946]  btrfs_ioctl+0x104a/0x2f60\n  [17.694384]  ? selinux_file_ioctl+0x182/0x220\n  [17.695995]  ? __x64_sys_ioctl+0x84/0xc0\n  [17.697394]  __x64_sys_ioctl+0x84/0xc0\n  [17.698697]  do_syscall_64+0x33/0x40\n  [17.700017]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n  [17.701753] RIP: 0033:0x7f64e72761b7\n  [17.709355] RSP: 002b:00007ffefb067f58 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  [17.712088] RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f64e72761b7\n  [17.714667] RDX: 00007ffefb067fb0 RSI: 00000000c0389424 RDI: 0000000000000003\n  [17.717386] RBP: 00007ffefb06d188 R08: 000055d4a390d2b0 R09: 00007f64e7340a60\n  [17.719938] R10: 0000000000000231 R11: 0000000000000246 R12: 0000000000000001\n  [17.722383] R13: 0000000000000000 R14: 00000000c0389424 R15: 000055d4a38fd2a0\n  [17.724839] Modules linked in:\n\nFix the bug by detecting the inline extent item in add_all_parents and\nskipping to the next extent item.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50459",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi: iscsi_tcp: Fix null-ptr-deref while calling getpeername()\n\nFix a NULL pointer crash that occurs when we are freeing the socket at the\nsame time we access it via sysfs.\n\nThe problem is that:\n\n 1. iscsi_sw_tcp_conn_get_param() and iscsi_sw_tcp_host_get_param() take\n    the frwd_lock and do sock_hold() then drop the frwd_lock. sock_hold()\n    does a get on the \"struct sock\".\n\n 2. iscsi_sw_tcp_release_conn() does sockfd_put() which does the last put\n    on the \"struct socket\" and that does __sock_release() which sets the\n    sock-\u003eops to NULL.\n\n 3. iscsi_sw_tcp_conn_get_param() and iscsi_sw_tcp_host_get_param() then\n    call kernel_getpeername() which accesses the NULL sock-\u003eops.\n\nAbove we do a get on the \"struct sock\", but we needed a get on the \"struct\nsocket\". Originally, we just held the frwd_lock the entire time but in\ncommit bcf3a2953d36 (\"scsi: iscsi: iscsi_tcp: Avoid holding spinlock while\ncalling getpeername()\") we switched to refcount based because the network\nlayer changed and started taking a mutex in that path, so we could no\nlonger hold the frwd_lock.\n\nInstead of trying to maintain multiple refcounts, this just has us use a\nmutex for accessing the socket in the interface code paths.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50460",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix xid leak in cifs_flock()\n\nIf not flock, before return -ENOLCK, should free the xid,\notherwise, the xid will be leaked.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50470",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxhci: Remove device endpoints from bandwidth list when freeing the device\n\nEndpoints are normally deleted from the bandwidth list when they are\ndropped, before the virt device is freed.\n\nIf xHC host is dying or being removed then the endpoints aren't dropped\ncleanly due to functions returning early to avoid interacting with a\nnon-accessible host controller.\n\nSo check and delete endpoints that are still on the bandwidth list when\nfreeing the virt device.\n\nSolves a list_del corruption kernel crash when unbinding xhci-pci,\ncaused by xhci_mem_cleanup() when it later tried to delete already freed\nendpoints from the bandwidth list.\n\nThis only affects hosts that use software bandwidth checking, which\ncurrenty is only the xHC in intel Panther Point PCH (Ivy Bridge)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50481",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxl: fix possible null-ptr-deref in cxl_guest_init_afu|adapter()\n\nIf device_register() fails in cxl_register_afu|adapter(), the device\nis not added, device_unregister() can not be called in the error path,\notherwise it will cause a null-ptr-deref because of removing not added\ndevice.\n\nAs comment of device_register() says, it should use put_device() to give\nup the reference in the error path. So split device_unregister() into\ndevice_del() and put_device(), then goes to put dev when register fails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50485",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: add EXT4_IGET_BAD flag to prevent unexpected bad inode\n\nThere are many places that will get unhappy (and crash) when ext4_iget()\nreturns a bad inode. However, if iget the boot loader inode, allows a bad\ninode to be returned, because the inode may not be initialized. This\nmechanism can be used to bypass some checks and cause panic. To solve this\nproblem, we add a special iget flag EXT4_IGET_BAD. Only with this flag\nwe'd be returning bad inode from ext4_iget(), otherwise we always return\nthe error code if the inode is bad inode.(suggested by Jan Kara)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50493",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix crash when I/O abort times out\n\nWhile performing CPU hotplug, a crash with the following stack was seen:\n\nCall Trace:\n     qla24xx_process_response_queue+0x42a/0x970 [qla2xxx]\n     qla2x00_start_nvme_mq+0x3a2/0x4b0 [qla2xxx]\n     qla_nvme_post_cmd+0x166/0x240 [qla2xxx]\n     nvme_fc_start_fcp_op.part.0+0x119/0x2e0 [nvme_fc]\n     blk_mq_dispatch_rq_list+0x17b/0x610\n     __blk_mq_sched_dispatch_requests+0xb0/0x140\n     blk_mq_sched_dispatch_requests+0x30/0x60\n     __blk_mq_run_hw_queue+0x35/0x90\n     __blk_mq_delay_run_hw_queue+0x161/0x180\n     blk_execute_rq+0xbe/0x160\n     __nvme_submit_sync_cmd+0x16f/0x220 [nvme_core]\n     nvmf_connect_admin_queue+0x11a/0x170 [nvme_fabrics]\n     nvme_fc_create_association.cold+0x50/0x3dc [nvme_fc]\n     nvme_fc_connect_ctrl_work+0x19/0x30 [nvme_fc]\n     process_one_work+0x1e8/0x3c0\n\nOn abort timeout, completion was called without checking if the I/O was\nalready completed.\n\nVerify that I/O and abort request are indeed outstanding before attempting\ncompletion.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50494",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nthermal: intel_powerclamp: Use get_cpu() instead of smp_processor_id() to avoid crash\n\nWhen CPU 0 is offline and intel_powerclamp is used to inject\nidle, it generates kernel BUG:\n\nBUG: using smp_processor_id() in preemptible [00000000] code: bash/15687\ncaller is debug_smp_processor_id+0x17/0x20\nCPU: 4 PID: 15687 Comm: bash Not tainted 5.19.0-rc7+ #57\nCall Trace:\n\u003cTASK\u003e\ndump_stack_lvl+0x49/0x63\ndump_stack+0x10/0x16\ncheck_preemption_disabled+0xdd/0xe0\ndebug_smp_processor_id+0x17/0x20\npowerclamp_set_cur_state+0x7f/0xf9 [intel_powerclamp]\n...\n...\n\nHere CPU 0 is the control CPU by default and changed to the current CPU,\nif CPU 0 offlined. This check has to be performed under cpus_read_lock(),\nhence the above warning.\n\nUse get_cpu() instead of smp_processor_id() to avoid this BUG.\n\n[ rjw: Subject edits ]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50496",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: Fix UAF in destroy()\n\nDm_cache also has the same UAF problem when dm_resume()\nand dm_destroy() are concurrent.\n\nTherefore, cancelling timer again in destroy().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50501",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: coda: Add check for dcoda_iram_alloc\n\nAs the coda_iram_alloc may return NULL pointer,\nit should be better to check the return value\nin order to avoid NULL poineter dereference,\nsame as the others.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50504",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/rtas: avoid scheduling in rtas_os_term()\n\nIt's unsafe to use rtas_busy_delay() to handle a busy status from\nthe ibm,os-term RTAS function in rtas_os_term():\n\nKernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\nBUG: sleeping function called from invalid context at arch/powerpc/kernel/rtas.c:618\nin_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 1, name: swapper/0\npreempt_count: 2, expected: 0\nCPU: 7 PID: 1 Comm: swapper/0 Tainted: G      D            6.0.0-rc5-02182-gf8553a572277-dirty #9\nCall Trace:\n[c000000007b8f000] [c000000001337110] dump_stack_lvl+0xb4/0x110 (unreliable)\n[c000000007b8f040] [c0000000002440e4] __might_resched+0x394/0x3c0\n[c000000007b8f0e0] [c00000000004f680] rtas_busy_delay+0x120/0x1b0\n[c000000007b8f100] [c000000000052d04] rtas_os_term+0xb8/0xf4\n[c000000007b8f180] [c0000000001150fc] pseries_panic+0x50/0x68\n[c000000007b8f1f0] [c000000000036354] ppc_panic_platform_handler+0x34/0x50\n[c000000007b8f210] [c0000000002303c4] notifier_call_chain+0xd4/0x1c0\n[c000000007b8f2b0] [c0000000002306cc] atomic_notifier_call_chain+0xac/0x1c0\n[c000000007b8f2f0] [c0000000001d62b8] panic+0x228/0x4d0\n[c000000007b8f390] [c0000000001e573c] do_exit+0x140c/0x1420\n[c000000007b8f480] [c0000000001e586c] make_task_dead+0xdc/0x200\n\nUse rtas_busy_delay_time() instead, which signals without side effects\nwhether to attempt the ibm,os-term RTAS call again.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50505",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/amd: Fix pci device refcount leak in ppr_notifier()\n\nAs comment of pci_get_domain_bus_and_slot() says, it returns\na pci device with refcount increment, when finish using it,\nthe caller must decrement the reference count by calling\npci_dev_put(). So call it before returning from ppr_notifier()\nto avoid refcount leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50509",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: coda: Add check for kmalloc\n\nAs the kmalloc may return NULL pointer,\nit should be better to check the return value\nin order to avoid NULL poineter dereference,\nsame as the others.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50516",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: dlm: fix invalid derefence of sb_lvbptr\n\nI experience issues when putting a lkbsb on the stack and have sb_lvbptr\nfield to a dangled pointer while not using DLM_LKF_VALBLK. It will crash\nwith the following kernel message, the dangled pointer is here\n0xdeadbeef as example:\n\n[  102.749317] BUG: unable to handle page fault for address: 00000000deadbeef\n[  102.749320] #PF: supervisor read access in kernel mode\n[  102.749323] #PF: error_code(0x0000) - not-present page\n[  102.749325] PGD 0 P4D 0\n[  102.749332] Oops: 0000 [#1] PREEMPT SMP PTI\n[  102.749336] CPU: 0 PID: 1567 Comm: lock_torture_wr Tainted: G        W         5.19.0-rc3+ #1565\n[  102.749343] Hardware name: Red Hat KVM/RHEL-AV, BIOS 1.16.0-2.module+el8.7.0+15506+033991b0 04/01/2014\n[  102.749344] RIP: 0010:memcpy_erms+0x6/0x10\n[  102.749353] Code: cc cc cc cc eb 1e 0f 1f 00 48 89 f8 48 89 d1 48 c1 e9 03 83 e2 07 f3 48 a5 89 d1 f3 a4 c3 66 0f 1f 44 00 00 48 89 f8 48 89 d1 \u003cf3\u003e a4 c3 0f 1f 80 00 00 00 00 48 89 f8 48 83 fa 20 72 7e 40 38 fe\n[  102.749355] RSP: 0018:ffff97a58145fd08 EFLAGS: 00010202\n[  102.749358] RAX: ffff901778b77070 RBX: 0000000000000000 RCX: 0000000000000040\n[  102.749360] RDX: 0000000000000040 RSI: 00000000deadbeef RDI: ffff901778b77070\n[  102.749362] RBP: ffff97a58145fd10 R08: ffff901760b67a70 R09: 0000000000000001\n[  102.749364] R10: ffff9017008e2cb8 R11: 0000000000000001 R12: ffff901760b67a70\n[  102.749366] R13: ffff901760b78f00 R14: 0000000000000003 R15: 0000000000000001\n[  102.749368] FS:  0000000000000000(0000) GS:ffff901876e00000(0000) knlGS:0000000000000000\n[  102.749372] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  102.749374] CR2: 00000000deadbeef CR3: 000000017c49a004 CR4: 0000000000770ef0\n[  102.749376] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  102.749378] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  102.749379] PKRU: 55555554\n[  102.749381] Call Trace:\n[  102.749382]  \u003cTASK\u003e\n[  102.749383]  ? send_args+0xb2/0xd0\n[  102.749389]  send_common+0xb7/0xd0\n[  102.749395]  _unlock_lock+0x2c/0x90\n[  102.749400]  unlock_lock.isra.56+0x62/0xa0\n[  102.749405]  dlm_unlock+0x21e/0x330\n[  102.749411]  ? lock_torture_stats+0x80/0x80 [dlm_locktorture]\n[  102.749416]  torture_unlock+0x5a/0x90 [dlm_locktorture]\n[  102.749419]  ? preempt_count_sub+0xba/0x100\n[  102.749427]  lock_torture_writer+0xbd/0x150 [dlm_locktorture]\n[  102.786186]  kthread+0x10a/0x130\n[  102.786581]  ? kthread_complete_and_exit+0x20/0x20\n[  102.787156]  ret_from_fork+0x22/0x30\n[  102.787588]  \u003c/TASK\u003e\n[  102.787855] Modules linked in: dlm_locktorture torture rpcsec_gss_krb5 intel_rapl_msr intel_rapl_common kvm_intel iTCO_wdt iTCO_vendor_support kvm vmw_vsock_virtio_transport qxl irqbypass vmw_vsock_virtio_transport_common drm_ttm_helper crc32_pclmul joydev crc32c_intel ttm vsock virtio_scsi virtio_balloon snd_pcm drm_kms_helper virtio_console snd_timer snd drm soundcore syscopyarea i2c_i801 sysfillrect sysimgblt i2c_smbus pcspkr fb_sys_fops lpc_ich serio_raw\n[  102.792536] CR2: 00000000deadbeef\n[  102.792930] ---[ end trace 0000000000000000 ]---\n\nThis patch fixes the issue by checking also on DLM_LKF_VALBLK on exflags\nis set when copying the lvbptr array instead of if it's just null which\nfixes for me the issue.\n\nI think this patch can fix other dlm users as well, depending how they\nhandle the init, freeing memory handling of sb_lvbptr and don't set\nDLM_LKF_VALBLK for some dlm_lock() calls. It might a there could be a\nhidden issue all the time. However with checking on DLM_LKF_VALBLK the\nuser always need to provide a sb_lvbptr non-null value. There might be\nmore intelligent handling between per ls lvblen, DLM_LKF_VALBLK and\nnon-null to report the user the way how DLM API is used is wrong but can\nbe added for later, this will only fix the current behaviour.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50532",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpt3sas: Fix possible resource leaks in mpt3sas_transport_port_add()\n\nIn mpt3sas_transport_port_add(), if sas_rphy_add() returns error,\nsas_rphy_free() needs be called to free the resource allocated in\nsas_end_device_alloc(). Otherwise a kernel crash will happen:\n\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000108\nCPU: 45 PID: 37020 Comm: bash Kdump: loaded Tainted: G        W          6.1.0-rc1+ #189\npstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : device_del+0x54/0x3d0\nlr : device_del+0x37c/0x3d0\nCall trace:\n device_del+0x54/0x3d0\n attribute_container_class_device_del+0x28/0x38\n transport_remove_classdev+0x6c/0x80\n attribute_container_device_trigger+0x108/0x110\n transport_remove_device+0x28/0x38\n sas_rphy_remove+0x50/0x78 [scsi_transport_sas]\n sas_port_delete+0x30/0x148 [scsi_transport_sas]\n do_sas_phy_delete+0x78/0x80 [scsi_transport_sas]\n device_for_each_child+0x68/0xb0\n sas_remove_children+0x30/0x50 [scsi_transport_sas]\n sas_rphy_remove+0x38/0x78 [scsi_transport_sas]\n sas_port_delete+0x30/0x148 [scsi_transport_sas]\n do_sas_phy_delete+0x78/0x80 [scsi_transport_sas]\n device_for_each_child+0x68/0xb0\n sas_remove_children+0x30/0x50 [scsi_transport_sas]\n sas_remove_host+0x20/0x38 [scsi_transport_sas]\n scsih_remove+0xd8/0x420 [mpt3sas]\n\nBecause transport_add_device() is not called when sas_rphy_add() fails, the\ndevice is not added. When sas_rphy_remove() is subsequently called to\nremove the device in the remove() path, a NULL pointer dereference happens.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50534",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm thin: Use last transaction's pmd-\u003eroot when commit failed\n\nRecently we found a softlock up problem in dm thin pool btree lookup\ncode due to corrupted metadata:\n\n Kernel panic - not syncing: softlockup: hung tasks\n CPU: 7 PID: 2669225 Comm: kworker/u16:3\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)\n Workqueue: dm-thin do_worker [dm_thin_pool]\n Call Trace:\n   \u003cIRQ\u003e\n   dump_stack+0x9c/0xd3\n   panic+0x35d/0x6b9\n   watchdog_timer_fn.cold+0x16/0x25\n   __run_hrtimer+0xa2/0x2d0\n   \u003c/IRQ\u003e\n   RIP: 0010:__relink_lru+0x102/0x220 [dm_bufio]\n   __bufio_new+0x11f/0x4f0 [dm_bufio]\n   new_read+0xa3/0x1e0 [dm_bufio]\n   dm_bm_read_lock+0x33/0xd0 [dm_persistent_data]\n   ro_step+0x63/0x100 [dm_persistent_data]\n   btree_lookup_raw.constprop.0+0x44/0x220 [dm_persistent_data]\n   dm_btree_lookup+0x16f/0x210 [dm_persistent_data]\n   dm_thin_find_block+0x12c/0x210 [dm_thin_pool]\n   __process_bio_read_only+0xc5/0x400 [dm_thin_pool]\n   process_thin_deferred_bios+0x1a4/0x4a0 [dm_thin_pool]\n   process_one_work+0x3c5/0x730\n\nFollowing process may generate a broken btree mixed with fresh and\nstale btree nodes, which could get dm thin trapped in an infinite loop\nwhile looking up data block:\n Transaction 1: pmd-\u003eroot = A, A-\u003eB-\u003eC   // One path in btree\n                pmd-\u003eroot = X, X-\u003eY-\u003eZ   // Copy-up\n Transaction 2: X,Z is updated on disk, Y write failed.\n                // Commit failed, dm thin becomes read-only.\n                process_bio_read_only\n\t\t dm_thin_find_block\n\t\t  __find_block\n\t\t   dm_btree_lookup(pmd-\u003eroot)\nThe pmd-\u003eroot points to a broken btree, Y may contain stale node\npointing to any block, for example X, which gets dm thin trapped into\na dead loop while looking up Z.\n\nFix this by setting pmd-\u003eroot in __open_metadata(), so that dm thin\nwill use the last transaction's pmd-\u003eroot if commit failed.\n\nFetch a reproducer in [Link].\n\nLinke: https://bugzilla.kernel.org/show_bug.cgi?id=216790",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50537",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: raspberrypi: fix possible memory leak in rpi_firmware_probe()\n\nIn rpi_firmware_probe(), if mbox_request_channel() fails, the 'fw' will\nnot be freed through rpi_firmware_delete(), fix this leak by calling\nkfree() in the error path.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50542",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: si470x: Fix use-after-free in si470x_int_in_callback()\n\nsyzbot reported use-after-free in si470x_int_in_callback() [1].  This\nindicates that urb-\u003econtext, which contains struct si470x_device\nobject, is freed when si470x_int_in_callback() is called.\n\nThe cause of this issue is that si470x_int_in_callback() is called for\nfreed urb.\n\nsi470x_usb_driver_probe() calls si470x_start_usb(), which then calls\nusb_submit_urb() and si470x_start().  If si470x_start_usb() fails,\nsi470x_usb_driver_probe() doesn't kill urb, but it just frees struct\nsi470x_device object, as depicted below:\n\nsi470x_usb_driver_probe()\n  ...\n  si470x_start_usb()\n    ...\n    usb_submit_urb()\n    retval = si470x_start()\n    return retval\n  if (retval \u003c 0)\n    free struct si470x_device object, but don't kill urb\n\nThis patch fixes this issue by killing urb when si470x_start_usb()\nfails and urb is submitted.  If si470x_start_usb() fails and urb is\nnot submitted, i.e. submitting usb fails, it just frees struct\nsi470x_device object.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50544",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: host: xhci: Fix potential memory leak in xhci_alloc_stream_info()\n\nxhci_alloc_stream_info() allocates stream context array for stream_info\n-\u003estream_ctx_array with xhci_alloc_stream_ctx(). When some error occurs,\nstream_info-\u003estream_ctx_array is not released, which will lead to a\nmemory leak.\n\nWe can fix it by releasing the stream_info-\u003estream_ctx_array with\nxhci_free_stream_ctx() on the error path to avoid the potential memory\nleak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50545",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nr6040: Fix kmemleak in probe and remove\n\nThere is a memory leaks reported by kmemleak:\n\n  unreferenced object 0xffff888116111000 (size 2048):\n    comm \"modprobe\", pid 817, jiffies 4294759745 (age 76.502s)\n    hex dump (first 32 bytes):\n      00 c4 0a 04 81 88 ff ff 08 10 11 16 81 88 ff ff  ................\n      08 10 11 16 81 88 ff ff 00 00 00 00 00 00 00 00  ................\n    backtrace:\n      [\u003cffffffff815bcd82\u003e] kmalloc_trace+0x22/0x60\n      [\u003cffffffff827e20ee\u003e] phy_device_create+0x4e/0x90\n      [\u003cffffffff827e6072\u003e] get_phy_device+0xd2/0x220\n      [\u003cffffffff827e7844\u003e] mdiobus_scan+0xa4/0x2e0\n      [\u003cffffffff827e8be2\u003e] __mdiobus_register+0x482/0x8b0\n      [\u003cffffffffa01f5d24\u003e] r6040_init_one+0x714/0xd2c [r6040]\n      ...\n\nThe problem occurs in probe process as follows:\n  r6040_init_one:\n    mdiobus_register\n      mdiobus_scan    \u003c- alloc and register phy_device,\n                         the reference count of phy_device is 3\n    r6040_mii_probe\n      phy_connect     \u003c- connect to the first phy_device,\n                         so the reference count of the first\n                         phy_device is 4, others are 3\n    register_netdev   \u003c- fault inject succeeded, goto error handling path\n\n    // error handling path\n    err_out_mdio_unregister:\n      mdiobus_unregister(lp-\u003emii_bus);\n    err_out_mdio:\n      mdiobus_free(lp-\u003emii_bus);    \u003c- the reference count of the first\n                                       phy_device is 1, it is not released\n                                       and other phy_devices are released\n  // similarly, the remove process also has the same problem\n\nThe root cause is traced to the phy_device is not disconnected when\nremoves one r6040 device in r6040_remove_one() or on error handling path\nafter r6040_mii probed successfully. In r6040_mii_probe(), a net ethernet\ndevice is connected to the first PHY device of mii_bus, in order to\nnotify the connected driver when the link status changes, which is the\ndefault behavior of the PHY infrastructure to handle everything.\nTherefore the phy_device should be disconnected when removes one r6040\ndevice or on error handling path.\n\nFix it by adding phy_disconnect() when removes one r6040 device or on\nerror handling path after r6040_mii probed successfully.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50549",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm thin: Fix ABBA deadlock between shrink_slab and dm_pool_abort_metadata\n\nFollowing concurrent processes:\n\n          P1(drop cache)                P2(kworker)\ndrop_caches_sysctl_handler\n drop_slab\n  shrink_slab\n   down_read(\u0026shrinker_rwsem)  - LOCK A\n   do_shrink_slab\n    super_cache_scan\n     prune_icache_sb\n      dispose_list\n       evict\n        ext4_evict_inode\n\t ext4_clear_inode\n\t  ext4_discard_preallocations\n\t   ext4_mb_load_buddy_gfp\n\t    ext4_mb_init_cache\n\t     ext4_read_block_bitmap_nowait\n\t      ext4_read_bh_nowait\n\t       submit_bh\n\t        dm_submit_bio\n\t\t                 do_worker\n\t\t\t\t  process_deferred_bios\n\t\t\t\t   commit\n\t\t\t\t    metadata_operation_failed\n\t\t\t\t     dm_pool_abort_metadata\n\t\t\t\t      down_write(\u0026pmd-\u003eroot_lock) - LOCK B\n\t\t                      __destroy_persistent_data_objects\n\t\t\t\t       dm_block_manager_destroy\n\t\t\t\t        dm_bufio_client_destroy\n\t\t\t\t         unregister_shrinker\n\t\t\t\t\t  down_write(\u0026shrinker_rwsem)\n\t\t thin_map                            |\n\t\t  dm_thin_find_block                 v\n\t\t   down_read(\u0026pmd-\u003eroot_lock) --\u003e ABBA deadlock\n\n, which triggers hung task:\n\n[   76.974820] INFO: task kworker/u4:3:63 blocked for more than 15 seconds.\n[   76.976019]       Not tainted 6.1.0-rc4-00011-g8f17dd350364-dirty #910\n[   76.978521] task:kworker/u4:3    state:D stack:0     pid:63    ppid:2\n[   76.978534] Workqueue: dm-thin do_worker\n[   76.978552] Call Trace:\n[   76.978564]  __schedule+0x6ba/0x10f0\n[   76.978582]  schedule+0x9d/0x1e0\n[   76.978588]  rwsem_down_write_slowpath+0x587/0xdf0\n[   76.978600]  down_write+0xec/0x110\n[   76.978607]  unregister_shrinker+0x2c/0xf0\n[   76.978616]  dm_bufio_client_destroy+0x116/0x3d0\n[   76.978625]  dm_block_manager_destroy+0x19/0x40\n[   76.978629]  __destroy_persistent_data_objects+0x5e/0x70\n[   76.978636]  dm_pool_abort_metadata+0x8e/0x100\n[   76.978643]  metadata_operation_failed+0x86/0x110\n[   76.978649]  commit+0x6a/0x230\n[   76.978655]  do_worker+0xc6e/0xd90\n[   76.978702]  process_one_work+0x269/0x630\n[   76.978714]  worker_thread+0x266/0x630\n[   76.978730]  kthread+0x151/0x1b0\n[   76.978772] INFO: task test.sh:2646 blocked for more than 15 seconds.\n[   76.979756]       Not tainted 6.1.0-rc4-00011-g8f17dd350364-dirty #910\n[   76.982111] task:test.sh         state:D stack:0     pid:2646  ppid:2459\n[   76.982128] Call Trace:\n[   76.982139]  __schedule+0x6ba/0x10f0\n[   76.982155]  schedule+0x9d/0x1e0\n[   76.982159]  rwsem_down_read_slowpath+0x4f4/0x910\n[   76.982173]  down_read+0x84/0x170\n[   76.982177]  dm_thin_find_block+0x4c/0xd0\n[   76.982183]  thin_map+0x201/0x3d0\n[   76.982188]  __map_bio+0x5b/0x350\n[   76.982195]  dm_submit_bio+0x2b6/0x930\n[   76.982202]  __submit_bio+0x123/0x2d0\n[   76.982209]  submit_bio_noacct_nocheck+0x101/0x3e0\n[   76.982222]  submit_bio_noacct+0x389/0x770\n[   76.982227]  submit_bio+0x50/0xc0\n[   76.982232]  submit_bh_wbc+0x15e/0x230\n[   76.982238]  submit_bh+0x14/0x20\n[   76.982241]  ext4_read_bh_nowait+0xc5/0x130\n[   76.982247]  ext4_read_block_bitmap_nowait+0x340/0xc60\n[   76.982254]  ext4_mb_init_cache+0x1ce/0xdc0\n[   76.982259]  ext4_mb_load_buddy_gfp+0x987/0xfa0\n[   76.982263]  ext4_discard_preallocations+0x45d/0x830\n[   76.982274]  ext4_clear_inode+0x48/0xf0\n[   76.982280]  ext4_evict_inode+0xcf/0xc70\n[   76.982285]  evict+0x119/0x2b0\n[   76.982290]  dispose_list+0x43/0xa0\n[   76.982294]  prune_icache_sb+0x64/0x90\n[   76.982298]  super_cache_scan+0x155/0x210\n[   76.982303]  do_shrink_slab+0x19e/0x4e0\n[   76.982310]  shrink_slab+0x2bd/0x450\n[   76.982317]  drop_slab+0xcc/0x1a0\n[   76.982323]  drop_caches_sysctl_handler+0xb7/0xe0\n[   76.982327]  proc_sys_call_handler+0x1bc/0x300\n[   76.982331]  proc_sys_write+0x17/0x20\n[   76.982334]  vfs_write+0x3d3/0x570\n[   76.982342]  ksys_write+0x73/0x160\n[   76.982347]  __x64_sys_write+0x1e/0x30\n[   76.982352]  do_syscall_64+0x35/0x80\n[   76.982357]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nFunct\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50551",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: Fix potential shift-out-of-bounds in brcmf_fw_alloc_request()\n\nThis patch fixes a shift-out-of-bounds in brcmfmac that occurs in\nBIT(chiprev) when a 'chiprev' provided by the device is too large.\nIt should also not be equal to or greater than BITS_PER_TYPE(u32)\nas we do bitwise AND with a u32 variable and BIT(chiprev). The patch\nadds a check that makes the function return NULL if that is the case.\nNote that the NULL case is later handled by the bus-specific caller,\nbrcmf_usb_probe_cb() or brcmf_usb_reset_resume(), for example.\n\nFound by a modified version of syzkaller.\n\nUBSAN: shift-out-of-bounds in drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c\nshift exponent 151055786 is too large for 64-bit type 'long unsigned int'\nCPU: 0 PID: 1885 Comm: kworker/0:2 Tainted: G           O      5.14.0+ #132\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n dump_stack_lvl+0x57/0x7d\n ubsan_epilogue+0x5/0x40\n __ubsan_handle_shift_out_of_bounds.cold+0x53/0xdb\n ? lock_chain_count+0x20/0x20\n brcmf_fw_alloc_request.cold+0x19/0x3ea\n ? brcmf_fw_get_firmwares+0x250/0x250\n ? brcmf_usb_ioctl_resp_wait+0x1a7/0x1f0\n brcmf_usb_get_fwname+0x114/0x1a0\n ? brcmf_usb_reset_resume+0x120/0x120\n ? number+0x6c4/0x9a0\n brcmf_c_process_clm_blob+0x168/0x590\n ? put_dec+0x90/0x90\n ? enable_ptr_key_workfn+0x20/0x20\n ? brcmf_common_pd_remove+0x50/0x50\n ? rcu_read_lock_sched_held+0xa1/0xd0\n brcmf_c_preinit_dcmds+0x673/0xc40\n ? brcmf_c_set_joinpref_default+0x100/0x100\n ? rcu_read_lock_sched_held+0xa1/0xd0\n ? rcu_read_lock_bh_held+0xb0/0xb0\n ? lock_acquire+0x19d/0x4e0\n ? find_held_lock+0x2d/0x110\n ? brcmf_usb_deq+0x1cc/0x260\n ? mark_held_locks+0x9f/0xe0\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n ? _raw_spin_unlock_irqrestore+0x47/0x50\n ? trace_hardirqs_on+0x1c/0x120\n ? brcmf_usb_deq+0x1a7/0x260\n ? brcmf_usb_rx_fill_all+0x5a/0xf0\n brcmf_attach+0x246/0xd40\n ? wiphy_new_nm+0x1476/0x1d50\n ? kmemdup+0x30/0x40\n brcmf_usb_probe+0x12de/0x1690\n ? brcmf_usbdev_qinit.constprop.0+0x470/0x470\n usb_probe_interface+0x25f/0x710\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n ? usb_match_id.part.0+0x88/0xc0\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n ? driver_allows_async_probing+0x120/0x120\n bus_for_each_drv+0x123/0x1a0\n ? bus_rescan_devices+0x20/0x20\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n ? trace_hardirqs_on+0x1c/0x120\n __device_attach+0x207/0x330\n ? device_bind_driver+0xb0/0xb0\n ? kobject_uevent_env+0x230/0x12c0\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n ? __mutex_unlock_slowpath+0xe7/0x660\n ? __fw_devlink_link_to_suppliers+0x550/0x550\n usb_set_configuration+0x984/0x1770\n ? kernfs_create_link+0x175/0x230\n usb_generic_driver_probe+0x69/0x90\n usb_probe_device+0x9c/0x220\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n ? driver_allows_async_probing+0x120/0x120\n bus_for_each_drv+0x123/0x1a0\n ? bus_rescan_devices+0x20/0x20\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n ? trace_hardirqs_on+0x1c/0x120\n __device_attach+0x207/0x330\n ? device_bind_driver+0xb0/0xb0\n ? kobject_uevent_env+0x230/0x12c0\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n ? __fw_devlink_link_to_suppliers+0x550/0x550\n usb_new_device.cold+0x463/0xf66\n ? hub_disconnect+0x400/0x400\n ? _raw_spin_unlock_irq+0x24/0x30\n hub_event+0x10d5/0x3330\n ? hub_port_debounce+0x280/0x280\n ? __lock_acquire+0x1671/0x5790\n ? wq_calc_node_cpumask+0x170/0x2a0\n ? lock_release+0x640/0x640\n ? rcu_read_lock_sched_held+0xa1/0xd0\n ? rcu_read_lock_bh_held+0xb0/0xb0\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n process_one_work+0x873/0x13e0\n ? lock_release+0x640/0x640\n ? pwq_dec_nr_in_flight+0x320/0x320\n ? rwlock_bug.part.0+0x90/0x90\n worker_thread+0x8b/0xd10\n ? __kthread_parkme+0xd9/0x1d0\n ? pr\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50563",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm thin: Fix UAF in run_timer_softirq()\n\nWhen dm_resume() and dm_destroy() are concurrent, it will\nlead to UAF, as follows:\n\n BUG: KASAN: use-after-free in __run_timers+0x173/0x710\n Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0\n\u003csnip\u003e\n Call Trace:\n  \u003cIRQ\u003e\n  dump_stack_lvl+0x73/0x9f\n  print_report.cold+0x132/0xaa2\n  _raw_spin_lock_irqsave+0xcd/0x160\n  __run_timers+0x173/0x710\n  kasan_report+0xad/0x110\n  __run_timers+0x173/0x710\n  __asan_store8+0x9c/0x140\n  __run_timers+0x173/0x710\n  call_timer_fn+0x310/0x310\n  pvclock_clocksource_read+0xfa/0x250\n  kvm_clock_read+0x2c/0x70\n  kvm_clock_get_cycles+0xd/0x20\n  ktime_get+0x5c/0x110\n  lapic_next_event+0x38/0x50\n  clockevents_program_event+0xf1/0x1e0\n  run_timer_softirq+0x49/0x90\n  __do_softirq+0x16e/0x62c\n  __irq_exit_rcu+0x1fa/0x270\n  irq_exit_rcu+0x12/0x20\n  sysvec_apic_timer_interrupt+0x8e/0xc0\n\nOne of the concurrency UAF can be shown as below:\n\n        use                                  free\ndo_resume                           |\n  __find_device_hash_cell           |\n    dm_get                          |\n      atomic_inc(\u0026md-\u003eholders)      |\n                                    | dm_destroy\n                                    |   __dm_destroy\n                                    |     if (!dm_suspended_md(md))\n                                    |     atomic_read(\u0026md-\u003eholders)\n                                    |     msleep(1)\n  dm_resume                         |\n    __dm_resume                     |\n      dm_table_resume_targets       |\n        pool_resume                 |\n          do_waker  #add delay work |\n  dm_put                            |\n    atomic_dec(\u0026md-\u003eholders)        |\n                                    |     dm_table_destroy\n                                    |       pool_dtr\n                                    |         __pool_dec\n                                    |           __pool_destroy\n                                    |             destroy_workqueue\n                                    |             kfree(pool) # free pool\n        time out\n__do_softirq\n  run_timer_softirq # pool has already been freed\n\nThis can be easily reproduced using:\n  1. create thin-pool\n  2. dmsetup suspend pool\n  3. dmsetup resume pool\n  4. dmsetup remove_all # Concurrent with 3\n\nThe root cause of this UAF bug is that dm_resume() adds timer after\ndm_destroy() skips cancelling the timer because of suspend status.\nAfter timeout, it will call run_timer_softirq(), however pool has\nalready been freed. The concurrency UAF bug will happen.\n\nTherefore, cancelling timer again in __pool_destroy().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50564",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/netiucv: Fix return type of netiucv_tx()\n\nWith clang's kernel control flow integrity (kCFI, CONFIG_CFI_CLANG),\nindirect call targets are validated against the expected function\npointer prototype to make sure the call target is valid to help mitigate\nROP attacks. If they are not identical, there is a failure at run time,\nwhich manifests as either a kernel panic or thread getting killed. A\nproposed warning in clang aims to catch these at compile time, which\nreveals:\n\n  drivers/s390/net/netiucv.c:1854:21: error: incompatible function pointer types initializing 'netdev_tx_t (*)(struct sk_buff *, struct net_device *)' (aka 'enum netdev_tx (*)(struct sk_buff *, struct net_device *)') with an expression of type 'int (struct sk_buff *, struct net_device *)' [-Werror,-Wincompatible-function-pointer-types-strict]\n          .ndo_start_xmit         = netiucv_tx,\n                                    ^~~~~~~~~~\n\n-\u003endo_start_xmit() in 'struct net_device_ops' expects a return type of\n'netdev_tx_t', not 'int'. Adjust the return type of netiucv_tx() to\nmatch the prototype's to resolve the warning and potential CFI failure,\nshould s390 select ARCH_SUPPORTS_CFI_CLANG in the future.\n\nAdditionally, while in the area, remove a comment block that is no\nlonger relevant.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50569",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: Update ipcomp_scratches with NULL when freed\n\nCurrently if ipcomp_alloc_scratches() fails to allocate memory\nipcomp_scratches holds obsolete address. So when we try to free the\npercpu scratches using ipcomp_free_scratches() it tries to vfree non\nexistent vm area. Described below:\n\nstatic void * __percpu *ipcomp_alloc_scratches(void)\n{\n        ...\n        scratches = alloc_percpu(void *);\n        if (!scratches)\n                return NULL;\nipcomp_scratches does not know about this allocation failure.\nTherefore holding the old obsolete address.\n        ...\n}\n\nSo when we free,\n\nstatic void ipcomp_free_scratches(void)\n{\n        ...\n        scratches = ipcomp_scratches;\nAssigning obsolete address from ipcomp_scratches\n\n        if (!scratches)\n                return;\n\n        for_each_possible_cpu(i)\n               vfree(*per_cpu_ptr(scratches, i));\nTrying to free non existent page, causing warning: trying to vfree\nexistent vm area.\n        ...\n}\n\nFix this breakage by updating ipcomp_scrtches with NULL when scratches\nis freed",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50571",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: call __btrfs_remove_free_space_cache_locked on cache load failure\n\nNow that lockdep is staying enabled through our entire CI runs I started\nseeing the following stack in generic/475\n\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 2171864 at fs/btrfs/discard.c:604 btrfs_discard_update_discardable+0x98/0xb0\nCPU: 1 PID: 2171864 Comm: kworker/u4:0 Not tainted 5.19.0-rc8+ #789\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\nWorkqueue: btrfs-cache btrfs_work_helper\nRIP: 0010:btrfs_discard_update_discardable+0x98/0xb0\nRSP: 0018:ffffb857c2f7bad0 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff8c85c605c200 RCX: 0000000000000001\nRDX: 0000000000000000 RSI: ffffffff86807c5b RDI: ffffffff868a831e\nRBP: ffff8c85c4c54000 R08: 0000000000000000 R09: 0000000000000000\nR10: ffff8c85c66932f0 R11: 0000000000000001 R12: ffff8c85c3899010\nR13: ffff8c85d5be4f40 R14: ffff8c85c4c54000 R15: ffff8c86114bfa80\nFS:  0000000000000000(0000) GS:ffff8c863bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f2e7f168160 CR3: 000000010289a004 CR4: 0000000000370ee0\nCall Trace:\n\n __btrfs_remove_free_space_cache+0x27/0x30\n load_free_space_cache+0xad2/0xaf0\n caching_thread+0x40b/0x650\n ? lock_release+0x137/0x2d0\n btrfs_work_helper+0xf2/0x3e0\n ? lock_is_held_type+0xe2/0x140\n process_one_work+0x271/0x590\n ? process_one_work+0x590/0x590\n worker_thread+0x52/0x3b0\n ? process_one_work+0x590/0x590\n kthread+0xf0/0x120\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x1f/0x30\n\nThis is the code\n\n        ctl = block_group-\u003efree_space_ctl;\n        discard_ctl = \u0026block_group-\u003efs_info-\u003ediscard_ctl;\n\n        lockdep_assert_held(\u0026ctl-\u003etree_lock);\n\nWe have a temporary free space ctl for loading the free space cache in\norder to avoid having allocations happening while we're loading the\ncache.  When we hit an error we free it all up, however this also calls\nbtrfs_discard_update_discardable, which requires\nblock_group-\u003efree_space_ctl-\u003etree_lock to be held.  However this is our\ntemporary ctl so this lock isn't held.  Fix this by calling\n__btrfs_remove_free_space_cache_locked instead so that we only clean up\nthe entries and do not mess with the discardable stats.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50578",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclass: fix possible memory leak in __class_register()\n\nIf class_add_groups() returns error, the 'cp-\u003esubsys' need be\nunregister, and the 'cp' need be freed.\n\nWe can not call kset_unregister() here, because the 'cls' will\nbe freed in callback function class_release() and it's also\nfreed in caller's error path, it will cause double free.\n\nSo fix this by calling kobject_del() and kfree_const(name) to\ncleanup kobject. Besides, call kfree() to free the 'cp'.\n\nFault injection test can trigger this:\n\nunreferenced object 0xffff888102fa8190 (size 8):\n  comm \"modprobe\", pid 502, jiffies 4294906074 (age 49.296s)\n  hex dump (first 8 bytes):\n    70 6b 74 63 64 76 64 00                          pktcdvd.\n  backtrace:\n    [\u003c00000000e7c7703d\u003e] __kmalloc_track_caller+0x1ae/0x320\n    [\u003c000000005e4d70bc\u003e] kstrdup+0x3a/0x70\n    [\u003c00000000c2e5e85a\u003e] kstrdup_const+0x68/0x80\n    [\u003c000000000049a8c7\u003e] kvasprintf_const+0x10b/0x190\n    [\u003c0000000029123163\u003e] kobject_set_name_vargs+0x56/0x150\n    [\u003c00000000747219c9\u003e] kobject_set_name+0xab/0xe0\n    [\u003c0000000005f1ea4e\u003e] __class_register+0x15c/0x49a\n\nunreferenced object 0xffff888037274000 (size 1024):\n  comm \"modprobe\", pid 502, jiffies 4294906074 (age 49.296s)\n  hex dump (first 32 bytes):\n    00 40 27 37 80 88 ff ff 00 40 27 37 80 88 ff ff  .@'7.....@'7....\n    00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N..........\n  backtrace:\n    [\u003c00000000151f9600\u003e] kmem_cache_alloc_trace+0x17c/0x2f0\n    [\u003c00000000ecf3dd95\u003e] __class_register+0x86/0x49a",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2022-50581",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfs: fix OOB Read in __hfs_brec_find\n\nSyzbot reported a OOB read bug:\n\n==================================================================\nBUG: KASAN: slab-out-of-bounds in hfs_strcmp+0x117/0x190\nfs/hfs/string.c:84\nRead of size 1 at addr ffff88807eb62c4e by task kworker/u4:1/11\nCPU: 1 PID: 11 Comm: kworker/u4:1 Not tainted\n6.1.0-rc6-syzkaller-00308-g644e9524388a #0\nWorkqueue: writeback wb_workfn (flush-7:0)\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106\n print_address_description+0x74/0x340 mm/kasan/report.c:284\n print_report+0x107/0x1f0 mm/kasan/report.c:395\n kasan_report+0xcd/0x100 mm/kasan/report.c:495\n hfs_strcmp+0x117/0x190 fs/hfs/string.c:84\n __hfs_brec_find+0x213/0x5c0 fs/hfs/bfind.c:75\n hfs_brec_find+0x276/0x520 fs/hfs/bfind.c:138\n hfs_write_inode+0x34c/0xb40 fs/hfs/inode.c:462\n write_inode fs/fs-writeback.c:1440 [inline]\n\nIf the input inode of hfs_write_inode() is incorrect:\nstruct inode\n  struct hfs_inode_info\n    struct hfs_cat_key\n      struct hfs_name\n        u8 len # len is greater than HFS_NAMELEN(31) which is the\nmaximum length of an HFS filename\n\nOOB read occurred:\nhfs_write_inode()\n  hfs_brec_find()\n    __hfs_brec_find()\n      hfs_cat_keycmp()\n        hfs_strcmp() # OOB read occurred due to len is too large\n\nFix this by adding a Check on len in hfs_write_inode() before calling\nhfs_brec_find().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-1380",
      "Description": "A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info-\u003ereq_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-28328",
      "Description": "A NULL pointer dereference flaw was found in the az6027 driver in drivers/media/usb/dev-usb/az6027.c in the Linux Kernel. The message from user space is not checked properly before transferring into the device. This flaw allows a local user to crash the system or potentially cause a denial of service.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-3772",
      "Description": "A flaw was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem). This issue may allow a malicious user with CAP_NET_ADMIN privileges to directly dereference a NULL pointer in xfrm_update_ae_params(), leading to a possible kernel crash and denial of service.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-39197",
      "Description": "An out-of-bounds read vulnerability was found in Netfilter Connection Tracking (conntrack) in the Linux kernel. This flaw allows a remote user to disclose sensitive information via the DCCP protocol.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53148",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Fix igb_down hung on surprise removal\n\nIn a setup where a Thunderbolt hub connects to Ethernet and a display\nthrough USB Type-C, users may experience a hung task timeout when they\nremove the cable between the PC and the Thunderbolt hub.\nThis is because the igb_down function is called multiple times when\nthe Thunderbolt hub is unplugged. For example, the igb_io_error_detected\ntriggers the first call, and the igb_remove triggers the second call.\nThe second call to igb_down will block at napi_synchronize.\nHere's the call trace:\n    __schedule+0x3b0/0xddb\n    ? __mod_timer+0x164/0x5d3\n    schedule+0x44/0xa8\n    schedule_timeout+0xb2/0x2a4\n    ? run_local_timers+0x4e/0x4e\n    msleep+0x31/0x38\n    igb_down+0x12c/0x22a [igb 6615058754948bfde0bf01429257eb59f13030d4]\n    __igb_close+0x6f/0x9c [igb 6615058754948bfde0bf01429257eb59f13030d4]\n    igb_close+0x23/0x2b [igb 6615058754948bfde0bf01429257eb59f13030d4]\n    __dev_close_many+0x95/0xec\n    dev_close_many+0x6e/0x103\n    unregister_netdevice_many+0x105/0x5b1\n    unregister_netdevice_queue+0xc2/0x10d\n    unregister_netdev+0x1c/0x23\n    igb_remove+0xa7/0x11c [igb 6615058754948bfde0bf01429257eb59f13030d4]\n    pci_device_remove+0x3f/0x9c\n    device_release_driver_internal+0xfe/0x1b4\n    pci_stop_bus_device+0x5b/0x7f\n    pci_stop_bus_device+0x30/0x7f\n    pci_stop_bus_device+0x30/0x7f\n    pci_stop_and_remove_bus_device+0x12/0x19\n    pciehp_unconfigure_device+0x76/0xe9\n    pciehp_disable_slot+0x6e/0x131\n    pciehp_handle_presence_or_link_change+0x7a/0x3f7\n    pciehp_ist+0xbe/0x194\n    irq_thread_fn+0x22/0x4d\n    ? irq_thread+0x1fd/0x1fd\n    irq_thread+0x17b/0x1fd\n    ? irq_forced_thread_fn+0x5f/0x5f\n    kthread+0x142/0x153\n    ? __irq_get_irqchip_state+0x46/0x46\n    ? kthread_associate_blkcg+0x71/0x71\n    ret_from_fork+0x1f/0x30\n\nIn this case, igb_io_error_detected detaches the network interface\nand requests a PCIE slot reset, however, the PCIE reset callback is\nnot being invoked and thus the Ethernet connection breaks down.\nAs the PCIE error in this case is a non-fatal one, requesting a\nslot reset can be avoided.\nThis patch fixes the task hung issue and preserves Ethernet\nconnection by ignoring non-fatal PCIE errors.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53149",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid deadlock in fs reclaim with page writeback\n\nExt4 has a filesystem wide lock protecting ext4_writepages() calls to\navoid races with switching of journalled data flag or inode format. This\nlock can however cause a deadlock like:\n\nCPU0                            CPU1\n\next4_writepages()\n  percpu_down_read(sbi-\u003es_writepages_rwsem);\n                                ext4_change_inode_journal_flag()\n                                  percpu_down_write(sbi-\u003es_writepages_rwsem);\n                                    - blocks, all readers block from now on\n  ext4_do_writepages()\n    ext4_init_io_end()\n      kmem_cache_zalloc(io_end_cachep, GFP_KERNEL)\n        fs_reclaim frees dentry...\n          dentry_unlink_inode()\n            iput() - last ref =\u003e\n              iput_final() - inode dirty =\u003e\n                write_inode_now()...\n                  ext4_writepages() tries to acquire sbi-\u003es_writepages_rwsem\n                    and blocks forever\n\nMake sure we cannot recurse into filesystem reclaim from writeback code\nto avoid the deadlock.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53150",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Pointer may be dereferenced\n\nKlocwork tool reported pointer 'rport' returned from call to function\nfc_bsg_to_rport() may be NULL and will be dereferenced.\n\nAdd a fix to validate rport before dereferencing.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53151",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid10: prevent soft lockup while flush writes\n\nCurrently, there is no limit for raid1/raid10 plugged bio. While flushing\nwrites, raid1 has cond_resched() while raid10 doesn't, and too many\nwrites can cause soft lockup.\n\nFollow up soft lockup can be triggered easily with writeback test for\nraid10 with ramdisks:\n\nwatchdog: BUG: soft lockup - CPU#10 stuck for 27s! [md0_raid10:1293]\nCall Trace:\n \u003cTASK\u003e\n call_rcu+0x16/0x20\n put_object+0x41/0x80\n __delete_object+0x50/0x90\n delete_object_full+0x2b/0x40\n kmemleak_free+0x46/0xa0\n slab_free_freelist_hook.constprop.0+0xed/0x1a0\n kmem_cache_free+0xfd/0x300\n mempool_free_slab+0x1f/0x30\n mempool_free+0x3a/0x100\n bio_free+0x59/0x80\n bio_put+0xcf/0x2c0\n free_r10bio+0xbf/0xf0\n raid_end_bio_io+0x78/0xb0\n one_write_done+0x8a/0xa0\n raid10_end_write_request+0x1b4/0x430\n bio_endio+0x175/0x320\n brd_submit_bio+0x3b9/0x9b7 [brd]\n __submit_bio+0x69/0xe0\n submit_bio_noacct_nocheck+0x1e6/0x5a0\n submit_bio_noacct+0x38c/0x7e0\n flush_pending_writes+0xf0/0x240\n raid10d+0xac/0x1ed0\n\nFix the problem by adding cond_resched() to raid10 like what raid1 did.\n\nNote that unlimited plugged bio still need to be optimized, for example,\nin the case of lots of dirty pages writeback, this will take lots of\nmemory and io will spend a long time in plug, hence io latency is bad.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53153",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: Fix use after free for wext\n\nKey information in wext.connect is not reset on (re)connect and can hold\ndata from a previous connection.\n\nReset key data to avoid that drivers or mac80211 incorrectly detect a\nWEP connection request and access the freed or already reused memory.\n\nAdditionally optimize cfg80211_sme_connect() and avoid an useless\nschedule of conn_work.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53165",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Fix uninitialized array access for some pathnames\n\nFor filenames that begin with . and are between 2 and 5 characters long,\nUDF charset conversion code would read uninitialized memory in the\noutput buffer. The only practical impact is that the name may be prepended a\n\"unification hash\" when it is not actually needed but still it is good\nto fix this.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53174",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix possible memory leak if device_add() fails\n\nIf device_add() returns error, the name allocated by dev_set_name() needs\nbe freed. As the comment of device_add() says, put_device() should be used\nto decrease the reference count in the error path. So fix this by calling\nput_device(), then the name can be freed in kobject_cleanp().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53176",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: 8250: Reinit port-\u003epm on port specific driver unbind\n\nWhen we unbind a serial port hardware specific 8250 driver, the generic\nserial8250 driver takes over the port. After that we see an oops about 10\nseconds later. This can produce the following at least on some TI SoCs:\n\nUnhandled fault: imprecise external abort (0x1406)\nInternal error: : 1406 [#1] SMP ARM\n\nTurns out that we may still have the serial port hardware specific driver\nport-\u003epm in use, and serial8250_pm() tries to call it after the port\nspecific driver is gone:\n\nserial8250_pm [8250_base] from uart_change_pm+0x54/0x8c [serial_base]\nuart_change_pm [serial_base] from uart_hangup+0x154/0x198 [serial_base]\nuart_hangup [serial_base] from __tty_hangup.part.0+0x328/0x37c\n__tty_hangup.part.0 from disassociate_ctty+0x154/0x20c\ndisassociate_ctty from do_exit+0x744/0xaac\ndo_exit from do_group_exit+0x40/0x8c\ndo_group_exit from __wake_up_parent+0x0/0x1c\n\nLet's fix the issue by calling serial8250_set_defaults() in\nserial8250_unregister_port(). This will set the port back to using\nthe serial8250 default functions, and sets the port-\u003epm to point to\nserial8250_pm.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53178",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: fix zswap writeback race condition\n\nThe zswap writeback mechanism can cause a race condition resulting in\nmemory corruption, where a swapped out page gets swapped in with data that\nwas written to a different page.\n\nThe race unfolds like this:\n1. a page with data A and swap offset X is stored in zswap\n2. page A is removed off the LRU by zpool driver for writeback in\n   zswap-shrink work, data for A is mapped by zpool driver\n3. user space program faults and invalidates page entry A, offset X is\n   considered free\n4. kswapd stores page B at offset X in zswap (zswap could also be\n   full, if so, page B would then be IOed to X, then skip step 5.)\n5. entry A is replaced by B in tree-\u003erbroot, this doesn't affect the\n   local reference held by zswap-shrink work\n6. zswap-shrink work writes back A at X, and frees zswap entry A\n7. swapin of slot X brings A in memory instead of B\n\nThe fix:\nOnce the swap page cache has been allocated (case ZSWAP_SWAPCACHE_NEW),\nzswap-shrink work just checks that the local zswap_entry reference is\nstill the same as the one in the tree.  If it's not the same it means that\nit's either been invalidated or replaced, in both cases the writeback is\naborted because the local entry contains stale data.\n\nReproducer:\nI originally found this by running `stress` overnight to validate my work\non the zswap writeback mechanism, it manifested after hours on my test\nmachine.  The key to make it happen is having zswap writebacks, so\nwhatever setup pumps /sys/kernel/debug/zswap/written_back_pages should do\nthe trick.\n\nIn order to reproduce this faster on a vm, I setup a system with ~100M of\navailable memory and a 500M swap file, then running `stress --vm 1\n--vm-bytes 300000000 --vm-stride 4000` makes it happen in matter of tens\nof minutes.  One can speed things up even more by swinging\n/sys/module/zswap/parameters/max_pool_percent up and down between, say, 20\nand 1; this makes it reproduce in tens of seconds.  It's crucial to set\n`--vm-stride` to something other than 4096 otherwise `stress` won't\nrealize that memory has been corrupted because all pages would have the\nsame data.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53183",
      "Description": "This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53185",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: don't allow to overwrite ENDPOINT0 attributes\n\nA bad USB device is able to construct a service connection response\nmessage with target endpoint being ENDPOINT0 which is reserved for\nHTC_CTRL_RSVD_SVC and should not be modified to be used for any other\nservices.\n\nReject such service connection responses.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53188",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: fix race on port output\n\nassume the following setup on a single machine:\n1. An openvswitch instance with one bridge and default flows\n2. two network namespaces \"server\" and \"client\"\n3. two ovs interfaces \"server\" and \"client\" on the bridge\n4. for each ovs interface a veth pair with a matching name and 32 rx and\n   tx queues\n5. move the ends of the veth pairs to the respective network namespaces\n6. assign ip addresses to each of the veth ends in the namespaces (needs\n   to be the same subnet)\n7. start some http server on the server network namespace\n8. test if a client in the client namespace can reach the http server\n\nwhen following the actions below the host has a chance of getting a cpu\nstuck in a infinite loop:\n1. send a large amount of parallel requests to the http server (around\n   3000 curls should work)\n2. in parallel delete the network namespace (do not delete interfaces or\n   stop the server, just kill the namespace)\n\nthere is a low chance that this will cause the below kernel cpu stuck\nmessage. If this does not happen just retry.\nBelow there is also the output of bpftrace for the functions mentioned\nin the output.\n\nThe series of events happening here is:\n1. the network namespace is deleted calling\n   `unregister_netdevice_many_notify` somewhere in the process\n2. this sets first `NETREG_UNREGISTERING` on both ends of the veth and\n   then runs `synchronize_net`\n3. it then calls `call_netdevice_notifiers` with `NETDEV_UNREGISTER`\n4. this is then handled by `dp_device_event` which calls\n   `ovs_netdev_detach_dev` (if a vport is found, which is the case for\n   the veth interface attached to ovs)\n5. this removes the rx_handlers of the device but does not prevent\n   packages to be sent to the device\n6. `dp_device_event` then queues the vport deletion to work in\n   background as a ovs_lock is needed that we do not hold in the\n   unregistration path\n7. `unregister_netdevice_many_notify` continues to call\n   `netdev_unregister_kobject` which sets `real_num_tx_queues` to 0\n8. port deletion continues (but details are not relevant for this issue)\n9. at some future point the background task deletes the vport\n\nIf after 7. but before 9. a packet is send to the ovs vport (which is\nnot deleted at this point in time) which forwards it to the\n`dev_queue_xmit` flow even though the device is unregistering.\nIn `skb_tx_hash` (which is called in the `dev_queue_xmit`) path there is\na while loop (if the packet has a rx_queue recorded) that is infinite if\n`dev-\u003ereal_num_tx_queues` is zero.\n\nTo prevent this from happening we update `do_output` to handle devices\nwithout carrier the same as if the device is not found (which would\nbe the code path after 9. is done).\n\nAdditionally we now produce a warning in `skb_tx_hash` if we will hit\nthe infinite loop.\n\nbpftrace (first word is function name):\n\n__dev_queue_xmit server: real_num_tx_queues: 1, cpu: 2, pid: 28024, tid: 28024, skb_addr: 0xffff9edb6f207000, reg_state: 1\nnetdev_core_pick_tx server: addr: 0xffff9f0a46d4a000 real_num_tx_queues: 1, cpu: 2, pid: 28024, tid: 28024, skb_addr: 0xffff9edb6f207000, reg_state: 1\ndp_device_event server: real_num_tx_queues: 1 cpu 9, pid: 21024, tid: 21024, event 2, reg_state: 1\nsynchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024\nsynchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024\nsynchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024\nsynchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024\ndp_device_event server: real_num_tx_queues: 1 cpu 9, pid: 21024, tid: 21024, event 6, reg_state: 2\novs_netdev_detach_dev server: real_num_tx_queues: 1 cpu 9, pid: 21024, tid: 21024, reg_state: 2\nnetdev_rx_handler_unregister server: real_num_tx_queues: 1, cpu: 9, pid: 21024, tid: 21024, reg_state: 2\nsynchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024\nnetdev_rx_handler_unregister ret server: real_num_tx_queues: 1, cpu: 9, pid: 21024, tid: 21024, reg_state: 2\ndp_\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53189",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6/addrconf: fix a potential refcount underflow for idev\n\nNow in addrconf_mod_rs_timer(), reference idev depends on whether\nrs_timer is not pending. Then modify rs_timer timeout.\n\nThere is a time gap in [1], during which if the pending rs_timer\nbecomes not pending. It will miss to hold idev, but the rs_timer\nis activated. Thus rs_timer callback function addrconf_rs_timer()\nwill be executed and put idev later without holding idev. A refcount\nunderflow issue for idev can be caused by this.\n\n\tif (!timer_pending(\u0026idev-\u003ers_timer))\n\t\tin6_dev_hold(idev);\n\t\t  \u003c--------------[1]\n\tmod_timer(\u0026idev-\u003ers_timer, jiffies + when);\n\nTo fix the issue, hold idev if mod_timer() return 0.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53191",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/alpine-msi: Fix refcount leak in alpine_msix_init_domains\n\nof_irq_find_parent() returns a node pointer with refcount incremented,\nWe should use of_node_put() on it when not needed anymore.\nAdd missing of_node_put() to avoid refcount leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53199",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: hif_usb: clean up skbs if ath9k_hif_usb_rx_stream() fails\n\nSyzkaller detected a memory leak of skbs in ath9k_hif_usb_rx_stream().\nWhile processing skbs in ath9k_hif_usb_rx_stream(), the already allocated\nskbs in skb_pool are not freed if ath9k_hif_usb_rx_stream() fails. If we\nhave an incorrect pkt_len or pkt_tag, the input skb is considered invalid\nand dropped. All the associated packets already in skb_pool should be\ndropped and freed. Added a comment describing this issue.\n\nThe patch also makes remain_skb NULL after being processed so that it\ncannot be referenced after potential free. The initialization of hif_dev\nfields which are associated with remain_skb (rx_remain_len,\nrx_transfer_len and rx_pad_len) is moved after a new remain_skb is\nallocated.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53201",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/bnxt_re: wraparound mbox producer index\n\nDriver is not handling the wraparound of the mbox producer index correctly.\nCurrently the wraparound happens once u32 max is reached.\n\nBit 31 of the producer index register is special and should be set\nonly once for the first command. Because the producer index overflow\nsetting bit31 after a long time, FW goes to initialization sequence\nand this causes FW hang.\n\nFix is to wraparound the mbox producer index once it reaches u16 max.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53204",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix data-races around user-\u003eunix_inflight.\n\nuser-\u003eunix_inflight is changed under spin_lock(unix_gc_lock),\nbut too_many_unix_fds() reads it locklessly.\n\nLet's annotate the write/read accesses to user-\u003eunix_inflight.\n\nBUG: KCSAN: data-race in unix_attach_fds / unix_inflight\n\nwrite to 0xffffffff8546f2d0 of 8 bytes by task 44798 on cpu 1:\n unix_inflight+0x157/0x180 net/unix/scm.c:66\n unix_attach_fds+0x147/0x1e0 net/unix/scm.c:123\n unix_scm_to_skb net/unix/af_unix.c:1827 [inline]\n unix_dgram_sendmsg+0x46a/0x14f0 net/unix/af_unix.c:1950\n unix_seqpacket_sendmsg net/unix/af_unix.c:2308 [inline]\n unix_seqpacket_sendmsg+0xba/0x130 net/unix/af_unix.c:2292\n sock_sendmsg_nosec net/socket.c:725 [inline]\n sock_sendmsg+0x148/0x160 net/socket.c:748\n ____sys_sendmsg+0x4e4/0x610 net/socket.c:2494\n ___sys_sendmsg+0xc6/0x140 net/socket.c:2548\n __sys_sendmsg+0x94/0x140 net/socket.c:2577\n __do_sys_sendmsg net/socket.c:2586 [inline]\n __se_sys_sendmsg net/socket.c:2584 [inline]\n __x64_sys_sendmsg+0x45/0x50 net/socket.c:2584\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nread to 0xffffffff8546f2d0 of 8 bytes by task 44814 on cpu 0:\n too_many_unix_fds net/unix/scm.c:101 [inline]\n unix_attach_fds+0x54/0x1e0 net/unix/scm.c:110\n unix_scm_to_skb net/unix/af_unix.c:1827 [inline]\n unix_dgram_sendmsg+0x46a/0x14f0 net/unix/af_unix.c:1950\n unix_seqpacket_sendmsg net/unix/af_unix.c:2308 [inline]\n unix_seqpacket_sendmsg+0xba/0x130 net/unix/af_unix.c:2292\n sock_sendmsg_nosec net/socket.c:725 [inline]\n sock_sendmsg+0x148/0x160 net/socket.c:748\n ____sys_sendmsg+0x4e4/0x610 net/socket.c:2494\n ___sys_sendmsg+0xc6/0x140 net/socket.c:2548\n __sys_sendmsg+0x94/0x140 net/socket.c:2577\n __do_sys_sendmsg net/socket.c:2586 [inline]\n __se_sys_sendmsg net/socket.c:2584 [inline]\n __x64_sys_sendmsg+0x45/0x50 net/socket.c:2584\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nvalue changed: 0x000000000000000c -\u003e 0x000000000000000d\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 44814 Comm: systemd-coredum Not tainted 6.4.0-11989-g6843306689af #6\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53215",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/fair: Don't balance task to its current running CPU\n\nWe've run into the case that the balancer tries to balance a migration\ndisabled task and trigger the warning in set_task_cpu() like below:\n\n ------------[ cut here ]------------\n WARNING: CPU: 7 PID: 0 at kernel/sched/core.c:3115 set_task_cpu+0x188/0x240\n Modules linked in: hclgevf xt_CHECKSUM ipt_REJECT nf_reject_ipv4 \u003c...snip\u003e\n CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G           O       6.1.0-rc4+ #1\n Hardware name: Huawei TaiShan 2280 V2/BC82AMDC, BIOS 2280-V2 CS V5.B221.01 12/09/2021\n pstate: 604000c9 (nZCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : set_task_cpu+0x188/0x240\n lr : load_balance+0x5d0/0xc60\n sp : ffff80000803bc70\n x29: ffff80000803bc70 x28: ffff004089e190e8 x27: ffff004089e19040\n x26: ffff007effcabc38 x25: 0000000000000000 x24: 0000000000000001\n x23: ffff80000803be84 x22: 000000000000000c x21: ffffb093e79e2a78\n x20: 000000000000000c x19: ffff004089e19040 x18: 0000000000000000\n x17: 0000000000001fad x16: 0000000000000030 x15: 0000000000000000\n x14: 0000000000000003 x13: 0000000000000000 x12: 0000000000000000\n x11: 0000000000000001 x10: 0000000000000400 x9 : ffffb093e4cee530\n x8 : 00000000fffffffe x7 : 0000000000ce168a x6 : 000000000000013e\n x5 : 00000000ffffffe1 x4 : 0000000000000001 x3 : 0000000000000b2a\n x2 : 0000000000000b2a x1 : ffffb093e6d6c510 x0 : 0000000000000001\n Call trace:\n  set_task_cpu+0x188/0x240\n  load_balance+0x5d0/0xc60\n  rebalance_domains+0x26c/0x380\n  _nohz_idle_balance.isra.0+0x1e0/0x370\n  run_rebalance_domains+0x6c/0x80\n  __do_softirq+0x128/0x3d8\n  ____do_softirq+0x18/0x24\n  call_on_irq_stack+0x2c/0x38\n  do_softirq_own_stack+0x24/0x3c\n  __irq_exit_rcu+0xcc/0xf4\n  irq_exit_rcu+0x18/0x24\n  el1_interrupt+0x4c/0xe4\n  el1h_64_irq_handler+0x18/0x2c\n  el1h_64_irq+0x74/0x78\n  arch_cpu_idle+0x18/0x4c\n  default_idle_call+0x58/0x194\n  do_idle+0x244/0x2b0\n  cpu_startup_entry+0x30/0x3c\n  secondary_start_kernel+0x14c/0x190\n  __secondary_switched+0xb0/0xb4\n ---[ end trace 0000000000000000 ]---\n\nFurther investigation shows that the warning is superfluous, the migration\ndisabled task is just going to be migrated to its current running CPU.\nThis is because that on load balance if the dst_cpu is not allowed by the\ntask, we'll re-select a new_dst_cpu as a candidate. If no task can be\nbalanced to dst_cpu we'll try to balance the task to the new_dst_cpu\ninstead. In this case when the migration disabled task is not on CPU it\nonly allows to run on its current CPU, load balance will select its\ncurrent CPU as new_dst_cpu and later triggers the warning above.\n\nThe new_dst_cpu is chosen from the env-\u003edst_grpmask. Currently it\ncontains CPUs in sched_group_span() and if we have overlapped groups it's\npossible to run into this case. This patch makes env-\u003edst_grpmask of\ngroup_balance_mask() which exclude any CPUs from the busiest group and\nsolve the issue. For balancing in a domain with no overlapped groups\nthe behaviour keeps same as before.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53226",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Fix OOB and integer underflow when rx packets\n\nMake sure mwifiex_process_mgmt_packet,\nmwifiex_process_sta_rx_packet and mwifiex_process_uap_rx_packet,\nmwifiex_uap_queue_bridged_pkt and mwifiex_process_rx_packet\nnot out-of-bounds access the skb-\u003edata buffer.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53229",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix invalid drv_sta_pre_rcu_remove calls for non-uploaded sta\n\nAvoid potential data corruption issues caused by uninitialized driver\nprivate data structures.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53245",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: storvsc: Fix handling of virtual Fibre Channel timeouts\n\nHyper-V provides the ability to connect Fibre Channel LUNs to the host\nsystem and present them in a guest VM as a SCSI device. I/O to the vFC\ndevice is handled by the storvsc driver. The storvsc driver includes a\npartial integration with the FC transport implemented in the generic\nportion of the Linux SCSI subsystem so that FC attributes can be displayed\nin /sys.  However, the partial integration means that some aspects of vFC\ndon't work properly. Unfortunately, a full and correct integration isn't\npractical because of limitations in what Hyper-V provides to the guest.\n\nIn particular, in the context of Hyper-V storvsc, the FC transport timeout\nfunction fc_eh_timed_out() causes a kernel panic because it can't find the\nrport and dereferences a NULL pointer. The original patch that added the\ncall from storvsc_eh_timed_out() to fc_eh_timed_out() is faulty in this\nregard.\n\nIn many cases a timeout is due to a transient condition, so the situation\ncan be improved by just continuing to wait like with other I/O requests\nissued by storvsc, and avoiding the guaranteed panic. For a permanent\nfailure, continuing to wait may result in a hung thread instead of a panic,\nwhich again may be better.\n\nSo fix the panic by removing the storvsc call to fc_eh_timed_out().  This\nallows storvsc to keep waiting for a response.  The change has been tested\nby users who experienced a panic in fc_eh_timed_out() due to transient\ntimeouts, and it solves their problem.\n\nIn the future we may want to deprecate the vFC functionality in storvsc\nsince it can't be fully fixed. But it has current users for whom it is\nworking well enough, so it should probably stay for a while longer.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53246",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix DFS traversal oops without CONFIG_CIFS_DFS_UPCALL\n\nWhen compiled with CONFIG_CIFS_DFS_UPCALL disabled, cifs_dfs_d_automount\nis NULL. cifs.ko logic for mapping CIFS_FATTR_DFS_REFERRAL attributes to\nS_AUTOMOUNT and corresponding dentry flags is retained regardless of\nCONFIG_CIFS_DFS_UPCALL, leading to a NULL pointer dereference in\nVFS follow_automount() when traversing a DFS referral link:\n  BUG: kernel NULL pointer dereference, address: 0000000000000000\n  ...\n  Call Trace:\n   \u003cTASK\u003e\n   __traverse_mounts+0xb5/0x220\n   ? cifs_revalidate_mapping+0x65/0xc0 [cifs]\n   step_into+0x195/0x610\n   ? lookup_fast+0xe2/0xf0\n   path_lookupat+0x64/0x140\n   filename_lookup+0xc2/0x140\n   ? __create_object+0x299/0x380\n   ? kmem_cache_alloc+0x119/0x220\n   ? user_path_at_empty+0x31/0x50\n   user_path_at_empty+0x31/0x50\n   __x64_sys_chdir+0x2a/0xd0\n   ? exit_to_user_mode_prepare+0xca/0x100\n   do_syscall_64+0x42/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThis fix adds an inline cifs_dfs_d_automount() {return -EREMOTE} handler\nwhen CONFIG_CIFS_DFS_UPCALL is disabled. An alternative would be to\navoid flagging S_AUTOMOUNT, etc. without CONFIG_CIFS_DFS_UPCALL. This\napproach was chosen as it provides more control over the error path.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53248",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: install stub fence into potential unused fence pointers\n\nWhen using cpu to update page tables, vm update fences are unused.\nInstall stub fence into these fence pointers instead of NULL\nto avoid NULL dereference when calling dma_fence_wait() on them.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53250",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: dmi-sysfs: Fix null-ptr-deref in dmi_sysfs_register_handle\n\nKASAN reported a null-ptr-deref error:\n\nKASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]\nCPU: 0 PID: 1373 Comm: modprobe\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996)\nRIP: 0010:dmi_sysfs_entry_release\n...\nCall Trace:\n \u003cTASK\u003e\n kobject_put\n dmi_sysfs_register_handle (drivers/firmware/dmi-sysfs.c:540) dmi_sysfs\n dmi_decode_table (drivers/firmware/dmi_scan.c:133)\n dmi_walk (drivers/firmware/dmi_scan.c:1115)\n dmi_sysfs_init (drivers/firmware/dmi-sysfs.c:149) dmi_sysfs\n do_one_initcall (init/main.c:1296)\n ...\nKernel panic - not syncing: Fatal exception\nKernel Offset: 0x4000000 from 0xffffffff81000000\n---[ end Kernel panic - not syncing: Fatal exception ]---\n\nIt is because previous patch added kobject_put() to release the memory\nwhich will call  dmi_sysfs_entry_release() and list_del().\n\nHowever, list_add_tail(entry-\u003elist) is called after the error block,\nso the list_head is uninitialized and cannot be deleted.\n\nMove error handling to after list_add_tail to fix this.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53254",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncacheinfo: Fix shared_cpu_map to handle shared caches at different levels\n\nThe cacheinfo sets up the shared_cpu_map by checking whether the caches\nwith the same index are shared between CPUs. However, this will trigger\nslab-out-of-bounds access if the CPUs do not have the same cache hierarchy.\nAnother problem is the mismatched shared_cpu_map when the shared cache does\nnot have the same index between CPUs.\n\nCPU0\tI\tD\tL3\nindex\t0\t1\t2\tx\n\t^\t^\t^\t^\nindex\t0\t1\t2\t3\nCPU1\tI\tD\tL2\tL3\n\nThis patch checks each cache is shared with all caches on other CPUs.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53265",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: ensure that VID header offset + VID header size \u003c= alloc, size\n\nEnsure that the VID header offset + VID header size does not exceed\nthe allocated area to avoid slab OOB.\n\nBUG: KASAN: slab-out-of-bounds in crc32_body lib/crc32.c:111 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_generic lib/crc32.c:179 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_base+0x58c/0x626 lib/crc32.c:197\nRead of size 4 at addr ffff88802bb36f00 by task syz-executor136/1555\n\nCPU: 2 PID: 1555 Comm: syz-executor136 Tainted: G        W\n6.0.0-1868 #1\nHardware name: Red Hat KVM, BIOS 1.13.0-2.module+el8.3.0+7860+a7792d29\n04/01/2014\nCall Trace:\n  \u003cTASK\u003e\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x85/0xad lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:317 [inline]\n  print_report.cold.13+0xb6/0x6bb mm/kasan/report.c:433\n  kasan_report+0xa7/0x11b mm/kasan/report.c:495\n  crc32_body lib/crc32.c:111 [inline]\n  crc32_le_generic lib/crc32.c:179 [inline]\n  crc32_le_base+0x58c/0x626 lib/crc32.c:197\n  ubi_io_write_vid_hdr+0x1b7/0x472 drivers/mtd/ubi/io.c:1067\n  create_vtbl+0x4d5/0x9c4 drivers/mtd/ubi/vtbl.c:317\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\nRIP: 0033:0x7f96d5cf753d\nCode:\nRSP: 002b:00007fffd72206f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f96d5cf753d\nRDX: 0000000020000080 RSI: 0000000040186f40 RDI: 0000000000000003\nRBP: 0000000000400cd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400be0\nR13: 00007fffd72207e0 R14: 0000000000000000 R15: 0000000000000000\n  \u003c/TASK\u003e\n\nAllocated by task 1555:\n  kasan_save_stack+0x20/0x3d mm/kasan/common.c:38\n  kasan_set_track mm/kasan/common.c:45 [inline]\n  set_alloc_info mm/kasan/common.c:437 [inline]\n  ____kasan_kmalloc mm/kasan/common.c:516 [inline]\n  __kasan_kmalloc+0x88/0xa3 mm/kasan/common.c:525\n  kasan_kmalloc include/linux/kasan.h:234 [inline]\n  __kmalloc+0x138/0x257 mm/slub.c:4429\n  kmalloc include/linux/slab.h:605 [inline]\n  ubi_alloc_vid_buf drivers/mtd/ubi/ubi.h:1093 [inline]\n  create_vtbl+0xcc/0x9c4 drivers/mtd/ubi/vtbl.c:295\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\n\nThe buggy address belongs to the object at ffff88802bb36e00\n  which belongs to the cache kmalloc-256 of size 256\nThe buggy address is located 0 bytes to the right of\n  256-byte region [ffff88802bb36e00, ffff88802bb36f00)\n\nThe buggy address belongs to the physical page:\npage:00000000ea4d1263 refcount:1 mapcount:0 mapping:0000000000000000\nindex:0x0 pfn:0x2bb36\nhead:00000000ea4d1263 order:1 compound_mapcount:0 compound_pincount:0\nflags: 0xfffffc0010200(slab|head|node=0|zone=1|lastcpupid=0x1fffff)\nraw: 000fffffc0010200 ffffea000066c300 dead000000000003 ffff888100042b40\nraw: 0000000000000000 00000000001\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53270",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix i_disksize exceeding i_size problem in paritally written case\n\nIt is possible for i_disksize can exceed i_size, triggering a warning.\n\ngeneric_perform_write\n copied = iov_iter_copy_from_user_atomic(len) // copied \u003c len\n ext4_da_write_end\n | ext4_update_i_disksize\n |  new_i_size = pos + copied;\n |  WRITE_ONCE(EXT4_I(inode)-\u003ei_disksize, newsize) // update i_disksize\n | generic_write_end\n |  copied = block_write_end(copied, len) // copied = 0\n |   if (unlikely(copied \u003c len))\n |    if (!PageUptodate(page))\n |     copied = 0;\n |  if (pos + copied \u003e inode-\u003ei_size) // return false\n if (unlikely(copied == 0))\n  goto again;\n if (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n  status = -EFAULT;\n  break;\n }\n\nWe get i_disksize greater than i_size here, which could trigger WARNING\ncheck 'i_size_read(inode) \u003c EXT4_I(inode)-\u003ei_disksize' while doing dio:\n\next4_dio_write_iter\n iomap_dio_rw\n  __iomap_dio_rw // return err, length is not aligned to 512\n ext4_handle_inode_extension\n  WARN_ON_ONCE(i_size_read(inode) \u003c EXT4_I(inode)-\u003ei_disksize) // Oops\n\n WARNING: CPU: 2 PID: 2609 at fs/ext4/file.c:319\n CPU: 2 PID: 2609 Comm: aa Not tainted 6.3.0-rc2\n RIP: 0010:ext4_file_write_iter+0xbc7\n Call Trace:\n  vfs_write+0x3b1\n  ksys_write+0x77\n  do_syscall_64+0x39\n\nFix it by updating 'copied' value before updating i_disksize just like\next4_write_inline_data_end() does.\n\nA reproducer can be found in the buganizer link below.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53271",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: Fix unreferenced object reported by kmemleak in ubi_resize_volume()\n\nThere is a memory leaks problem reported by kmemleak:\n\nunreferenced object 0xffff888102007a00 (size 128):\n  comm \"ubirsvol\", pid 32090, jiffies 4298464136 (age 2361.231s)\n  hex dump (first 32 bytes):\nff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................\nff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................\n  backtrace:\n[\u003cffffffff8176cecd\u003e] __kmalloc+0x4d/0x150\n[\u003cffffffffa02a9a36\u003e] ubi_eba_create_table+0x76/0x170 [ubi]\n[\u003cffffffffa029764e\u003e] ubi_resize_volume+0x1be/0xbc0 [ubi]\n[\u003cffffffffa02a3321\u003e] ubi_cdev_ioctl+0x701/0x1850 [ubi]\n[\u003cffffffff81975d2d\u003e] __x64_sys_ioctl+0x11d/0x170\n[\u003cffffffff83c142a5\u003e] do_syscall_64+0x35/0x80\n[\u003cffffffff83e0006a\u003e] entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis is due to a mismatch between create and destroy interfaces, and\nin detail that \"new_eba_tbl\" created by ubi_eba_create_table() but\ndestroyed by kfree(), while will causing \"new_eba_tbl-\u003eentries\" not\nfreed.\n\nFix it by replacing kfree(new_eba_tbl) with\nubi_eba_destroy_table(new_eba_tbl)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53272",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ena: fix shift-out-of-bounds in exponential backoff\n\nThe ENA adapters on our instances occasionally reset.  Once recently\nlogged a UBSAN failure to console in the process:\n\n  UBSAN: shift-out-of-bounds in build/linux/drivers/net/ethernet/amazon/ena/ena_com.c:540:13\n  shift exponent 32 is too large for 32-bit type 'unsigned int'\n  CPU: 28 PID: 70012 Comm: kworker/u72:2 Kdump: loaded not tainted 5.15.117\n  Hardware name: Amazon EC2 c5d.9xlarge/, BIOS 1.0 10/16/2017\n  Workqueue: ena ena_fw_reset_device [ena]\n  Call Trace:\n  \u003cTASK\u003e\n  dump_stack_lvl+0x4a/0x63\n  dump_stack+0x10/0x16\n  ubsan_epilogue+0x9/0x36\n  __ubsan_handle_shift_out_of_bounds.cold+0x61/0x10e\n  ? __const_udelay+0x43/0x50\n  ena_delay_exponential_backoff_us.cold+0x16/0x1e [ena]\n  wait_for_reset_state+0x54/0xa0 [ena]\n  ena_com_dev_reset+0xc8/0x110 [ena]\n  ena_down+0x3fe/0x480 [ena]\n  ena_destroy_device+0xeb/0xf0 [ena]\n  ena_fw_reset_device+0x30/0x50 [ena]\n  process_one_work+0x22b/0x3d0\n  worker_thread+0x4d/0x3f0\n  ? process_one_work+0x3d0/0x3d0\n  kthread+0x12a/0x150\n  ? set_kthread_struct+0x50/0x50\n  ret_from_fork+0x22/0x30\n  \u003c/TASK\u003e\n\nApparently, the reset delays are getting so large they can trigger a\nUBSAN panic.\n\nLooking at the code, the current timeout is capped at 5000us.  Using a\nbase value of 100us, the current code will overflow after (1\u003c\u003c29).  Even\nat values before 32, this function wraps around, perhaps\nunintentionally.\n\nCap the value of the exponent used for this backoff at (1\u003c\u003c16) which is\nlarger than currently necessary, but large enough to support bigger\nvalues in the future.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53277",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwl3945: Add missing check for create_singlethread_workqueue\n\nAdd the check for the return value of the create_singlethread_workqueue\nin order to avoid NULL pointer dereference.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53280",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Remove unused nvme_ls_waitq wait queue\n\nSystem crash when qla2x00_start_sp(sp) returns error code EGAIN and wake_up\ngets called for uninitialized wait queue sp-\u003envme_ls_waitq.\n\n    qla2xxx [0000:37:00.1]-2121:5: Returning existing qpair of ffff8ae2c0513400 for idx=0\n    qla2xxx [0000:37:00.1]-700e:5: qla2x00_start_sp failed = 11\n    BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n    PGD 0 P4D 0\n    Oops: 0000 [#1] SMP NOPTI\n    Hardware name: HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 09/03/2021\n    Workqueue: nvme-wq nvme_fc_connect_ctrl_work [nvme_fc]\n    RIP: 0010:__wake_up_common+0x4c/0x190\n    RSP: 0018:ffff95f3e0cb7cd0 EFLAGS: 00010086\n    RAX: 0000000000000000 RBX: ffff8b08d3b26328 RCX: 0000000000000000\n    RDX: 0000000000000001 RSI: 0000000000000003 RDI: ffff8b08d3b26320\n    RBP: 0000000000000001 R08: 0000000000000000 R09: ffffffffffffffe8\n    R10: 0000000000000000 R11: ffff95f3e0cb7a60 R12: ffff95f3e0cb7d20\n    R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000\n    FS:  0000000000000000(0000) GS:ffff8b2fdf6c0000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: 0000000000000000 CR3: 0000002f1e410002 CR4: 00000000007706e0\n    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    PKRU: 55555554\n    Call Trace:\n     __wake_up_common_lock+0x7c/0xc0\n     qla_nvme_ls_req+0x355/0x4c0 [qla2xxx]\n     ? __nvme_fc_send_ls_req+0x260/0x380 [nvme_fc]\n     ? nvme_fc_send_ls_req.constprop.42+0x1a/0x45 [nvme_fc]\n     ? nvme_fc_connect_ctrl_work.cold.63+0x1e3/0xa7d [nvme_fc]\n\nRemove unused nvme_ls_waitq wait queue. nvme_ls_waitq logic was removed\npreviously in the commits tagged Fixed: below.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53282",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix use-after-free KFENCE violation during sysfs firmware write\n\nDuring the sysfs firmware write process, a use-after-free read warning is\nlogged from the lpfc_wr_object() routine:\n\n  BUG: KFENCE: use-after-free read in lpfc_wr_object+0x235/0x310 [lpfc]\n  Use-after-free read at 0x0000000000cf164d (in kfence-#111):\n  lpfc_wr_object+0x235/0x310 [lpfc]\n  lpfc_write_firmware.cold+0x206/0x30d [lpfc]\n  lpfc_sli4_request_firmware_update+0xa6/0x100 [lpfc]\n  lpfc_request_firmware_upgrade_store+0x66/0xb0 [lpfc]\n  kernfs_fop_write_iter+0x121/0x1b0\n  new_sync_write+0x11c/0x1b0\n  vfs_write+0x1ef/0x280\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x59/0x90\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe driver accessed wr_object pointer data, which was initialized into\nmailbox payload memory, after the mailbox object was released back to the\nmailbox pool.\n\nFix by moving the mailbox free calls to the end of the routine ensuring\nthat we don't reference internal mailbox memory after release.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53288",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/client: Fix memory leak in drm_client_modeset_probe\n\nWhen a new mode is set to modeset-\u003emode, the previous mode should be freed.\nThis fixes the following kmemleak report:\n\ndrm_mode_duplicate+0x45/0x220 [drm]\ndrm_client_modeset_probe+0x944/0xf50 [drm]\n__drm_fb_helper_initial_config_and_unlock+0xb4/0x2c0 [drm_kms_helper]\ndrm_fbdev_client_hotplug+0x2bc/0x4d0 [drm_kms_helper]\ndrm_client_register+0x169/0x240 [drm]\nast_pci_probe+0x142/0x190 [ast]\nlocal_pci_probe+0xdc/0x180\nwork_for_cpu_fn+0x4e/0xa0\nprocess_one_work+0x8b7/0x1540\nworker_thread+0x70a/0xed0\nkthread+0x29f/0x340\nret_from_fork+0x1f/0x30",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53289",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: bdisp: Add missing check for create_workqueue\n\nAdd the check for the return value of the create_workqueue\nin order to avoid NULL pointer dereference.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53292",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: fix NULL dereference on q-\u003eelevator in blk_mq_elv_switch_none\n\nAfter grabbing q-\u003esysfs_lock, q-\u003eelevator may become NULL because of\nelevator switch.\n\nFix the NULL dereference on q-\u003eelevator by checking it with lock.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53295",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Do not update file length for failed writes to inline files\n\nWhen write to inline file fails (or happens only partly), we still\nupdated length of inline data as if the whole write succeeded. Fix the\nupdate of length of inline data to happen only if the write succeeds.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53298",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfc: fix memory leak of se_io context in nfc_genl_se_io\n\nThe callback context for sending/receiving APDUs to/from the selected\nsecure element is allocated inside nfc_genl_se_io and supposed to be\neventually freed in se_io_cb callback function. However, there are several\nerror paths where the bwi_timer is not charged to call se_io_cb later, and\nthe cb_context is leaked.\n\nThe patch proposes to free the cb_context explicitly on those error paths.\n\nAt the moment we can't simply check 'dev-\u003eops-\u003ese_io()' return value as it\nmay be negative in both cases: when the timer was charged and was not.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53299",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid10: fix leak of 'r10bio-\u003eremaining' for recovery\n\nraid10_sync_request() will add 'r10bio-\u003eremaining' for both rdev and\nreplacement rdev. However, if the read io fails, recovery_request_write()\nreturns without issuing the write io, in this case, end_sync_request()\nis only called once and 'remaining' is leaked, cause an io hang.\n\nFix the problem by decreasing 'remaining' according to if 'bio' and\n'repl_bio' is valid.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53302",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwl4965: Add missing check for create_singlethread_workqueue()\n\nAdd the check for the return value of the create_singlethread_workqueue()\nin order to avoid NULL pointer dereference.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53305",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix use-after-free\n\nFix potential use-after-free in l2cap_le_command_rej.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53307",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrbd: avoid use-after-free in do_rbd_add() when rbd_dev_create() fails\n\nIf getting an ID or setting up a work queue in rbd_dev_create() fails,\nuse-after-free on rbd_dev-\u003erbd_client, rbd_dev-\u003espec and rbd_dev-\u003eopts\nis triggered in do_rbd_add().  The root cause is that the ownership of\nthese structures is transfered to rbd_dev prematurely and they all end\nup getting freed when rbd_dev_create() calls rbd_dev_free() prior to\nreturning to do_rbd_add().\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE, an\nincomplete patch submitted by Natalia Petrova \u003cn.petrova@fintech.ru\u003e.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53308",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fec: Better handle pm_runtime_get() failing in .remove()\n\nIn the (unlikely) event that pm_runtime_get() (disguised as\npm_runtime_resume_and_get()) fails, the remove callback returned an\nerror early. The problem with this is that the driver core ignores the\nerror value and continues removing the device. This results in a\nresource leak. Worse the devm allocated resources are freed and so if a\ncallback of the driver is called later the register mapping is already\ngone which probably results in a crash.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53309",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/radeon: Fix integer overflow in radeon_cs_parser_init\n\nThe type of size is unsigned, if size is 0x40000000, there will be an\ninteger overflow, size will be zero after size *= sizeof(uint32_t),\nwill cause uninitialized memory to be referenced later",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53313",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid10: fix wrong setting of max_corr_read_errors\n\nThere is no input check when echo md/max_read_errors and overflow might\noccur. Add check of input number.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53317",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix WARNING in mb_find_extent\n\nSyzbot found the following issue:\n\nEXT4-fs: Warning: mounting with data=journal disables delayed allocation, dioread_nolock, O_DIRECT and fast_commit support!\nEXT4-fs (loop0): orphan cleanup on readonly fs\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 5067 at fs/ext4/mballoc.c:1869 mb_find_extent+0x8a1/0xe30\nModules linked in:\nCPU: 1 PID: 5067 Comm: syz-executor307 Not tainted 6.2.0-rc1-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nRIP: 0010:mb_find_extent+0x8a1/0xe30 fs/ext4/mballoc.c:1869\nRSP: 0018:ffffc90003c9e098 EFLAGS: 00010293\nRAX: ffffffff82405731 RBX: 0000000000000041 RCX: ffff8880783457c0\nRDX: 0000000000000000 RSI: 0000000000000041 RDI: 0000000000000040\nRBP: 0000000000000040 R08: ffffffff82405723 R09: ffffed10053c9402\nR10: ffffed10053c9402 R11: 1ffff110053c9401 R12: 0000000000000000\nR13: ffffc90003c9e538 R14: dffffc0000000000 R15: ffffc90003c9e2cc\nFS:  0000555556665300(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000056312f6796f8 CR3: 0000000022437000 CR4: 00000000003506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n \u003cTASK\u003e\n ext4_mb_complex_scan_group+0x353/0x1100 fs/ext4/mballoc.c:2307\n ext4_mb_regular_allocator+0x1533/0x3860 fs/ext4/mballoc.c:2735\n ext4_mb_new_blocks+0xddf/0x3db0 fs/ext4/mballoc.c:5605\n ext4_ext_map_blocks+0x1868/0x6880 fs/ext4/extents.c:4286\n ext4_map_blocks+0xa49/0x1cc0 fs/ext4/inode.c:651\n ext4_getblk+0x1b9/0x770 fs/ext4/inode.c:864\n ext4_bread+0x2a/0x170 fs/ext4/inode.c:920\n ext4_quota_write+0x225/0x570 fs/ext4/super.c:7105\n write_blk fs/quota/quota_tree.c:64 [inline]\n get_free_dqblk+0x34a/0x6d0 fs/quota/quota_tree.c:130\n do_insert_tree+0x26b/0x1aa0 fs/quota/quota_tree.c:340\n do_insert_tree+0x722/0x1aa0 fs/quota/quota_tree.c:375\n do_insert_tree+0x722/0x1aa0 fs/quota/quota_tree.c:375\n do_insert_tree+0x722/0x1aa0 fs/quota/quota_tree.c:375\n dq_insert_tree fs/quota/quota_tree.c:401 [inline]\n qtree_write_dquot+0x3b6/0x530 fs/quota/quota_tree.c:420\n v2_write_dquot+0x11b/0x190 fs/quota/quota_v2.c:358\n dquot_acquire+0x348/0x670 fs/quota/dquot.c:444\n ext4_acquire_dquot+0x2dc/0x400 fs/ext4/super.c:6740\n dqget+0x999/0xdc0 fs/quota/dquot.c:914\n __dquot_initialize+0x3d0/0xcf0 fs/quota/dquot.c:1492\n ext4_process_orphan+0x57/0x2d0 fs/ext4/orphan.c:329\n ext4_orphan_cleanup+0xb60/0x1340 fs/ext4/orphan.c:474\n __ext4_fill_super fs/ext4/super.c:5516 [inline]\n ext4_fill_super+0x81cd/0x8700 fs/ext4/super.c:5644\n get_tree_bdev+0x400/0x620 fs/super.c:1282\n vfs_get_tree+0x88/0x270 fs/super.c:1489\n do_new_mount+0x289/0xad0 fs/namespace.c:3145\n do_mount fs/namespace.c:3488 [inline]\n __do_sys_mount fs/namespace.c:3697 [inline]\n __se_sys_mount+0x2d3/0x3c0 fs/namespace.c:3674\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nAdd some debug information:\nmb_find_extent: mb_find_extent block=41, order=0 needed=64 next=0 ex=0/41/1@3735929054 64 64 7\nblock_bitmap: ff 3f 0c 00 fc 01 00 00 d2 3d 00 00 00 00 00 00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nAcctually, blocks per group is 64, but block bitmap indicate at least has\n128 blocks. Now, ext4_validate_block_bitmap() didn't check invalid block's\nbitmap if set.\nTo resolve above issue, add check like fsck \"Padding at end of block bitmap is\nnot set\".",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53321",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211_hwsim: drop short frames\n\nWhile technically some control frames like ACK are shorter and\nend after Address 1, such frames shouldn't be forwarded through\nwmediumd or similar userspace, so require the full 3-address\nheader to avoid accessing invalid memory if shorter frames are\npassed in.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53322",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Wait for io return on terminate rport\n\nSystem crash due to use after free.\nCurrent code allows terminate_rport_io to exit before making\nsure all IOs has returned. For FCP-2 device, IO's can hang\non in HW because driver has not tear down the session in FW at\nfirst sign of cable pull. When dev_loss_tmo timer pops,\nterminate_rport_io is called and upper layer is about to\nfree various resources. Terminate_rport_io trigger qla to do\nthe final cleanup, but the cleanup might not be fast enough where it\nleave qla still holding on to the same resource.\n\nWait for IO's to return to upper layer before resources are freed.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53326",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc: Don't try to copy PPR for task with NULL pt_regs\n\npowerpc sets up PF_KTHREAD and PF_IO_WORKER with a NULL pt_regs, which\nfrom my (arguably very short) checking is not commonly done for other\narchs. This is fine, except when PF_IO_WORKER's have been created and\nthe task does something that causes a coredump to be generated. Then we\nget this crash:\n\n  Kernel attempted to read user page (160) - exploit attempt? (uid: 1000)\n  BUG: Kernel NULL pointer dereference on read at 0x00000160\n  Faulting instruction address: 0xc0000000000c3a60\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=32 NUMA pSeries\n  Modules linked in: bochs drm_vram_helper drm_kms_helper xts binfmt_misc ecb ctr syscopyarea sysfillrect cbc sysimgblt drm_ttm_helper aes_generic ttm sg libaes evdev joydev virtio_balloon vmx_crypto gf128mul drm dm_mod fuse loop configfs drm_panel_orientation_quirks ip_tables x_tables autofs4 hid_generic usbhid hid xhci_pci xhci_hcd usbcore usb_common sd_mod\n  CPU: 1 PID: 1982 Comm: ppc-crash Not tainted 6.3.0-rc2+ #88\n  Hardware name: IBM pSeries (emulated by qemu) POWER9 (raw) 0x4e1202 0xf000005 of:SLOF,HEAD hv:linux,kvm pSeries\n  NIP:  c0000000000c3a60 LR: c000000000039944 CTR: c0000000000398e0\n  REGS: c0000000041833b0 TRAP: 0300   Not tainted  (6.3.0-rc2+)\n  MSR:  800000000280b033 \u003cSF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE\u003e  CR: 88082828  XER: 200400f8\n  ...\n  NIP memcpy_power7+0x200/0x7d0\n  LR  ppr_get+0x64/0xb0\n  Call Trace:\n    ppr_get+0x40/0xb0 (unreliable)\n    __regset_get+0x180/0x1f0\n    regset_get_alloc+0x64/0x90\n    elf_core_dump+0xb98/0x1b60\n    do_coredump+0x1c34/0x24a0\n    get_signal+0x71c/0x1410\n    do_notify_resume+0x140/0x6f0\n    interrupt_exit_user_prepare_main+0x29c/0x320\n    interrupt_exit_user_prepare+0x6c/0xa0\n    interrupt_return_srr_user+0x8/0x138\n\nBecause ppr_get() is trying to copy from a PF_IO_WORKER with a NULL\npt_regs.\n\nCheck for a valid pt_regs in both ppc_get/ppr_set, and return an error\nif not set. The actual error value doesn't seem to be important here, so\njust pick -EINVAL.\n\n[mpe: Trim oops in change log, add Fixes \u0026 Cc stable]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53331",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npstore/ram: Check start of empty przs during init\n\nAfter commit 30696378f68a (\"pstore/ram: Do not treat empty buffers as\nvalid\"), initialization would assume a prz was valid after seeing that\nthe buffer_size is zero (regardless of the buffer start position). This\nunchecked start value means it could be outside the bounds of the buffer,\nleading to future access panics when written to:\n\n sysdump_panic_event+0x3b4/0x5b8\n atomic_notifier_call_chain+0x54/0x90\n panic+0x1c8/0x42c\n die+0x29c/0x2a8\n die_kernel_fault+0x68/0x78\n __do_kernel_fault+0x1c4/0x1e0\n do_bad_area+0x40/0x100\n do_translation_fault+0x68/0x80\n do_mem_abort+0x68/0xf8\n el1_da+0x1c/0xc0\n __raw_writeb+0x38/0x174\n __memcpy_toio+0x40/0xac\n persistent_ram_update+0x44/0x12c\n persistent_ram_write+0x1a8/0x1b8\n ramoops_pstore_write+0x198/0x1e8\n pstore_console_write+0x94/0xe0\n ...\n\nTo avoid this, also check if the prz start is 0 during the initialization\nphase. If not, the next prz sanity check case will discover it (start \u003e\nsize) and zap the buffer back to a sane state.\n\n[kees: update commit log with backtrace and clarifications]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53332",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngenirq/ipi: Fix NULL pointer deref in irq_data_get_affinity_mask()\n\nIf ipi_send_{mask|single}() is called with an invalid interrupt number, all\nthe local variables there will be NULL. ipi_send_verify() which is invoked\nfrom these functions does verify its 'data' parameter, resulting in a\nkernel oops in irq_data_get_affinity_mask() as the passed NULL pointer gets\ndereferenced.\n\nAdd a missing NULL pointer check in ipi_send_verify()...\n\nFound by Linux Verification Center (linuxtesting.org) with the SVACE static\nanalysis tool.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53335",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/cxgb4: Fix potential null-ptr-deref in pass_establish()\n\nIf get_ep_from_tid() fails to lookup non-NULL value for ep, ep is\ndereferenced later regardless of whether it is empty.\nThis patch adds a simple sanity check to fix the issue.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53338",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlwt: Fix return values of BPF xmit ops\n\nBPF encap ops can return different types of positive values, such like\nNET_RX_DROP, NET_XMIT_CN, NETDEV_TX_BUSY, and so on, from function\nskb_do_redirect and bpf_lwt_xmit_reroute. At the xmit hook, such return\nvalues would be treated implicitly as LWTUNNEL_XMIT_CONTINUE in\nip(6)_finish_output2. When this happens, skbs that have been freed would\ncontinue to the neighbor subsystem, causing use-after-free bug and\nkernel crashes.\n\nTo fix the incorrect behavior, skb_do_redirect return values can be\nsimply discarded, the same as tc-egress behavior. On the other hand,\nbpf_lwt_xmit_reroute returns useful errors to local senders, e.g. PMTU\ninformation. Thus convert its return values to avoid the conflict with\nLWTUNNEL_XMIT_CONTINUE.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53339",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix BUG_ON condition in btrfs_cancel_balance\n\nPausing and canceling balance can race to interrupt balance lead to BUG_ON\npanic in btrfs_cancel_balance. The BUG_ON condition in btrfs_cancel_balance\ndoes not take this race scenario into account.\n\nHowever, the race condition has no other side effects. We can fix that.\n\nReproducing it with panic trace like this:\n\n  kernel BUG at fs/btrfs/volumes.c:4618!\n  RIP: 0010:btrfs_cancel_balance+0x5cf/0x6a0\n  Call Trace:\n   \u003cTASK\u003e\n   ? do_nanosleep+0x60/0x120\n   ? hrtimer_nanosleep+0xb7/0x1a0\n   ? sched_core_clone_cookie+0x70/0x70\n   btrfs_ioctl_balance_ctl+0x55/0x70\n   btrfs_ioctl+0xa46/0xd20\n   __x64_sys_ioctl+0x7d/0xa0\n   do_syscall_64+0x38/0x80\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\n  Race scenario as follows:\n  \u003e mutex_unlock(\u0026fs_info-\u003ebalance_mutex);\n  \u003e --------------------\n  \u003e .......issue pause and cancel req in another thread\n  \u003e --------------------\n  \u003e ret = __btrfs_balance(fs_info);\n  \u003e\n  \u003e mutex_lock(\u0026fs_info-\u003ebalance_mutex);\n  \u003e if (ret == -ECANCELED \u0026\u0026 atomic_read(\u0026fs_info-\u003ebalance_pause_req)) {\n  \u003e         btrfs_info(fs_info, \"balance: paused\");\n  \u003e         btrfs_exclop_balance(fs_info, BTRFS_EXCLOP_BALANCE_PAUSED);\n  \u003e }",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53344",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: bcm: bcm_tx_setup(): fix KMSAN uninit-value in vfs_write\n\nSyzkaller reported the following issue:\n\n=====================================================\nBUG: KMSAN: uninit-value in aio_rw_done fs/aio.c:1520 [inline]\nBUG: KMSAN: uninit-value in aio_write+0x899/0x950 fs/aio.c:1600\n aio_rw_done fs/aio.c:1520 [inline]\n aio_write+0x899/0x950 fs/aio.c:1600\n io_submit_one+0x1d1c/0x3bf0 fs/aio.c:2019\n __do_sys_io_submit fs/aio.c:2078 [inline]\n __se_sys_io_submit+0x293/0x770 fs/aio.c:2048\n __x64_sys_io_submit+0x92/0xd0 fs/aio.c:2048\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nUninit was created at:\n slab_post_alloc_hook mm/slab.h:766 [inline]\n slab_alloc_node mm/slub.c:3452 [inline]\n __kmem_cache_alloc_node+0x71f/0xce0 mm/slub.c:3491\n __do_kmalloc_node mm/slab_common.c:967 [inline]\n __kmalloc+0x11d/0x3b0 mm/slab_common.c:981\n kmalloc_array include/linux/slab.h:636 [inline]\n bcm_tx_setup+0x80e/0x29d0 net/can/bcm.c:930\n bcm_sendmsg+0x3a2/0xce0 net/can/bcm.c:1351\n sock_sendmsg_nosec net/socket.c:714 [inline]\n sock_sendmsg net/socket.c:734 [inline]\n sock_write_iter+0x495/0x5e0 net/socket.c:1108\n call_write_iter include/linux/fs.h:2189 [inline]\n aio_write+0x63a/0x950 fs/aio.c:1600\n io_submit_one+0x1d1c/0x3bf0 fs/aio.c:2019\n __do_sys_io_submit fs/aio.c:2078 [inline]\n __se_sys_io_submit+0x293/0x770 fs/aio.c:2048\n __x64_sys_io_submit+0x92/0xd0 fs/aio.c:2048\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nCPU: 1 PID: 5034 Comm: syz-executor350 Not tainted 6.2.0-rc6-syzkaller-80422-geda666ff2276 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/12/2023\n=====================================================\n\nWe can follow the call chain and find that 'bcm_tx_setup' function\ncalls 'memcpy_from_msg' to copy some content to the newly allocated\nframe of 'op-\u003eframes'. After that the 'len' field of copied structure\nbeing compared with some constant value (64 or 8). However, if\n'memcpy_from_msg' returns an error, we will compare some uninitialized\nmemory. This triggers 'uninit-value' issue.\n\nThis patch will add 'memcpy_from_msg' possible errors processing to\navoid uninit-value issue.\n\nTested via syzkaller",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53348",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix deadlock when aborting transaction during relocation with scrub\n\nBefore relocating a block group we pause scrub, then do the relocation and\nthen unpause scrub. The relocation process requires starting and committing\na transaction, and if we have a failure in the critical section of the\ntransaction commit path (transaction state \u003e= TRANS_STATE_COMMIT_START),\nwe will deadlock if there is a paused scrub.\n\nThat results in stack traces like the following:\n\n  [42.479] BTRFS info (device sdc): relocating block group 53876686848 flags metadata|raid6\n  [42.936] BTRFS warning (device sdc): Skipping commit of aborted transaction.\n  [42.936] ------------[ cut here ]------------\n  [42.936] BTRFS: Transaction aborted (error -28)\n  [42.936] WARNING: CPU: 11 PID: 346822 at fs/btrfs/transaction.c:1977 btrfs_commit_transaction+0xcc8/0xeb0 [btrfs]\n  [42.936] Modules linked in: dm_flakey dm_mod loop btrfs (...)\n  [42.936] CPU: 11 PID: 346822 Comm: btrfs Tainted: G        W          6.3.0-rc2-btrfs-next-127+ #1\n  [42.936] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\n  [42.936] RIP: 0010:btrfs_commit_transaction+0xcc8/0xeb0 [btrfs]\n  [42.936] Code: ff ff 45 8b (...)\n  [42.936] RSP: 0018:ffffb58649633b48 EFLAGS: 00010282\n  [42.936] RAX: 0000000000000000 RBX: ffff8be6ef4d5bd8 RCX: 0000000000000000\n  [42.936] RDX: 0000000000000002 RSI: ffffffffb35e7782 RDI: 00000000ffffffff\n  [42.936] RBP: ffff8be6ef4d5c98 R08: 0000000000000000 R09: ffffb586496339e8\n  [42.936] R10: 0000000000000001 R11: 0000000000000001 R12: ffff8be6d38c7c00\n  [42.936] R13: 00000000ffffffe4 R14: ffff8be6c268c000 R15: ffff8be6ef4d5cf0\n  [42.936] FS:  00007f381a82b340(0000) GS:ffff8beddfcc0000(0000) knlGS:0000000000000000\n  [42.936] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [42.936] CR2: 00007f1e35fb7638 CR3: 0000000117680006 CR4: 0000000000370ee0\n  [42.936] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  [42.936] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  [42.936] Call Trace:\n  [42.936]  \u003cTASK\u003e\n  [42.936]  ? start_transaction+0xcb/0x610 [btrfs]\n  [42.936]  prepare_to_relocate+0x111/0x1a0 [btrfs]\n  [42.936]  relocate_block_group+0x57/0x5d0 [btrfs]\n  [42.936]  ? btrfs_wait_nocow_writers+0x25/0xb0 [btrfs]\n  [42.936]  btrfs_relocate_block_group+0x248/0x3c0 [btrfs]\n  [42.936]  ? __pfx_autoremove_wake_function+0x10/0x10\n  [42.936]  btrfs_relocate_chunk+0x3b/0x150 [btrfs]\n  [42.936]  btrfs_balance+0x8ff/0x11d0 [btrfs]\n  [42.936]  ? __kmem_cache_alloc_node+0x14a/0x410\n  [42.936]  btrfs_ioctl+0x2334/0x32c0 [btrfs]\n  [42.937]  ? mod_objcg_state+0xd2/0x360\n  [42.937]  ? refill_obj_stock+0xb0/0x160\n  [42.937]  ? seq_release+0x25/0x30\n  [42.937]  ? __rseq_handle_notify_resume+0x3b5/0x4b0\n  [42.937]  ? percpu_counter_add_batch+0x2e/0xa0\n  [42.937]  ? __x64_sys_ioctl+0x88/0xc0\n  [42.937]  __x64_sys_ioctl+0x88/0xc0\n  [42.937]  do_syscall_64+0x38/0x90\n  [42.937]  entry_SYSCALL_64_after_hwframe+0x72/0xdc\n  [42.937] RIP: 0033:0x7f381a6ffe9b\n  [42.937] Code: 00 48 89 44 24 (...)\n  [42.937] RSP: 002b:00007ffd45ecf060 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  [42.937] RAX: ffffffffffffffda RBX: 0000000000000001 RCX: 00007f381a6ffe9b\n  [42.937] RDX: 00007ffd45ecf150 RSI: 00000000c4009420 RDI: 0000000000000003\n  [42.937] RBP: 0000000000000003 R08: 0000000000000013 R09: 0000000000000000\n  [42.937] R10: 00007f381a60c878 R11: 0000000000000246 R12: 00007ffd45ed0423\n  [42.937] R13: 00007ffd45ecf150 R14: 0000000000000000 R15: 00007ffd45ecf148\n  [42.937]  \u003c/TASK\u003e\n  [42.937] ---[ end trace 0000000000000000 ]---\n  [42.937] BTRFS: error (device sdc: state A) in cleanup_transaction:1977: errno=-28 No space left\n  [59.196] INFO: task btrfs:346772 blocked for more than 120 seconds.\n  [59.196]       Tainted: G        W          6.3.0-rc2-btrfs-next-127+ #1\n  [59.196] \"echo 0 \u003e /proc/sys/kernel/hung_\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53357",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid10: check slab-out-of-bounds in md_bitmap_get_counter\n\nIf we write a large number to md/bitmap_set_bits, md_bitmap_checkpage()\nwill return -EINVAL because 'page \u003e= bitmap-\u003epages', but the return value\nwas not checked immediately in md_bitmap_get_counter() in order to set\n*blocks value and slab-out-of-bounds occurs.\n\nMove check of 'page \u003e= bitmap-\u003epages' to md_bitmap_get_counter() and\nreturn directly if true.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53365",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nip6mr: Fix skb_under_panic in ip6mr_cache_report()\n\nskbuff: skb_under_panic: text:ffffffff88771f69 len:56 put:-4\n head:ffff88805f86a800 data:ffff887f5f86a850 tail:0x88 end:0x2c0 dev:pim6reg\n ------------[ cut here ]------------\n kernel BUG at net/core/skbuff.c:192!\n invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n CPU: 2 PID: 22968 Comm: kworker/2:11 Not tainted 6.5.0-rc3-00044-g0a8db05b571a #236\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n Workqueue: ipv6_addrconf addrconf_dad_work\n RIP: 0010:skb_panic+0x152/0x1d0\n Call Trace:\n  \u003cTASK\u003e\n  skb_push+0xc4/0xe0\n  ip6mr_cache_report+0xd69/0x19b0\n  reg_vif_xmit+0x406/0x690\n  dev_hard_start_xmit+0x17e/0x6e0\n  __dev_queue_xmit+0x2d6a/0x3d20\n  vlan_dev_hard_start_xmit+0x3ab/0x5c0\n  dev_hard_start_xmit+0x17e/0x6e0\n  __dev_queue_xmit+0x2d6a/0x3d20\n  neigh_connected_output+0x3ed/0x570\n  ip6_finish_output2+0x5b5/0x1950\n  ip6_finish_output+0x693/0x11c0\n  ip6_output+0x24b/0x880\n  NF_HOOK.constprop.0+0xfd/0x530\n  ndisc_send_skb+0x9db/0x1400\n  ndisc_send_rs+0x12a/0x6c0\n  addrconf_dad_completed+0x3c9/0xea0\n  addrconf_dad_work+0x849/0x1420\n  process_one_work+0xa22/0x16e0\n  worker_thread+0x679/0x10c0\n  ret_from_fork+0x28/0x60\n  ret_from_fork_asm+0x11/0x20\n\nWhen setup a vlan device on dev pim6reg, DAD ns packet may sent on reg_vif_xmit().\nreg_vif_xmit()\n    ip6mr_cache_report()\n        skb_push(skb, -skb_network_offset(pkt));//skb_network_offset(pkt) is 4\nAnd skb_push declared as:\n\tvoid *skb_push(struct sk_buff *skb, unsigned int len);\n\t\tskb-\u003edata -= len;\n\t\t//0xffff88805f86a84c - 0xfffffffc = 0xffff887f5f86a850\nskb-\u003edata is set to 0xffff887f5f86a850, which is invalid mem addr, lead to skb_push() fails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53368",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Fix race issue between cpu buffer write and swap\n\nWarning happened in rb_end_commit() at code:\n\tif (RB_WARN_ON(cpu_buffer, !local_read(\u0026cpu_buffer-\u003ecommitting)))\n\n  WARNING: CPU: 0 PID: 139 at kernel/trace/ring_buffer.c:3142\n\trb_commit+0x402/0x4a0\n  Call Trace:\n   ring_buffer_unlock_commit+0x42/0x250\n   trace_buffer_unlock_commit_regs+0x3b/0x250\n   trace_event_buffer_commit+0xe5/0x440\n   trace_event_buffer_reserve+0x11c/0x150\n   trace_event_raw_event_sched_switch+0x23c/0x2c0\n   __traceiter_sched_switch+0x59/0x80\n   __schedule+0x72b/0x1580\n   schedule+0x92/0x120\n   worker_thread+0xa0/0x6f0\n\nIt is because the race between writing event into cpu buffer and swapping\ncpu buffer through file per_cpu/cpu0/snapshot:\n\n  Write on CPU 0             Swap buffer by per_cpu/cpu0/snapshot on CPU 1\n  --------                   --------\n                             tracing_snapshot_write()\n                               [...]\n\n  ring_buffer_lock_reserve()\n    cpu_buffer = buffer-\u003ebuffers[cpu]; // 1. Suppose find 'cpu_buffer_a';\n    [...]\n    rb_reserve_next_event()\n      [...]\n\n                               ring_buffer_swap_cpu()\n                                 if (local_read(\u0026cpu_buffer_a-\u003ecommitting))\n                                     goto out_dec;\n                                 if (local_read(\u0026cpu_buffer_b-\u003ecommitting))\n                                     goto out_dec;\n                                 buffer_a-\u003ebuffers[cpu] = cpu_buffer_b;\n                                 buffer_b-\u003ebuffers[cpu] = cpu_buffer_a;\n                                 // 2. cpu_buffer has swapped here.\n\n      rb_start_commit(cpu_buffer);\n      if (unlikely(READ_ONCE(cpu_buffer-\u003ebuffer)\n          != buffer)) { // 3. This check passed due to 'cpu_buffer-\u003ebuffer'\n        [...]           //    has not changed here.\n        return NULL;\n      }\n                                 cpu_buffer_b-\u003ebuffer = buffer_a;\n                                 cpu_buffer_a-\u003ebuffer = buffer_b;\n                                 [...]\n\n      // 4. Reserve event from 'cpu_buffer_a'.\n\n  ring_buffer_unlock_commit()\n    [...]\n    cpu_buffer = buffer-\u003ebuffers[cpu]; // 5. Now find 'cpu_buffer_b' !!!\n    rb_commit(cpu_buffer)\n      rb_end_commit()  // 6. WARN for the wrong 'committing' state !!!\n\nBased on above analysis, we can easily reproduce by following testcase:\n  ``` bash\n  #!/bin/bash\n\n  dmesg -n 7\n  sysctl -w kernel.panic_on_warn=1\n  TR=/sys/kernel/tracing\n  echo 7 \u003e ${TR}/buffer_size_kb\n  echo \"sched:sched_switch\" \u003e ${TR}/set_event\n  while [ true ]; do\n          echo 1 \u003e ${TR}/per_cpu/cpu0/snapshot\n  done \u0026\n  while [ true ]; do\n          echo 1 \u003e ${TR}/per_cpu/cpu0/snapshot\n  done \u0026\n  while [ true ]; do\n          echo 1 \u003e ${TR}/per_cpu/cpu0/snapshot\n  done \u0026\n  ```\n\nTo fix it, IIUC, we can use smp_call_function_single() to do the swap on\nthe target cpu where the buffer is located, so that above race would be\navoided.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53369",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dcb: choose correct policy to parse DCB_ATTR_BCN\n\nThe dcbnl_bcn_setcfg uses erroneous policy to parse tb[DCB_ATTR_BCN],\nwhich is introduced in commit 859ee3c43812 (\"DCB: Add support for DCB\nBCN\"). Please see the comment in below code\n\nstatic int dcbnl_bcn_setcfg(...)\n{\n  ...\n  ret = nla_parse_nested_deprecated(..., dcbnl_pfc_up_nest, .. )\n  // !!! dcbnl_pfc_up_nest for attributes\n  //  DCB_PFC_UP_ATTR_0 to DCB_PFC_UP_ATTR_ALL in enum dcbnl_pfc_up_attrs\n  ...\n  for (i = DCB_BCN_ATTR_RP_0; i \u003c= DCB_BCN_ATTR_RP_7; i++) {\n  // !!! DCB_BCN_ATTR_RP_0 to DCB_BCN_ATTR_RP_7 in enum dcbnl_bcn_attrs\n    ...\n    value_byte = nla_get_u8(data[i]);\n    ...\n  }\n  ...\n  for (i = DCB_BCN_ATTR_BCNA_0; i \u003c= DCB_BCN_ATTR_RI; i++) {\n  // !!! DCB_BCN_ATTR_BCNA_0 to DCB_BCN_ATTR_RI in enum dcbnl_bcn_attrs\n  ...\n    value_int = nla_get_u32(data[i]);\n  ...\n  }\n  ...\n}\n\nThat is, the nla_parse_nested_deprecated uses dcbnl_pfc_up_nest\nattributes to parse nlattr defined in dcbnl_pfc_up_attrs. But the\nfollowing access code fetch each nlattr as dcbnl_bcn_attrs attributes.\nBy looking up the associated nla_policy for dcbnl_bcn_attrs. We can find\nthe beginning part of these two policies are \"same\".\n\nstatic const struct nla_policy dcbnl_pfc_up_nest[...] = {\n        [DCB_PFC_UP_ATTR_0]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_1]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_2]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_3]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_4]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_5]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_6]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_7]   = {.type = NLA_U8},\n        [DCB_PFC_UP_ATTR_ALL] = {.type = NLA_FLAG},\n};\n\nstatic const struct nla_policy dcbnl_bcn_nest[...] = {\n        [DCB_BCN_ATTR_RP_0]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_1]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_2]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_3]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_4]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_5]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_6]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_7]         = {.type = NLA_U8},\n        [DCB_BCN_ATTR_RP_ALL]       = {.type = NLA_FLAG},\n        // from here is somewhat different\n        [DCB_BCN_ATTR_BCNA_0]       = {.type = NLA_U32},\n        ...\n        [DCB_BCN_ATTR_ALL]          = {.type = NLA_FLAG},\n};\n\nTherefore, the current code is buggy and this\nnla_parse_nested_deprecated could overflow the dcbnl_pfc_up_nest and use\nthe adjacent nla_policy to parse attributes from DCB_BCN_ATTR_BCNA_0.\n\nHence use the correct policy dcbnl_bcn_nest to parse the nested\ntb[DCB_ATTR_BCN] TLV.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53373",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: seqiv - Handle EBUSY correctly\n\nAs it is seqiv only handles the special return value of EINPROGERSS,\nwhich means that in all other cases it will free data related to the\nrequest.\n\nHowever, as the caller of seqiv may specify MAY_BACKLOG, we also need\nto expect EBUSY and treat it in the same way.  Otherwise backlogged\nrequests will trigger a use-after-free.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53380",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid10: fix null-ptr-deref of mreplace in raid10_sync_request\n\nThere are two check of 'mreplace' in raid10_sync_request(). In the first\ncheck, 'need_replace' will be set and 'mreplace' will be used later if\nno-Faulty 'mreplace' exists, In the second check, 'mreplace' will be\nset to NULL if it is Faulty, but 'need_replace' will not be changed\naccordingly. null-ptr-deref occurs if Faulty is set between two check.\n\nFix it by merging two checks into one. And replace 'need_replace' with\n'mreplace' because their values are always the same.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53384",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: avoid possible NULL skb pointer dereference\n\nIn 'mwifiex_handle_uap_rx_forward()', always check the value\nreturned by 'skb_copy()' to avoid potential NULL pointer\ndereference in 'mwifiex_uap_queue_bridged_pkt()', and drop\noriginal skb in case of copying failure.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53393",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx5: Fix mlx5_ib_get_hw_stats when used for device\n\nCurrently, when mlx5_ib_get_hw_stats() is used for device (port_num = 0),\nthere is a special handling in order to use the correct counters, but,\nport_num is being passed down the stack without any change.  Also, some\nfunctions assume that port_num \u003e=1. As a result, the following oops can\noccur.\n\n BUG: unable to handle page fault for address: ffff89510294f1a8\n #PF: supervisor write access in kernel mode\n #PF: error_code(0x0002) - not-present page\n PGD 0 P4D 0\n Oops: 0002 [#1] SMP\n CPU: 8 PID: 1382 Comm: devlink Tainted: G W          6.1.0-rc4_for_upstream_base_2022_11_10_16_12 #1\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n RIP: 0010:_raw_spin_lock+0xc/0x20\n Call Trace:\n  \u003cTASK\u003e\n  mlx5_ib_get_native_port_mdev+0x73/0xe0 [mlx5_ib]\n  do_get_hw_stats.constprop.0+0x109/0x160 [mlx5_ib]\n  mlx5_ib_get_hw_stats+0xad/0x180 [mlx5_ib]\n  ib_setup_device_attrs+0xf0/0x290 [ib_core]\n  ib_register_device+0x3bb/0x510 [ib_core]\n  ? atomic_notifier_chain_register+0x67/0x80\n  __mlx5_ib_add+0x2b/0x80 [mlx5_ib]\n  mlx5r_probe+0xb8/0x150 [mlx5_ib]\n  ? auxiliary_match_id+0x6a/0x90\n  auxiliary_bus_probe+0x3c/0x70\n  ? driver_sysfs_add+0x6b/0x90\n  really_probe+0xcd/0x380\n  __driver_probe_device+0x80/0x170\n  driver_probe_device+0x1e/0x90\n  __device_attach_driver+0x7d/0x100\n  ? driver_allows_async_probing+0x60/0x60\n  ? driver_allows_async_probing+0x60/0x60\n  bus_for_each_drv+0x7b/0xc0\n  __device_attach+0xbc/0x200\n  bus_probe_device+0x87/0xa0\n  device_add+0x404/0x940\n  ? dev_set_name+0x53/0x70\n  __auxiliary_device_add+0x43/0x60\n  add_adev+0x99/0xe0 [mlx5_core]\n  mlx5_attach_device+0xc8/0x120 [mlx5_core]\n  mlx5_load_one_devl_locked+0xb2/0xe0 [mlx5_core]\n  devlink_reload+0x133/0x250\n  devlink_nl_cmd_reload+0x480/0x570\n  ? devlink_nl_pre_doit+0x44/0x2b0\n  genl_family_rcv_msg_doit.isra.0+0xc2/0x110\n  genl_rcv_msg+0x180/0x2b0\n  ? devlink_nl_cmd_region_read_dumpit+0x540/0x540\n  ? devlink_reload+0x250/0x250\n  ? devlink_put+0x50/0x50\n  ? genl_family_rcv_msg_doit.isra.0+0x110/0x110\n  netlink_rcv_skb+0x54/0x100\n  genl_rcv+0x24/0x40\n  netlink_unicast+0x1f6/0x2c0\n  netlink_sendmsg+0x237/0x490\n  sock_sendmsg+0x33/0x40\n  __sys_sendto+0x103/0x160\n  ? handle_mm_fault+0x10e/0x290\n  ? do_user_addr_fault+0x1c0/0x5f0\n  __x64_sys_sendto+0x25/0x30\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nFix it by setting port_num to 1 in order to get device status and remove\nunused variable.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53395",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Add AML_NO_OPERAND_RESOLVE flag to Timer\n\nACPICA commit 90310989a0790032f5a0140741ff09b545af4bc5\n\nAccording to the ACPI specification 19.6.134, no argument is required to be passed for ASL Timer instruction. For taking care of no argument, AML_NO_OPERAND_RESOLVE flag is added to ASL Timer instruction opcode.\n\nWhen ASL timer instruction interpreted by ACPI interpreter, getting error. After adding AML_NO_OPERAND_RESOLVE flag to ASL Timer instruction opcode, issue is not observed.\n\n=============================================================\nUBSAN: array-index-out-of-bounds in acpica/dswexec.c:401:12 index -1 is out of range for type 'union acpi_operand_object *[9]'\nCPU: 37 PID: 1678 Comm: cat Not tainted\n6.0.0-dev-th500-6.0.y-1+bcf8c46459e407-generic-64k\nHW name: NVIDIA BIOS v1.1.1-d7acbfc-dirty 12/19/2022 Call trace:\n dump_backtrace+0xe0/0x130\n show_stack+0x20/0x60\n dump_stack_lvl+0x68/0x84\n dump_stack+0x18/0x34\n ubsan_epilogue+0x10/0x50\n __ubsan_handle_out_of_bounds+0x80/0x90\n acpi_ds_exec_end_op+0x1bc/0x6d8\n acpi_ps_parse_loop+0x57c/0x618\n acpi_ps_parse_aml+0x1e0/0x4b4\n acpi_ps_execute_method+0x24c/0x2b8\n acpi_ns_evaluate+0x3a8/0x4bc\n acpi_evaluate_object+0x15c/0x37c\n acpi_evaluate_integer+0x54/0x15c\n show_power+0x8c/0x12c [acpi_power_meter]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53397",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmodpost: fix off by one in is_executable_section()\n\nThe \u003e comparison should be \u003e= to prevent an out of bounds array\naccess.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53400",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda: Fix Oops by 9.1 surround channel names\n\nget_line_out_pfx() may trigger an Oops by overflowing the static array\nwith more than 8 channels.  This was reported for MacBookPro 12,1 with\nCirrus codec.\n\nAs a workaround, extend for the 9.1 channels and also fix the\npotential Oops by unifying the code paths accessing the same array\nwith the proper size check.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53427",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix warning and UAF when destroy the MR list\n\nIf the MR allocate failed, the MR recovery work not initialized\nand list not cleared. Then will be warning and UAF when release\nthe MR:\n\n  WARNING: CPU: 4 PID: 824 at kernel/workqueue.c:3066 __flush_work.isra.0+0xf7/0x110\n  CPU: 4 PID: 824 Comm: mount.cifs Not tainted 6.1.0-rc5+ #82\n  RIP: 0010:__flush_work.isra.0+0xf7/0x110\n  Call Trace:\n   \u003cTASK\u003e\n   __cancel_work_timer+0x2ba/0x2e0\n   smbd_destroy+0x4e1/0x990\n   _smbd_get_connection+0x1cbd/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\n  BUG: KASAN: use-after-free in smbd_destroy+0x4fc/0x990\n  Read of size 8 at addr ffff88810b156a08 by task mount.cifs/824\n  CPU: 4 PID: 824 Comm: mount.cifs Tainted: G        W          6.1.0-rc5+ #82\n  Call Trace:\n   dump_stack_lvl+0x34/0x44\n   print_report+0x171/0x472\n   kasan_report+0xad/0x130\n   smbd_destroy+0x4fc/0x990\n   _smbd_get_connection+0x1cbd/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\n  Allocated by task 824:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   __kasan_kmalloc+0x7a/0x90\n   _smbd_get_connection+0x1b6f/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\n  Freed by task 824:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   kasan_save_free_info+0x2a/0x40\n   ____kasan_slab_free+0x143/0x1b0\n   __kmem_cache_free+0xc8/0x330\n   _smbd_get_connection+0x1c6a/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nLet's initialize the MR recovery work before MR allocate to prevent\nthe warning, remove the MRs from the list to prevent the UAF.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53431",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Handle enclosure with just a primary component gracefully\n\nThis reverts commit 3fe97ff3d949 (\"scsi: ses: Don't attach if enclosure\nhas no components\") and introduces proper handling of case where there are\nno detected secondary components, but primary component (enumerated in\nnum_enclosures) does exist. That fix was originally proposed by Ding Hui\n\u003cdinghui@sangfor.com.cn\u003e.\n\nCompletely ignoring devices that have one primary enclosure and no\nsecondary one results in ses_intf_add() bailing completely\n\n\tscsi 2:0:0:254: enclosure has no enumerated components\n        scsi 2:0:0:254: Failed to bind enclosure -12ven in valid configurations such\n\neven on valid configurations with 1 primary and 0 secondary enclosures as\nbelow:\n\n\t# sg_ses /dev/sg0\n\t  3PARdata  SES               3321\n\tSupported diagnostic pages:\n\t  Supported Diagnostic Pages [sdp] [0x0]\n\t  Configuration (SES) [cf] [0x1]\n\t  Short Enclosure Status (SES) [ses] [0x8]\n\t# sg_ses -p cf /dev/sg0\n\t  3PARdata  SES               3321\n\tConfiguration diagnostic page:\n\t  number of secondary subenclosures: 0\n\t  generation code: 0x0\n\t  enclosure descriptor list\n\t    Subenclosure identifier: 0 [primary]\n\t      relative ES process id: 0, number of ES processes: 1\n\t      number of type descriptor headers: 1\n\t      enclosure logical identifier (hex): 20000002ac02068d\n\t      enclosure vendor: 3PARdata  product: VV                rev: 3321\n\t  type descriptor header and text list\n\t    Element type: Unspecified, subenclosure id: 0\n\t      number of possible elements: 1\n\nThe changelog for the original fix follows\n\n=====\nWe can get a crash when disconnecting the iSCSI session,\nthe call trace like this:\n\n  [ffff00002a00fb70] kfree at ffff00000830e224\n  [ffff00002a00fba0] ses_intf_remove at ffff000001f200e4\n  [ffff00002a00fbd0] device_del at ffff0000086b6a98\n  [ffff00002a00fc50] device_unregister at ffff0000086b6d58\n  [ffff00002a00fc70] __scsi_remove_device at ffff00000870608c\n  [ffff00002a00fca0] scsi_remove_device at ffff000008706134\n  [ffff00002a00fcc0] __scsi_remove_target at ffff0000087062e4\n  [ffff00002a00fd10] scsi_remove_target at ffff0000087064c0\n  [ffff00002a00fd70] __iscsi_unbind_session at ffff000001c872c4\n  [ffff00002a00fdb0] process_one_work at ffff00000810f35c\n  [ffff00002a00fe00] worker_thread at ffff00000810f648\n  [ffff00002a00fe70] kthread at ffff000008116e98\n\nIn ses_intf_add, components count could be 0, and kcalloc 0 size scomp,\nbut not saved in edev-\u003ecomponent[i].scratch\n\nIn this situation, edev-\u003ecomponent[0].scratch is an invalid pointer,\nwhen kfree it in ses_intf_remove_enclosure, a crash like above would happen\nThe call trace also could be other random cases when kfree cannot catch\nthe invalid pointer\n\nWe should not use edev-\u003ecomponent[] array when the components count is 0\nWe also need check index when use edev-\u003ecomponent[] array in\nses_enclosure_data_process\n=====",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53433",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: add vlan_get_protocol_and_depth() helper\n\nBefore blamed commit, pskb_may_pull() was used instead\nof skb_header_pointer() in __vlan_get_protocol() and friends.\n\nFew callers depended on skb-\u003ehead being populated with MAC header,\nsyzbot caught one of them (skb_mac_gso_segment())\n\nAdd vlan_get_protocol_and_depth() to make the intent clearer\nand use it where sensible.\n\nThis is a more generic fix than commit e9d3f80935b6\n(\"net/af_packet: make sure to pull mac header\") which was\ndealing with a similar issue.\n\nkernel BUG at include/linux/skbuff.h:2655 !\ninvalid opcode: 0000 [#1] SMP KASAN\nCPU: 0 PID: 1441 Comm: syz-executor199 Not tainted 6.1.24-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/14/2023\nRIP: 0010:__skb_pull include/linux/skbuff.h:2655 [inline]\nRIP: 0010:skb_mac_gso_segment+0x68f/0x6a0 net/core/gro.c:136\nCode: fd 48 8b 5c 24 10 44 89 6b 70 48 c7 c7 c0 ae 0d 86 44 89 e6 e8 a1 91 d0 00 48 c7 c7 00 af 0d 86 48 89 de 31 d2 e8 d1 4a e9 ff \u003c0f\u003e 0b 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 41\nRSP: 0018:ffffc90001bd7520 EFLAGS: 00010286\nRAX: ffffffff8469736a RBX: ffff88810f31dac0 RCX: ffff888115a18b00\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ffffc90001bd75e8 R08: ffffffff84697183 R09: fffff5200037adf9\nR10: 0000000000000000 R11: dffffc0000000001 R12: 0000000000000012\nR13: 000000000000fee5 R14: 0000000000005865 R15: 000000000000fed7\nFS: 000055555633f300(0000) GS:ffff8881f6a00000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 0000000116fea000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cTASK\u003e\n[\u003cffffffff847018dd\u003e] __skb_gso_segment+0x32d/0x4c0 net/core/dev.c:3419\n[\u003cffffffff8470398a\u003e] skb_gso_segment include/linux/netdevice.h:4819 [inline]\n[\u003cffffffff8470398a\u003e] validate_xmit_skb+0x3aa/0xee0 net/core/dev.c:3725\n[\u003cffffffff84707042\u003e] __dev_queue_xmit+0x1332/0x3300 net/core/dev.c:4313\n[\u003cffffffff851a9ec7\u003e] dev_queue_xmit+0x17/0x20 include/linux/netdevice.h:3029\n[\u003cffffffff851b4a82\u003e] packet_snd net/packet/af_packet.c:3111 [inline]\n[\u003cffffffff851b4a82\u003e] packet_sendmsg+0x49d2/0x6470 net/packet/af_packet.c:3142\n[\u003cffffffff84669a12\u003e] sock_sendmsg_nosec net/socket.c:716 [inline]\n[\u003cffffffff84669a12\u003e] sock_sendmsg net/socket.c:736 [inline]\n[\u003cffffffff84669a12\u003e] __sys_sendto+0x472/0x5f0 net/socket.c:2139\n[\u003cffffffff84669c75\u003e] __do_sys_sendto net/socket.c:2151 [inline]\n[\u003cffffffff84669c75\u003e] __se_sys_sendto net/socket.c:2147 [inline]\n[\u003cffffffff84669c75\u003e] __x64_sys_sendto+0xe5/0x100 net/socket.c:2147\n[\u003cffffffff8551d40f\u003e] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n[\u003cffffffff8551d40f\u003e] do_syscall_64+0x2f/0x50 arch/x86/entry/common.c:80\n[\u003cffffffff85600087\u003e] entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53436",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: snic: Fix possible memory leak if device_add() fails\n\nIf device_add() returns error, the name allocated by dev_set_name() needs\nbe freed. As the comment of device_add() says, put_device() should be used\nto give up the reference in the error path. So fix this by calling\nput_device(), then the name can be freed in kobject_cleanp().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53438",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/MCE: Always save CS register on AMD Zen IF Poison errors\n\nThe Instruction Fetch (IF) units on current AMD Zen-based systems do not\nguarantee a synchronous #MC is delivered for poison consumption errors.\nTherefore, MCG_STATUS[EIPV|RIPV] will not be set. However, the\nmicroarchitecture does guarantee that the exception is delivered within\nthe same context. In other words, the exact rIP is not known, but the\ncontext is known to not have changed.\n\nThere is no architecturally-defined method to determine this behavior.\n\nThe Code Segment (CS) register is always valid on such IF unit poison\nerrors regardless of the value of MCG_STATUS[EIPV|RIPV].\n\nAdd a quirk to save the CS register for poison consumption from the IF\nunit banks.\n\nThis is needed to properly determine the context of the error.\nOtherwise, the severity grading function will assume the context is\nIN_KERNEL due to the m-\u003ecs value being 0 (the initialized value). This\nleads to unnecessary kernel panics on data poison errors due to the\nkernel believing the poison consumption occurred in kernel context.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53441",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: cpumap: Fix memory leak in cpu_map_update_elem\n\nSyzkaller reported a memory leak as follows:\n\nBUG: memory leak\nunreferenced object 0xff110001198ef748 (size 192):\n  comm \"syz-executor.3\", pid 17672, jiffies 4298118891 (age 9.906s)\n  hex dump (first 32 bytes):\n    00 00 00 00 4a 19 00 00 80 ad e3 e4 fe ff c0 00  ....J...........\n    00 b2 d3 0c 01 00 11 ff 28 f5 8e 19 01 00 11 ff  ........(.......\n  backtrace:\n    [\u003cffffffffadd28087\u003e] __cpu_map_entry_alloc+0xf7/0xb00\n    [\u003cffffffffadd28d8e\u003e] cpu_map_update_elem+0x2fe/0x3d0\n    [\u003cffffffffadc6d0fd\u003e] bpf_map_update_value.isra.0+0x2bd/0x520\n    [\u003cffffffffadc7349b\u003e] map_update_elem+0x4cb/0x720\n    [\u003cffffffffadc7d983\u003e] __se_sys_bpf+0x8c3/0xb90\n    [\u003cffffffffb029cc80\u003e] do_syscall_64+0x30/0x40\n    [\u003cffffffffb0400099\u003e] entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nBUG: memory leak\nunreferenced object 0xff110001198ef528 (size 192):\n  comm \"syz-executor.3\", pid 17672, jiffies 4298118891 (age 9.906s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [\u003cffffffffadd281f0\u003e] __cpu_map_entry_alloc+0x260/0xb00\n    [\u003cffffffffadd28d8e\u003e] cpu_map_update_elem+0x2fe/0x3d0\n    [\u003cffffffffadc6d0fd\u003e] bpf_map_update_value.isra.0+0x2bd/0x520\n    [\u003cffffffffadc7349b\u003e] map_update_elem+0x4cb/0x720\n    [\u003cffffffffadc7d983\u003e] __se_sys_bpf+0x8c3/0xb90\n    [\u003cffffffffb029cc80\u003e] do_syscall_64+0x30/0x40\n    [\u003cffffffffb0400099\u003e] entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nBUG: memory leak\nunreferenced object 0xff1100010fd93d68 (size 8):\n  comm \"syz-executor.3\", pid 17672, jiffies 4298118891 (age 9.906s)\n  hex dump (first 8 bytes):\n    00 00 00 00 00 00 00 00                          ........\n  backtrace:\n    [\u003cffffffffade5db3e\u003e] kvmalloc_node+0x11e/0x170\n    [\u003cffffffffadd28280\u003e] __cpu_map_entry_alloc+0x2f0/0xb00\n    [\u003cffffffffadd28d8e\u003e] cpu_map_update_elem+0x2fe/0x3d0\n    [\u003cffffffffadc6d0fd\u003e] bpf_map_update_value.isra.0+0x2bd/0x520\n    [\u003cffffffffadc7349b\u003e] map_update_elem+0x4cb/0x720\n    [\u003cffffffffadc7d983\u003e] __se_sys_bpf+0x8c3/0xb90\n    [\u003cffffffffb029cc80\u003e] do_syscall_64+0x30/0x40\n    [\u003cffffffffb0400099\u003e] entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nIn the cpu_map_update_elem flow, when kthread_stop is called before\ncalling the threadfn of rcpu-\u003ekthread, since the KTHREAD_SHOULD_STOP bit\nof kthread has been set by kthread_stop, the threadfn of rcpu-\u003ekthread\nwill never be executed, and rcpu-\u003erefcnt will never be 0, which will\nlead to the allocated rcpu, rcpu-\u003equeue and rcpu-\u003equeue-\u003equeue cannot be\nreleased.\n\nCalling kthread_stop before executing kthread's threadfn will return\n-EINTR. We can complete the release of memory resources in this state.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53446",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free\n\nStruct pcie_link_state-\u003edownstream is a pointer to the pci_dev of function\n0.  Previously we retained that pointer when removing function 0, and\nsubsequent ASPM policy changes dereferenced it, resulting in a\nuse-after-free warning from KASAN, e.g.:\n\n  # echo 1 \u003e /sys/bus/pci/devices/0000:03:00.0/remove\n  # echo powersave \u003e /sys/module/pcie_aspm/parameters/policy\n\n  BUG: KASAN: slab-use-after-free in pcie_config_aspm_link+0x42d/0x500\n  Call Trace:\n   kasan_report+0xae/0xe0\n   pcie_config_aspm_link+0x42d/0x500\n   pcie_aspm_set_policy+0x8e/0x1a0\n   param_attr_store+0x162/0x2c0\n   module_attr_store+0x3e/0x80\n\nPCIe spec r6.0, sec 7.5.3.7, recommends that software program the same ASPM\nControl value in all functions of multi-function devices.\n\nDisable ASPM and free the pcie_link_state when any child function is\nremoved so we can discard the dangling pcie_link_state-\u003edownstream pointer\nand maintain the same ASPM Control configuration for all functions.\n\n[bhelgaas: commit log and comment]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53451",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix potential NULL pointer dereference\n\nKlocwork tool reported 'cur_dsd' may be dereferenced.  Add fix to validate\npointer before dereferencing the pointer.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53456",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla4xxx: Add length check when parsing nlattrs\n\nThere are three places that qla4xxx parses nlattrs:\n\n - qla4xxx_set_chap_entry()\n\n - qla4xxx_iface_set_param()\n\n - qla4xxx_sysfs_ddb_set_param()\n\nand each of them directly converts the nlattr to specific pointer of\nstructure without length checking. This could be dangerous as those\nattributes are not validated and a malformed nlattr (e.g., length 0) could\nresult in an OOB read that leaks heap dirty data.\n\nAdd the nla_len check before accessing the nlattr data and return EINVAL if\nthe length check fails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53476",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niw_cxgb4: Fix potential NULL dereference in c4iw_fill_res_cm_id_entry()\n\nThis condition needs to match the previous \"if (epcp-\u003estate == LISTEN) {\"\nexactly to avoid a NULL dereference of either \"listen_ep\" or \"ep\". The\nproblem is that \"epcp\" has been re-assigned so just testing\n\"if (epcp-\u003estate == LISTEN) {\" a second time is not sufficient.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53477",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Add lwtunnel encap size of all siblings in nexthop calculation\n\nIn function rt6_nlmsg_size(), the length of nexthop is calculated\nby multipling the nexthop length of fib6_info and the number of\nsiblings. However if the fib6_info has no lwtunnel but the siblings\nhave lwtunnels, the nexthop length is less than it should be, and\nit will trigger a warning in inet6_rt_notify() as follows:\n\nWARNING: CPU: 0 PID: 6082 at net/ipv6/route.c:6180 inet6_rt_notify+0x120/0x130\n......\nCall Trace:\n \u003cTASK\u003e\n fib6_add_rt2node+0x685/0xa30\n fib6_add+0x96/0x1b0\n ip6_route_add+0x50/0xd0\n inet6_rtm_newroute+0x97/0xa0\n rtnetlink_rcv_msg+0x156/0x3d0\n netlink_rcv_skb+0x5a/0x110\n netlink_unicast+0x246/0x350\n netlink_sendmsg+0x250/0x4c0\n sock_sendmsg+0x66/0x70\n ___sys_sendmsg+0x7c/0xd0\n __sys_sendmsg+0x5d/0xb0\n do_syscall_64+0x3f/0x90\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThis bug can be reproduced by script:\n\nip -6 addr add 2002::2/64 dev ens2\nip -6 route add 100::/64 via 2002::1 dev ens2 metric 100\n\nfor i in 10 20 30 40 50 60 70;\ndo\n\tip link add link ens2 name ipv_$i type ipvlan\n\tip -6 addr add 2002::$i/64 dev ipv_$i\n\tifconfig ipv_$i up\ndone\n\nfor i in 10 20 30 40 50 60;\ndo\n\tip -6 route append 100::/64 encap ip6 dst 2002::$i via 2002::1\ndev ipv_$i metric 100\ndone\n\nip -6 route append 100::/64 via 2002::1 dev ipv_70 metric 100\n\nThis patch fixes it by adding nexthop_len of every siblings using\nrt6_nh_nlmsg_size().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53484",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlib: cpu_rmap: Avoid use after free on rmap-\u003eobj array entries\n\nWhen calling irq_set_affinity_notifier() with NULL at the notify\nargument, it will cause freeing of the glue pointer in the\ncorresponding array entry but will leave the pointer in the array. A\nsubsequent call to free_irq_cpu_rmap() will try to free this entry again\nleading to possible use after free.\n\nFix that by setting NULL to the array entry and checking that we have\nnon-zero at the array entry when iterating over the array in\nfree_irq_cpu_rmap().\n\nThe current code does not suffer from this since there are no cases\nwhere irq_set_affinity_notifier(irq, NULL) (note the NULL passed for the\nnotify arg) is called, followed by a call to free_irq_cpu_rmap() so we\ndon't hit and issue. Subsequent patches in this series excersize this\nflow, hence the required fix.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53499",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_net: Fix error unwinding of XDP initialization\n\nWhen initializing XDP in virtnet_open(), some rq xdp initialization\nmay hit an error causing net device open failed. However, previous\nrqs have already initialized XDP and enabled NAPI, which is not the\nexpected behavior. Need to roll back the previous rq initialization\nto avoid leaks in error unwinding of init code.\n\nAlso extract helper functions of disable and enable queue pairs.\nUse newly introduced disable helper function in error unwinding and\nvirtnet_close. Use enable helper function in virtnet_open.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53506",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Do not bother merging very long extents\n\nWhen merging very long extents we try to push as much length as possible\nto the first extent. However this is unnecessarily complicated and not\nreally worth the trouble. Furthermore there was a bug in the logic\nresulting in corrupting extents in the file as syzbot reproducer shows.\nSo just don't bother with the merging of extents that are too long\ntogether.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53512",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpt3sas: Fix a memory leak\n\nAdd a forgotten kfree().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53517",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: do not update mtu if msg_max is too small in mtu negotiation\n\nWhen doing link mtu negotiation, a malicious peer may send Activate msg\nwith a very small mtu, e.g. 4 in Shuang's testing, without checking for\nthe minimum mtu, l-\u003emtu will be set to 4 in tipc_link_proto_rcv(), then\nn-\u003elinks[bearer_id].mtu is set to 4294967228, which is a overflow of\n'4 - INT_H_SIZE - EMSG_OVERHEAD' in tipc_link_mss().\n\nWith tipc_link.mtu = 4, tipc_link_xmit() kept printing the warning:\n\n tipc: Too large msg, purging xmit list 1 5 0 40 4!\n tipc: Too large msg, purging xmit list 1 15 0 60 4!\n\nAnd with tipc_link_entry.mtu 4294967228, a huge skb was allocated in\nnamed_distribute(), and when purging it in tipc_link_xmit(), a crash\nwas even caused:\n\n  general protection fault, probably for non-canonical address 0x2100001011000dd: 0000 [#1] PREEMPT SMP PTI\n  CPU: 0 PID: 0 Comm: swapper/0 Kdump: loaded Not tainted 6.3.0.neta #19\n  RIP: 0010:kfree_skb_list_reason+0x7e/0x1f0\n  Call Trace:\n   \u003cIRQ\u003e\n   skb_release_data+0xf9/0x1d0\n   kfree_skb_reason+0x40/0x100\n   tipc_link_xmit+0x57a/0x740 [tipc]\n   tipc_node_xmit+0x16c/0x5c0 [tipc]\n   tipc_named_node_up+0x27f/0x2c0 [tipc]\n   tipc_node_write_unlock+0x149/0x170 [tipc]\n   tipc_rcv+0x608/0x740 [tipc]\n   tipc_udp_recv+0xdc/0x1f0 [tipc]\n   udp_queue_rcv_one_skb+0x33e/0x620\n   udp_unicast_rcv_skb.isra.72+0x75/0x90\n   __udp4_lib_rcv+0x56d/0xc20\n   ip_protocol_deliver_rcu+0x100/0x2d0\n\nThis patch fixes it by checking the new mtu against tipc_bearer_min_mtu(),\nand not updating mtu if it is too small.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53519",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-mem2mem: add lock to protect parameter num_rdy\n\nGetting below error when using KCSAN to check the driver. Adding lock to\nprotect parameter num_rdy when getting the value with function:\nv4l2_m2m_num_src_bufs_ready/v4l2_m2m_num_dst_bufs_ready.\n\nkworker/u16:3: [name:report\u0026]BUG: KCSAN: data-race in v4l2_m2m_buf_queue\nkworker/u16:3: [name:report\u0026]\n\nkworker/u16:3: [name:report\u0026]read-write to 0xffffff8105f35b94 of 1 bytes by task 20865 on cpu 7:\nkworker/u16:3:   v4l2_m2m_buf_queue+0xd8/0x10c",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53521",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Fix slab-out-of-bounds in ses_intf_remove()\n\nA fix for:\n\nBUG: KASAN: slab-out-of-bounds in ses_intf_remove+0x23f/0x270 [ses]\nRead of size 8 at addr ffff88a10d32e5d8 by task rmmod/12013\n\nWhen edev-\u003ecomponents is zero, accessing edev-\u003ecomponent[0] members is\nwrong.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53526",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: check 'jh-\u003eb_transaction' before removing it from checkpoint\n\nFollowing process will corrupt ext4 image:\nStep 1:\njbd2_journal_commit_transaction\n __jbd2_journal_insert_checkpoint(jh, commit_transaction)\n // Put jh into trans1-\u003et_checkpoint_list\n journal-\u003ej_checkpoint_transactions = commit_transaction\n // Put trans1 into journal-\u003ej_checkpoint_transactions\n\nStep 2:\ndo_get_write_access\n test_clear_buffer_dirty(bh) // clear buffer dirtyset jbd dirty\n __jbd2_journal_file_buffer(jh, transaction) // jh belongs to trans2\n\nStep 3:\ndrop_cache\n journal_shrink_one_cp_list\n  jbd2_journal_try_remove_checkpoint\n   if (!trylock_buffer(bh))  // lock bh, true\n   if (buffer_dirty(bh))     // buffer is not dirty\n   __jbd2_journal_remove_checkpoint(jh)\n   // remove jh from trans1-\u003et_checkpoint_list\n\nStep 4:\njbd2_log_do_checkpoint\n trans1 = journal-\u003ej_checkpoint_transactions\n // jh is not in trans1-\u003et_checkpoint_list\n jbd2_cleanup_journal_tail(journal)  // trans1 is done\n\nStep 5: Power cut, trans2 is not committed, jh is lost in next mounting.\n\nFix it by checking 'jh-\u003eb_transaction' before remove it from checkpoint.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53530",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Use raw_smp_processor_id() instead of smp_processor_id()\n\nThe following call trace was observed:\n\nlocalhost kernel: nvme nvme0: NVME-FC{0}: controller connect complete\nlocalhost kernel: BUG: using smp_processor_id() in preemptible [00000000] code: kworker/u129:4/75092\nlocalhost kernel: nvme nvme0: NVME-FC{0}: new ctrl: NQN \"nqn.1992-08.com.netapp:sn.b42d198afb4d11ecad6d00a098d6abfa:subsystem.PR_Channel2022_RH84_subsystem_291\"\nlocalhost kernel: caller is qla_nvme_post_cmd+0x216/0x1380 [qla2xxx]\nlocalhost kernel: CPU: 6 PID: 75092 Comm: kworker/u129:4 Kdump: loaded Tainted: G    B   W  OE    --------- ---  5.14.0-70.22.1.el9_0.x86_64+debug #1\nlocalhost kernel: Hardware name: HPE ProLiant XL420 Gen10/ProLiant XL420 Gen10, BIOS U39 01/13/2022\nlocalhost kernel: Workqueue: nvme-wq nvme_async_event_work [nvme_core]\nlocalhost kernel: Call Trace:\nlocalhost kernel: dump_stack_lvl+0x57/0x7d\nlocalhost kernel: check_preemption_disabled+0xc8/0xd0\nlocalhost kernel: qla_nvme_post_cmd+0x216/0x1380 [qla2xxx]\n\nUse raw_smp_processor_id() instead of smp_processor_id().\n\nAlso use queue_work() across the driver instead of queue_work_on() thus\navoiding usage of smp_processor_id() when CONFIG_DEBUG_PREEMPT is enabled.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53533",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: raspberrypi-ts - fix refcount leak in rpi_ts_probe\n\nrpi_firmware_get() take reference, we need to release it in error paths\nas well. Use devm_rpi_firmware_get() helper to handling the resources.\nAlso remove the existing rpi_firmware_put().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53540",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: reject auth/assoc to AP with our address\n\nIf the AP uses our own address as its MLD address or BSSID, then\nclearly something's wrong. Reject such connections so we don't\ntry and fail later.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53542",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nARM: dts: exynos: Use Exynos5420 compatible for the MIPI video phy\n\nFor some reason, the driver adding support for Exynos5420 MIPI phy\nback in 2016 wasn't used on Exynos5420, which caused a kernel panic.\nAdd the proper compatible for it.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53548",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usbnet: Fix WARNING in usbnet_start_xmit/usb_submit_urb\n\nThe syzbot fuzzer identified a problem in the usbnet driver:\n\nusb 1-1: BOGUS urb xfer, pipe 3 != type 1\nWARNING: CPU: 0 PID: 754 at drivers/usb/core/urb.c:504 usb_submit_urb+0xed6/0x1880 drivers/usb/core/urb.c:504\nModules linked in:\nCPU: 0 PID: 754 Comm: kworker/0:2 Not tainted 6.4.0-rc7-syzkaller-00014-g692b7dc87ca6 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023\nWorkqueue: mld mld_ifc_work\nRIP: 0010:usb_submit_urb+0xed6/0x1880 drivers/usb/core/urb.c:504\nCode: 7c 24 18 e8 2c b4 5b fb 48 8b 7c 24 18 e8 42 07 f0 fe 41 89 d8 44 89 e1 4c 89 ea 48 89 c6 48 c7 c7 a0 c9 fc 8a e8 5a 6f 23 fb \u003c0f\u003e 0b e9 58 f8 ff ff e8 fe b3 5b fb 48 81 c5 c0 05 00 00 e9 84 f7\nRSP: 0018:ffffc9000463f568 EFLAGS: 00010086\nRAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000\nRDX: ffff88801eb28000 RSI: ffffffff814c03b7 RDI: 0000000000000001\nRBP: ffff8881443b7190 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000003\nR13: ffff88802a77cb18 R14: 0000000000000003 R15: ffff888018262500\nFS:  0000000000000000(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000556a99c15a18 CR3: 0000000028c71000 CR4: 0000000000350ef0\nCall Trace:\n \u003cTASK\u003e\n usbnet_start_xmit+0xfe5/0x2190 drivers/net/usb/usbnet.c:1453\n __netdev_start_xmit include/linux/netdevice.h:4918 [inline]\n netdev_start_xmit include/linux/netdevice.h:4932 [inline]\n xmit_one net/core/dev.c:3578 [inline]\n dev_hard_start_xmit+0x187/0x700 net/core/dev.c:3594\n...\n\nThis bug is caused by the fact that usbnet trusts the bulk endpoint\naddresses its probe routine receives in the driver_info structure, and\nit does not check to see that these endpoints actually exist and have\nthe expected type and directions.\n\nThe fix is simply to add such a check.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53556",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niavf: Fix use-after-free in free_netdev\n\nWe do netif_napi_add() for all allocated q_vectors[], but potentially\ndo netif_napi_del() for part of them, then kfree q_vectors and leave\ninvalid pointers at dev-\u003enapi_list.\n\nReproducer:\n\n  [root@host ~]# cat repro.sh\n  #!/bin/bash\n\n  pf_dbsf=\"0000:41:00.0\"\n  vf0_dbsf=\"0000:41:02.0\"\n  g_pids=()\n\n  function do_set_numvf()\n  {\n      echo 2 \u003e/sys/bus/pci/devices/${pf_dbsf}/sriov_numvfs\n      sleep $((RANDOM%3+1))\n      echo 0 \u003e/sys/bus/pci/devices/${pf_dbsf}/sriov_numvfs\n      sleep $((RANDOM%3+1))\n  }\n\n  function do_set_channel()\n  {\n      local nic=$(ls -1 --indicator-style=none /sys/bus/pci/devices/${vf0_dbsf}/net/)\n      [ -z \"$nic\" ] \u0026\u0026 { sleep $((RANDOM%3)) ; return 1; }\n      ifconfig $nic 192.168.18.5 netmask 255.255.255.0\n      ifconfig $nic up\n      ethtool -L $nic combined 1\n      ethtool -L $nic combined 4\n      sleep $((RANDOM%3))\n  }\n\n  function on_exit()\n  {\n      local pid\n      for pid in \"${g_pids[@]}\"; do\n          kill -0 \"$pid\" \u0026\u003e/dev/null \u0026\u0026 kill \"$pid\" \u0026\u003e/dev/null\n      done\n      g_pids=()\n  }\n\n  trap \"on_exit; exit\" EXIT\n\n  while :; do do_set_numvf ; done \u0026\n  g_pids+=($!)\n  while :; do do_set_channel ; done \u0026\n  g_pids+=($!)\n\n  wait\n\nResult:\n\n[ 4093.900222] ==================================================================\n[ 4093.900230] BUG: KASAN: use-after-free in free_netdev+0x308/0x390\n[ 4093.900232] Read of size 8 at addr ffff88b4dc145640 by task repro.sh/6699\n[ 4093.900233]\n[ 4093.900236] CPU: 10 PID: 6699 Comm: repro.sh Kdump: loaded Tainted: G           O     --------- -t - 4.18.0 #1\n[ 4093.900238] Hardware name: Powerleader PR2008AL/H12DSi-N6, BIOS 2.0 04/09/2021\n[ 4093.900239] Call Trace:\n[ 4093.900244]  dump_stack+0x71/0xab\n[ 4093.900249]  print_address_description+0x6b/0x290\n[ 4093.900251]  ? free_netdev+0x308/0x390\n[ 4093.900252]  kasan_report+0x14a/0x2b0\n[ 4093.900254]  free_netdev+0x308/0x390\n[ 4093.900261]  iavf_remove+0x825/0xd20 [iavf]\n[ 4093.900265]  pci_device_remove+0xa8/0x1f0\n[ 4093.900268]  device_release_driver_internal+0x1c6/0x460\n[ 4093.900271]  pci_stop_bus_device+0x101/0x150\n[ 4093.900273]  pci_stop_and_remove_bus_device+0xe/0x20\n[ 4093.900275]  pci_iov_remove_virtfn+0x187/0x420\n[ 4093.900277]  ? pci_iov_add_virtfn+0xe10/0xe10\n[ 4093.900278]  ? pci_get_subsys+0x90/0x90\n[ 4093.900280]  sriov_disable+0xed/0x3e0\n[ 4093.900282]  ? bus_find_device+0x12d/0x1a0\n[ 4093.900290]  i40e_free_vfs+0x754/0x1210 [i40e]\n[ 4093.900298]  ? i40e_reset_all_vfs+0x880/0x880 [i40e]\n[ 4093.900299]  ? pci_get_device+0x7c/0x90\n[ 4093.900300]  ? pci_get_subsys+0x90/0x90\n[ 4093.900306]  ? pci_vfs_assigned.part.7+0x144/0x210\n[ 4093.900309]  ? __mutex_lock_slowpath+0x10/0x10\n[ 4093.900315]  i40e_pci_sriov_configure+0x1fa/0x2e0 [i40e]\n[ 4093.900318]  sriov_numvfs_store+0x214/0x290\n[ 4093.900320]  ? sriov_totalvfs_show+0x30/0x30\n[ 4093.900321]  ? __mutex_lock_slowpath+0x10/0x10\n[ 4093.900323]  ? __check_object_size+0x15a/0x350\n[ 4093.900326]  kernfs_fop_write+0x280/0x3f0\n[ 4093.900329]  vfs_write+0x145/0x440\n[ 4093.900330]  ksys_write+0xab/0x160\n[ 4093.900332]  ? __ia32_sys_read+0xb0/0xb0\n[ 4093.900334]  ? fput_many+0x1a/0x120\n[ 4093.900335]  ? filp_close+0xf0/0x130\n[ 4093.900338]  do_syscall_64+0xa0/0x370\n[ 4093.900339]  ? page_fault+0x8/0x30\n[ 4093.900341]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n[ 4093.900357] RIP: 0033:0x7f16ad4d22c0\n[ 4093.900359] Code: 73 01 c3 48 8b 0d d8 cb 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 89 24 2d 00 00 75 10 b8 01 00 00 00 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 fe dd 01 00 48 89 04 24\n[ 4093.900360] RSP: 002b:00007ffd6491b7f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[ 4093.900362] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f16ad4d22c0\n[ 4093.900363] RDX: 0000000000000002 RSI: 0000000001a41408 RDI: 0000000000000001\n[ 4093.900364] RBP: 0000000001a41408 R08: 00007f16ad7a1780 R09: 00007f16ae1f2700\n[ 4093.9003\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53559",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nip_vti: fix potential slab-use-after-free in decode_session6\n\nWhen ip_vti device is set to the qdisc of the sfb type, the cb field\nof the sent skb may be modified during enqueuing. Then,\nslab-use-after-free may occur when ip_vti device sends IPv6 packets.\nAs commit f855691975bb (\"xfrm6: Fix the nexthdr offset in\n_decode_session6.\") showed, xfrm_decode_session was originally intended\nonly for the receive path. IP6CB(skb)-\u003enhoff is not set during\ntransmission. Therefore, set the cb field in the skb to 0 before\nsending packets.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53564",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix defrag path triggering jbd2 ASSERT\n\ncode path:\n\nocfs2_ioctl_move_extents\n ocfs2_move_extents\n  ocfs2_defrag_extent\n   __ocfs2_move_extent\n    + ocfs2_journal_access_di\n    + ocfs2_split_extent  //sub-paths call jbd2_journal_restart\n    + ocfs2_journal_dirty //crash by jbs2 ASSERT\n\ncrash stacks:\n\nPID: 11297  TASK: ffff974a676dcd00  CPU: 67  COMMAND: \"defragfs.ocfs2\"\n #0 [ffffb25d8dad3900] machine_kexec at ffffffff8386fe01\n #1 [ffffb25d8dad3958] __crash_kexec at ffffffff8395959d\n #2 [ffffb25d8dad3a20] crash_kexec at ffffffff8395a45d\n #3 [ffffb25d8dad3a38] oops_end at ffffffff83836d3f\n #4 [ffffb25d8dad3a58] do_trap at ffffffff83833205\n #5 [ffffb25d8dad3aa0] do_invalid_op at ffffffff83833aa6\n #6 [ffffb25d8dad3ac0] invalid_op at ffffffff84200d18\n    [exception RIP: jbd2_journal_dirty_metadata+0x2ba]\n    RIP: ffffffffc09ca54a  RSP: ffffb25d8dad3b70  RFLAGS: 00010207\n    RAX: 0000000000000000  RBX: ffff9706eedc5248  RCX: 0000000000000000\n    RDX: 0000000000000001  RSI: ffff97337029ea28  RDI: ffff9706eedc5250\n    RBP: ffff9703c3520200   R8: 000000000f46b0b2   R9: 0000000000000000\n    R10: 0000000000000001  R11: 00000001000000fe  R12: ffff97337029ea28\n    R13: 0000000000000000  R14: ffff9703de59bf60  R15: ffff9706eedc5250\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #7 [ffffb25d8dad3ba8] ocfs2_journal_dirty at ffffffffc137fb95 [ocfs2]\n #8 [ffffb25d8dad3be8] __ocfs2_move_extent at ffffffffc139a950 [ocfs2]\n #9 [ffffb25d8dad3c80] ocfs2_defrag_extent at ffffffffc139b2d2 [ocfs2]\n\nAnalysis\n\nThis bug has the same root cause of 'commit 7f27ec978b0e (\"ocfs2: call\nocfs2_journal_access_di() before ocfs2_journal_dirty() in\nocfs2_write_end_nolock()\")'.  For this bug, jbd2_journal_restart() is\ncalled by ocfs2_split_extent() during defragmenting.\n\nHow to fix\n\nFor ocfs2_split_extent() can handle journal operations totally by itself. \nCaller doesn't need to call journal access/dirty pair, and caller only\nneeds to call journal start/stop pair.  The fix method is to remove\njournal access/dirty from __ocfs2_move_extent().\n\nThe discussion for this patch:\nhttps://oss.oracle.com/pipermail/ocfs2-devel/2023-February/000647.html",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53568",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/zcrypt: don't leak memory if dev_set_name() fails\n\nWhen dev_set_name() fails, zcdn_create() doesn't free the newly\nallocated resources. Do it.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53582",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: ensure CLM version is null-terminated to prevent stack-out-of-bounds\n\nFix a stack-out-of-bounds read in brcmfmac that occurs\nwhen 'buf' that is not null-terminated is passed as an argument of\nstrreplace() in brcmf_c_preinit_dcmds(). This buffer is filled with\na CLM version string by memcpy() in brcmf_fil_iovar_data_get().\nEnsure buf is null-terminated.\n\nFound by a modified version of syzkaller.\n\n[   33.004414][ T1896] brcmfmac: brcmf_c_process_clm_blob: no clm_blob available (err=-2), device may have limited channels available\n[   33.013486][ T1896] brcmfmac: brcmf_c_preinit_dcmds: Firmware: BCM43236/3 wl0: Nov 30 2011 17:33:42 version 5.90.188.22\n[   33.021554][ T1896] ==================================================================\n[   33.022379][ T1896] BUG: KASAN: stack-out-of-bounds in strreplace+0xf2/0x110\n[   33.023122][ T1896] Read of size 1 at addr ffffc90001d6efc8 by task kworker/0:2/1896\n[   33.023852][ T1896]\n[   33.024096][ T1896] CPU: 0 PID: 1896 Comm: kworker/0:2 Tainted: G           O      5.14.0+ #132\n[   33.024927][ T1896] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\n[   33.026065][ T1896] Workqueue: usb_hub_wq hub_event\n[   33.026581][ T1896] Call Trace:\n[   33.026896][ T1896]  dump_stack_lvl+0x57/0x7d\n[   33.027372][ T1896]  print_address_description.constprop.0.cold+0xf/0x334\n[   33.028037][ T1896]  ? strreplace+0xf2/0x110\n[   33.028403][ T1896]  ? strreplace+0xf2/0x110\n[   33.028807][ T1896]  kasan_report.cold+0x83/0xdf\n[   33.029283][ T1896]  ? strreplace+0xf2/0x110\n[   33.029666][ T1896]  strreplace+0xf2/0x110\n[   33.029966][ T1896]  brcmf_c_preinit_dcmds+0xab1/0xc40\n[   33.030351][ T1896]  ? brcmf_c_set_joinpref_default+0x100/0x100\n[   33.030787][ T1896]  ? rcu_read_lock_sched_held+0xa1/0xd0\n[   33.031223][ T1896]  ? rcu_read_lock_bh_held+0xb0/0xb0\n[   33.031661][ T1896]  ? lock_acquire+0x19d/0x4e0\n[   33.032091][ T1896]  ? find_held_lock+0x2d/0x110\n[   33.032605][ T1896]  ? brcmf_usb_deq+0x1a7/0x260\n[   33.033087][ T1896]  ? brcmf_usb_rx_fill_all+0x5a/0xf0\n[   33.033582][ T1896]  brcmf_attach+0x246/0xd40\n[   33.034022][ T1896]  ? wiphy_new_nm+0x1476/0x1d50\n[   33.034383][ T1896]  ? kmemdup+0x30/0x40\n[   33.034722][ T1896]  brcmf_usb_probe+0x12de/0x1690\n[   33.035223][ T1896]  ? brcmf_usbdev_qinit.constprop.0+0x470/0x470\n[   33.035833][ T1896]  usb_probe_interface+0x25f/0x710\n[   33.036315][ T1896]  really_probe+0x1be/0xa90\n[   33.036656][ T1896]  __driver_probe_device+0x2ab/0x460\n[   33.037026][ T1896]  ? usb_match_id.part.0+0x88/0xc0\n[   33.037383][ T1896]  driver_probe_device+0x49/0x120\n[   33.037790][ T1896]  __device_attach_driver+0x18a/0x250\n[   33.038300][ T1896]  ? driver_allows_async_probing+0x120/0x120\n[   33.038986][ T1896]  bus_for_each_drv+0x123/0x1a0\n[   33.039906][ T1896]  ? bus_rescan_devices+0x20/0x20\n[   33.041412][ T1896]  ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n[   33.041861][ T1896]  ? trace_hardirqs_on+0x1c/0x120\n[   33.042330][ T1896]  __device_attach+0x207/0x330\n[   33.042664][ T1896]  ? device_bind_driver+0xb0/0xb0\n[   33.043026][ T1896]  ? kobject_uevent_env+0x230/0x12c0\n[   33.043515][ T1896]  bus_probe_device+0x1a2/0x260\n[   33.043914][ T1896]  device_add+0xa61/0x1ce0\n[   33.044227][ T1896]  ? __mutex_unlock_slowpath+0xe7/0x660\n[   33.044891][ T1896]  ? __fw_devlink_link_to_suppliers+0x550/0x550\n[   33.045531][ T1896]  usb_set_configuration+0x984/0x1770\n[   33.046051][ T1896]  ? kernfs_create_link+0x175/0x230\n[   33.046548][ T1896]  usb_generic_driver_probe+0x69/0x90\n[   33.046931][ T1896]  usb_probe_device+0x9c/0x220\n[   33.047434][ T1896]  really_probe+0x1be/0xa90\n[   33.047760][ T1896]  __driver_probe_device+0x2ab/0x460\n[   33.048134][ T1896]  driver_probe_device+0x49/0x120\n[   33.048516][ T1896]  __device_attach_driver+0x18a/0x250\n[   33.048910][ T1896]  ? driver_allows_async_probing+0x120/0x120\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53587",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nring-buffer: Sync IRQ works before buffer destruction\n\nIf something was written to the buffer just before destruction,\nit may be possible (maybe not in a real system, but it did\nhappen in ARCH=um with time-travel) to destroy the ringbuffer\nbefore the IRQ work ran, leading this KASAN report (or a crash\nwithout KASAN):\n\n    BUG: KASAN: slab-use-after-free in irq_work_run_list+0x11a/0x13a\n    Read of size 8 at addr 000000006d640a48 by task swapper/0\n\n    CPU: 0 PID: 0 Comm: swapper Tainted: G        W  O       6.3.0-rc1 #7\n    Stack:\n     60c4f20f 0c203d48 41b58ab3 60f224fc\n     600477fa 60f35687 60c4f20f 601273dd\n     00000008 6101eb00 6101eab0 615be548\n    Call Trace:\n     [\u003c60047a58\u003e] show_stack+0x25e/0x282\n     [\u003c60c609e0\u003e] dump_stack_lvl+0x96/0xfd\n     [\u003c60c50d4c\u003e] print_report+0x1a7/0x5a8\n     [\u003c603078d3\u003e] kasan_report+0xc1/0xe9\n     [\u003c60308950\u003e] __asan_report_load8_noabort+0x1b/0x1d\n     [\u003c60232844\u003e] irq_work_run_list+0x11a/0x13a\n     [\u003c602328b4\u003e] irq_work_tick+0x24/0x34\n     [\u003c6017f9dc\u003e] update_process_times+0x162/0x196\n     [\u003c6019f335\u003e] tick_sched_handle+0x1a4/0x1c3\n     [\u003c6019fd9e\u003e] tick_sched_timer+0x79/0x10c\n     [\u003c601812b9\u003e] __hrtimer_run_queues.constprop.0+0x425/0x695\n     [\u003c60182913\u003e] hrtimer_interrupt+0x16c/0x2c4\n     [\u003c600486a3\u003e] um_timer+0x164/0x183\n     [...]\n\n    Allocated by task 411:\n     save_stack_trace+0x99/0xb5\n     stack_trace_save+0x81/0x9b\n     kasan_save_stack+0x2d/0x54\n     kasan_set_track+0x34/0x3e\n     kasan_save_alloc_info+0x25/0x28\n     ____kasan_kmalloc+0x8b/0x97\n     __kasan_kmalloc+0x10/0x12\n     __kmalloc+0xb2/0xe8\n     load_elf_phdrs+0xee/0x182\n     [...]\n\n    The buggy address belongs to the object at 000000006d640800\n     which belongs to the cache kmalloc-1k of size 1024\n    The buggy address is located 584 bytes inside of\n     freed 1024-byte region [000000006d640800, 000000006d640c00)\n\nAdd the appropriate irq_work_sync() so the work finishes before\nthe buffers are destroyed.\n\nPrior to the commit in the Fixes tag below, there was only a\nsingle global IRQ work, so this issue didn't exist.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53589",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: don't trust firmware n_channels\n\nIf the firmware sends us a corrupted MCC response with\nn_channels much larger than the command response can be,\nwe might copy far too much (uninitialized) memory and\neven crash if the n_channels is large enough to make it\nrun out of the one page allocated for the FW response.\n\nFix that by checking the lengths. Doing a \u003c comparison\nwould be sufficient, but the firmware should be doing\nit correctly, so check more strictly.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53593",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Release folio lock on fscache read hit.\n\nUnder the current code, when cifs_readpage_worker is called, the call\ncontract is that the callee should unlock the page. This is documented\nin the read_folio section of Documentation/filesystems/vfs.rst as:\n\n\u003e The filesystem should unlock the folio once the read has completed,\n\u003e whether it was successful or not.\n\nWithout this change, when fscache is in use and cache hit occurs during\na read, the page lock is leaked, producing the following stack on\nsubsequent reads (via mmap) to the page:\n\n$ cat /proc/3890/task/12864/stack\n[\u003c0\u003e] folio_wait_bit_common+0x124/0x350\n[\u003c0\u003e] filemap_read_folio+0xad/0xf0\n[\u003c0\u003e] filemap_fault+0x8b1/0xab0\n[\u003c0\u003e] __do_fault+0x39/0x150\n[\u003c0\u003e] do_fault+0x25c/0x3e0\n[\u003c0\u003e] __handle_mm_fault+0x6ca/0xc70\n[\u003c0\u003e] handle_mm_fault+0xe9/0x350\n[\u003c0\u003e] do_user_addr_fault+0x225/0x6c0\n[\u003c0\u003e] exc_page_fault+0x84/0x1b0\n[\u003c0\u003e] asm_exc_page_fault+0x27/0x30\n\nThis requires a reboot to resolve; it is a deadlock.\n\nNote however that the call to cifs_readpage_from_fscache does mark the\npage clean, but does not free the folio lock. This happens in\n__cifs_readpage_from_fscache on success. Releasing the lock at that\npoint however is not appropriate as cifs_readahead also calls\ncifs_readpage_from_fscache and *does* unconditionally release the lock\nafter its return. This change therefore effectively makes\ncifs_readpage_worker work like cifs_readahead.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53594",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: fix resource leak in device_add()\n\nWhen calling kobject_add() failed in device_add(), it will call\ncleanup_glue_dir() to free resource. But in kobject_add(),\ndev-\u003ekobj.parent has been set to NULL. This will cause resource leak.\n\nThe process is as follows:\ndevice_add()\n\tget_device_parent()\n\t\tclass_dir_create_and_add()\n\t\t\tkobject_add()\t\t//kobject_get()\n\t...\n\tdev-\u003ekobj.parent = kobj;\n\t...\n\tkobject_add()\t\t//failed, but set dev-\u003ekobj.parent = NULL\n\t...\n\tglue_dir = get_glue_dir(dev)\t//glue_dir = NULL, and goto\n\t\t\t\t\t//\"Error\" label\n\t...\n\tcleanup_glue_dir()\t//becaues glue_dir is NULL, not call\n\t\t\t\t//kobject_put()\n\nThe preceding problem may cause insmod mac80211_hwsim.ko to failed.\nsysfs: cannot create duplicate filename '/devices/virtual/mac80211_hwsim'\nCall Trace:\n\u003cTASK\u003e\ndump_stack_lvl+0x8e/0xd1\nsysfs_warn_dup.cold+0x1c/0x29\nsysfs_create_dir_ns+0x224/0x280\nkobject_add_internal+0x2aa/0x880\nkobject_add+0x135/0x1a0\nget_device_parent+0x3d7/0x590\ndevice_add+0x2aa/0x1cb0\ndevice_create_groups_vargs+0x1eb/0x260\ndevice_create+0xdc/0x110\nmac80211_hwsim_new_radio+0x31e/0x4790 [mac80211_hwsim]\ninit_mac80211_hwsim+0x48d/0x1000 [mac80211_hwsim]\ndo_one_initcall+0x10f/0x630\ndo_init_module+0x19f/0x5e0\nload_module+0x64b7/0x6eb0\n__do_sys_finit_module+0x140/0x200\ndo_syscall_64+0x35/0x80\nentry_SYSCALL_64_after_hwframe+0x46/0xb0\n\u003c/TASK\u003e\nkobject_add_internal failed for mac80211_hwsim with -EEXIST, don't try to\nregister things with the same name in the same directory.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53596",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: base: Free devm resources when unregistering a device\n\nIn the current code, devres_release_all() only gets called if the device\nhas a bus and has been probed.\n\nThis leads to issues when using bus-less or driver-less devices where\nthe device might never get freed if a managed resource holds a reference\nto the device. This is happening in the DRM framework for example.\n\nWe should thus call devres_release_all() in the device_del() function to\nmake sure that the device-managed actions are properly executed when the\ndevice is unregistered, even if it has neither a bus nor a driver.\n\nThis is effectively the same change than commit 2f8d16a996da (\"devres:\nrelease resources on device_del()\") that got reverted by commit\na525a3ddeaca (\"driver core: free devres in device_release\") over\nmemory leaks concerns.\n\nThis patch effectively combines the two commits mentioned above to\nrelease the resources both on device_del() and device_release() and get\nthe best of both worlds.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53597",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix mid leak during reconnection after timeout threshold\n\nWhen the number of responses with status of STATUS_IO_TIMEOUT\nexceeds a specified threshold (NUM_STATUS_IO_TIMEOUT), we reconnect\nthe connection. But we do not return the mid, or the credits\nreturned for the mid, or reduce the number of in-flight requests.\n\nThis bug could result in the server-\u003ein_flight count to go bad,\nand also cause a leak in the mids.\n\nThis change moves the check to a few lines below where the\nresponse is decrypted, even of the response is read from the\ntransform header. This way, the code for returning the mids\ncan be reused.\n\nAlso, the cifs_reconnect was reconnecting just the transport\nconnection before. In case of multi-channel, this may not be\nwhat we want to do after several timeouts. Changed that to\nreconnect the session and the tree too.\n\nAlso renamed NUM_STATUS_IO_TIMEOUT to a more appropriate name\nMAX_STATUS_IO_TIMEOUT.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53603",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Avoid fcport pointer dereference\n\nKlocwork reported warning of NULL pointer may be dereferenced.  The routine\nexits when sa_ctl is NULL and fcport is allocated after the exit call thus\ncausing NULL fcport pointer to dereference at the time of exit.\n\nTo avoid fcport pointer dereference, exit the routine when sa_ctl is NULL.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53604",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm integrity: call kmem_cache_destroy() in dm_integrity_init() error path\n\nOtherwise the journal_io_cache will leak if dm_register_target() fails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53611",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipmi_si: fix a memleak in try_smi_init()\n\nKmemleak reported the following leak info in try_smi_init():\n\nunreferenced object 0xffff00018ecf9400 (size 1024):\n  comm \"modprobe\", pid 2707763, jiffies 4300851415 (age 773.308s)\n  backtrace:\n    [\u003c000000004ca5b312\u003e] __kmalloc+0x4b8/0x7b0\n    [\u003c00000000953b1072\u003e] try_smi_init+0x148/0x5dc [ipmi_si]\n    [\u003c000000006460d325\u003e] 0xffff800081b10148\n    [\u003c0000000039206ea5\u003e] do_one_initcall+0x64/0x2a4\n    [\u003c00000000601399ce\u003e] do_init_module+0x50/0x300\n    [\u003c000000003c12ba3c\u003e] load_module+0x7a8/0x9e0\n    [\u003c00000000c246fffe\u003e] __se_sys_init_module+0x104/0x180\n    [\u003c00000000eea99093\u003e] __arm64_sys_init_module+0x24/0x30\n    [\u003c0000000021b1ef87\u003e] el0_svc_common.constprop.0+0x94/0x250\n    [\u003c0000000070f4f8b7\u003e] do_el0_svc+0x48/0xe0\n    [\u003c000000005a05337f\u003e] el0_svc+0x24/0x3c\n    [\u003c000000005eb248d6\u003e] el0_sync_handler+0x160/0x164\n    [\u003c0000000030a59039\u003e] el0_sync+0x160/0x180\n\nThe problem was that when an error occurred before handlers registration\nand after allocating `new_smi-\u003esi_sm`, the variable wouldn't be freed in\nthe error handling afterwards since `shutdown_smi()` hadn't been\nregistered yet. Fix it by adding a `kfree()` in the error handling path\nin `try_smi_init()`.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53615",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix deletion race condition\n\nSystem crash when using debug kernel due to link list corruption. The cause\nof the link list corruption is due to session deletion was allowed to queue\nup twice.  Here's the internal trace that show the same port was allowed to\ndouble queue for deletion on different cpu.\n\n20808683956 015 qla2xxx [0000:13:00.1]-e801:4: Scheduling sess ffff93ebf9306800 for deletion 50:06:0e:80:12:48:ff:50 fc4_type 1\n20808683957 027 qla2xxx [0000:13:00.1]-e801:4: Scheduling sess ffff93ebf9306800 for deletion 50:06:0e:80:12:48:ff:50 fc4_type 1\n\nMove the clearing/setting of deleted flag lock.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53619",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: conntrack: Avoid nf_ct_helper_hash uses after free\n\nIf nf_conntrack_init_start() fails (for example due to a\nregister_nf_conntrack_bpf() failure), the nf_conntrack_helper_fini()\nclean-up path frees the nf_ct_helper_hash map.\n\nWhen built with NF_CONNTRACK=y, further netfilter modules (e.g:\nnetfilter_conntrack_ftp) can still be loaded and call\nnf_conntrack_helpers_register(), independently of whether nf_conntrack\ninitialized correctly. This accesses the nf_ct_helper_hash dangling\npointer and causes a uaf, possibly leading to random memory corruption.\n\nThis patch guards nf_conntrack_helper_register() from accessing a freed\nor uninitialized nf_ct_helper_hash pointer and fixes possible\nuses-after-free when loading a conntrack module.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53620",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: fix soft lockup in status_resync\n\nstatus_resync() will calculate 'curr_resync - recovery_active' to show\nuser a progress bar like following:\n\n[============\u003e........]  resync = 61.4%\n\n'curr_resync' and 'recovery_active' is updated in md_do_sync(), and\nstatus_resync() can read them concurrently, hence it's possible that\n'curr_resync - recovery_active' can overflow to a huge number. In this\ncase status_resync() will be stuck in the loop to print a large amount\nof '=', which will end up soft lockup.\n\nFix the problem by setting 'resync' to MD_RESYNC_ACTIVE in this case,\nthis way resync in progress will be reported to user.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53622",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix possible data races in gfs2_show_options()\n\nSome fields such as gt_logd_secs of the struct gfs2_tune are accessed\nwithout holding the lock gt_spin in gfs2_show_options():\n\n  val = sdp-\u003esd_tune.gt_logd_secs;\n  if (val != 30)\n    seq_printf(s, \",commit=%d\", val);\n\nAnd thus can cause data races when gfs2_show_options() and other functions\nsuch as gfs2_reconfigure() are concurrently executed:\n\n  spin_lock(\u0026gt-\u003egt_spin);\n  gt-\u003egt_logd_secs = newargs-\u003ear_commit;\n\nTo fix these possible data races, the lock sdp-\u003esd_tune.gt_spin is\nacquired before accessing the fields of gfs2_tune and released after these\naccesses.\n\nFurther changes by Andreas:\n\n- Don't hold the spin lock over the seq_printf operations.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53624",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_fq: fix integer overflow of \"credit\"\n\nif sch_fq is configured with \"initial quantum\" having values greater than\nINT_MAX, the first assignment of \"credit\" does signed integer overflow to\na very negative value.\nIn this situation, the syzkaller script provided by Cristoph triggers the\nCPU soft-lockup warning even with few sockets. It's not an infinite loop,\nbut \"credit\" wasn't probably meant to be minus 2Gb for each new flow.\nCapping \"initial quantum\" to INT_MAX proved to fix the issue.\n\nv2: validation of \"initial quantum\" is done in fq_policy, instead of open\n    coding in fq_change() _ suggested by Jakub Kicinski",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53635",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: conntrack: fix wrong ct-\u003etimeout value\n\n(struct nf_conn)-\u003etimeout is an interval before the conntrack\nconfirmed.  After confirmed, it becomes a timestamp.\n\nIt is observed that timeout of an unconfirmed conntrack:\n- Set by calling ctnetlink_change_timeout(). As a result,\n  `nfct_time_stamp` was wrongly added to `ct-\u003etimeout` twice.\n- Get by calling ctnetlink_dump_timeout(). As a result,\n  `nfct_time_stamp` was wrongly subtracted.\n\nCall Trace:\n \u003cTASK\u003e\n dump_stack_lvl\n ctnetlink_dump_timeout\n __ctnetlink_glue_build\n ctnetlink_glue_build\n __nfqnl_enqueue_packet\n nf_queue\n nf_hook_slow\n ip_mc_output\n ? __pfx_ip_finish_output\n ip_send_skb\n ? __pfx_dst_output\n udp_send_skb\n udp_sendmsg\n ? __pfx_ip_generic_getfrag\n sock_sendmsg\n\nSeparate the 2 cases in:\n- Setting `ct-\u003etimeout` in __nf_ct_set_timeout().\n- Getting `ct-\u003etimeout` in ctnetlink_dump_timeout().\n\nPablo appends:\n\nUpdate ctnetlink to set up the timeout _after_ the IPS_CONFIRMED flag is\nset on, otherwise conntrack creation via ctnetlink breaks.\n\nNote that the problem described in this patch occurs since the\nintroduction of the nfnetlink_queue conntrack support, select a\nsufficiently old Fixes: tag for -stable kernel to pick up this fix.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53641",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: hif_usb: fix memory leak of remain_skbs\n\nhif_dev-\u003eremain_skb is allocated and used exclusively in\nath9k_hif_usb_rx_stream(). It is implied that an allocated remain_skb is\nprocessed and subsequently freed (in error paths) only during the next\ncall of ath9k_hif_usb_rx_stream().\n\nSo, if the urbs are deallocated between those two calls due to the device\ndeinitialization or suspend, it is possible that ath9k_hif_usb_rx_stream()\nis not called next time and the allocated remain_skb is leaked. Our local\nSyzkaller instance was able to trigger that.\n\nremain_skb makes sense when receiving two consecutive urbs which are\nlogically linked together, i.e. a specific data field from the first skb\nindicates a cached skb to be allocated, memcpy'd with some data and\nsubsequently processed in the next call to ath9k_hif_usb_rx_stream(). Urbs\ndeallocation supposedly makes that link irrelevant so we need to free the\ncached skb in those cases.\n\nFix the leak by introducing a function to explicitly free remain_skb (if\nit is not NULL) when the rx urbs have been deallocated. remain_skb is NULL\nwhen it has not been allocated at all (hif_dev struct is kzalloced) or\nwhen it has been processed in next call to ath9k_hif_usb_rx_stream().\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53644",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: radio-shark: Add endpoint checks\n\nThe syzbot fuzzer was able to provoke a WARNING from the radio-shark2\ndriver:\n\n------------[ cut here ]------------\nusb 1-1: BOGUS urb xfer, pipe 1 != type 3\nWARNING: CPU: 0 PID: 3271 at drivers/usb/core/urb.c:504 usb_submit_urb+0xed2/0x1880 drivers/usb/core/urb.c:504\nModules linked in:\nCPU: 0 PID: 3271 Comm: kworker/0:3 Not tainted 6.1.0-rc4-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nWorkqueue: usb_hub_wq hub_event\nRIP: 0010:usb_submit_urb+0xed2/0x1880 drivers/usb/core/urb.c:504\nCode: 7c 24 18 e8 00 36 ea fb 48 8b 7c 24 18 e8 36 1c 02 ff 41 89 d8 44 89 e1 4c 89 ea 48 89 c6 48 c7 c7 a0 b6 90 8a e8 9a 29 b8 03 \u003c0f\u003e 0b e9 58 f8 ff ff e8 d2 35 ea fb 48 81 c5 c0 05 00 00 e9 84 f7\nRSP: 0018:ffffc90003876dd0 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000003 RCX: 0000000000000000\nRDX: ffff8880750b0040 RSI: ffffffff816152b8 RDI: fffff5200070edac\nRBP: ffff8880172d81e0 R08: 0000000000000005 R09: 0000000000000000\nR10: 0000000080000000 R11: 0000000000000000 R12: 0000000000000001\nR13: ffff8880285c5040 R14: 0000000000000002 R15: ffff888017158200\nFS:  0000000000000000(0000) GS:ffff8880b9a00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffe03235b90 CR3: 000000000bc8e000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n \u003cTASK\u003e\n usb_start_wait_urb+0x101/0x4b0 drivers/usb/core/message.c:58\n usb_bulk_msg+0x226/0x550 drivers/usb/core/message.c:387\n shark_write_reg+0x1ff/0x2e0 drivers/media/radio/radio-shark2.c:88\n...\n\nThe problem was caused by the fact that the driver does not check\nwhether the endpoints it uses are actually present and have the\nappropriate types.  This can be fixed by adding a simple check of\nthese endpoints (and similarly for the radio-shark driver).",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53647",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nDrivers: hv: vmbus: Don't dereference ACPI root object handle\n\nSince the commit referenced in the Fixes: tag below the VMBus client driver\nis walking the ACPI namespace up from the VMBus ACPI device to the ACPI\nnamespace root object trying to find Hyper-V MMIO ranges.\n\nHowever, if it is not able to find them it ends trying to walk resources of\nthe ACPI namespace root object itself.\nThis object has all-ones handle, which causes a NULL pointer dereference\nin the ACPI code (from dereferencing this pointer with an offset).\n\nThis in turn causes an oops on boot with VMBus host implementations that do\nnot provide Hyper-V MMIO ranges in their VMBus ACPI device or its\nancestors.\nThe QEMU VMBus implementation is an example of such implementation.\n\nI guess providing these ranges is optional, since all tested Windows\nversions seem to be able to use VMBus devices without them.\n\nFix this by explicitly terminating the lookup at the ACPI namespace root\nobject.\n\nNote that Linux guests under KVM/QEMU do not use the Hyper-V PV interface\nby default - they only do so if the KVM PV interface is missing or\ndisabled.\n\nExample stack trace of such oops:\n[ 3.710827] ? __die+0x1f/0x60\n[ 3.715030] ? page_fault_oops+0x159/0x460\n[ 3.716008] ? exc_page_fault+0x73/0x170\n[ 3.716959] ? asm_exc_page_fault+0x22/0x30\n[ 3.717957] ? acpi_ns_lookup+0x7a/0x4b0\n[ 3.718898] ? acpi_ns_internalize_name+0x79/0xc0\n[ 3.720018] acpi_ns_get_node_unlocked+0xb5/0xe0\n[ 3.721120] ? acpi_ns_check_object_type+0xfe/0x200\n[ 3.722285] ? acpi_rs_convert_aml_to_resource+0x37/0x6e0\n[ 3.723559] ? down_timeout+0x3a/0x60\n[ 3.724455] ? acpi_ns_get_node+0x3a/0x60\n[ 3.725412] acpi_ns_get_node+0x3a/0x60\n[ 3.726335] acpi_ns_evaluate+0x1c3/0x2c0\n[ 3.727295] acpi_ut_evaluate_object+0x64/0x1b0\n[ 3.728400] acpi_rs_get_method_data+0x2b/0x70\n[ 3.729476] ? vmbus_platform_driver_probe+0x1d0/0x1d0 [hv_vmbus]\n[ 3.730940] ? vmbus_platform_driver_probe+0x1d0/0x1d0 [hv_vmbus]\n[ 3.732411] acpi_walk_resources+0x78/0xd0\n[ 3.733398] vmbus_platform_driver_probe+0x9f/0x1d0 [hv_vmbus]\n[ 3.734802] platform_probe+0x3d/0x90\n[ 3.735684] really_probe+0x19b/0x400\n[ 3.736570] ? __device_attach_driver+0x100/0x100\n[ 3.737697] __driver_probe_device+0x78/0x160\n[ 3.738746] driver_probe_device+0x1f/0x90\n[ 3.739743] __driver_attach+0xc2/0x1b0\n[ 3.740671] bus_for_each_dev+0x70/0xc0\n[ 3.741601] bus_add_driver+0x10e/0x210\n[ 3.742527] driver_register+0x55/0xf0\n[ 3.744412] ? 0xffffffffc039a000\n[ 3.745207] hv_acpi_init+0x3c/0x1000 [hv_vmbus]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53648",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: ac97: Fix possible NULL dereference in snd_ac97_mixer\n\nsmatch error:\nsound/pci/ac97/ac97_codec.c:2354 snd_ac97_mixer() error:\nwe previously assumed 'rac97' could be null (see line 2072)\n\nremove redundant assignment, return error if rac97 is NULL.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53650",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: omapfb: lcd_mipid: Fix an error handling path in mipid_spi_probe()\n\nIf 'mipid_detect()' fails, we must free 'md' to avoid a memory leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53667",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: cdc_ncm: Deal with too low values of dwNtbOutMaxSize\n\nCurrently in cdc_ncm_check_tx_max(), if dwNtbOutMaxSize is lower than\nthe calculated \"min\" value, but greater than zero, the logic sets\ntx_max to dwNtbOutMaxSize. This is then used to allocate a new SKB in\ncdc_ncm_fill_tx_frame() where all the data is handled.\n\nFor small values of dwNtbOutMaxSize the memory allocated during\nalloc_skb(dwNtbOutMaxSize, GFP_ATOMIC) will have the same size, due to\nhow size is aligned at alloc time:\n\tsize = SKB_DATA_ALIGN(size);\n        size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\nThus we hit the same bug that we tried to squash with\ncommit 2be6d4d16a084 (\"net: cdc_ncm: Allow for dwNtbOutMaxSize to be unset or zero\")\n\nLow values of dwNtbOutMaxSize do not cause an issue presently because at\nalloc_skb() time more memory (512b) is allocated than required for the\nSKB headers alone (320b), leaving some space (512b - 320b = 192b)\nfor CDC data (172b).\n\nHowever, if more elements (for example 3 x u64 = [24b]) were added to\none of the SKB header structs, say 'struct skb_shared_info',\nincreasing its original size (320b [320b aligned]) to something larger\n(344b [384b aligned]), then suddenly the CDC data (172b) no longer\nfits in the spare SKB data area (512b - 384b = 128b).\n\nConsequently the SKB bounds checking semantics fails and panics:\n\nskbuff: skb_over_panic: text:ffffffff831f755b len:184 put:172 head:ffff88811f1c6c00 data:ffff88811f1c6c00 tail:0xb8 end:0x80 dev:\u003cNULL\u003e\n------------[ cut here ]------------\nkernel BUG at net/core/skbuff.c:113!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\nCPU: 0 PID: 57 Comm: kworker/0:2 Not tainted 5.15.106-syzkaller-00249-g19c0ed55a470 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/14/2023\nWorkqueue: mld mld_ifc_work\nRIP: 0010:skb_panic net/core/skbuff.c:113 [inline]\nRIP: 0010:skb_over_panic+0x14c/0x150 net/core/skbuff.c:118\n[snip]\nCall Trace:\n \u003cTASK\u003e\n skb_put+0x151/0x210 net/core/skbuff.c:2047\n skb_put_zero include/linux/skbuff.h:2422 [inline]\n cdc_ncm_ndp16 drivers/net/usb/cdc_ncm.c:1131 [inline]\n cdc_ncm_fill_tx_frame+0x11ab/0x3da0 drivers/net/usb/cdc_ncm.c:1308\n cdc_ncm_tx_fixup+0xa3/0x100\n\nDeal with too low values of dwNtbOutMaxSize, clamp it in the range\n[USB_CDC_NCM_NTB_MIN_OUT_SIZE, CDC_NCM_NTB_MAX_SIZE_TX]. We ensure\nenough data space is allocated to handle CDC data by making sure\ndwNtbOutMaxSize is not smaller than USB_CDC_NCM_NTB_MIN_OUT_SIZE.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53668",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nring-buffer: Fix deadloop issue on reading trace_pipe\n\nSoft lockup occurs when reading file 'trace_pipe':\n\n  watchdog: BUG: soft lockup - CPU#6 stuck for 22s! [cat:4488]\n  [...]\n  RIP: 0010:ring_buffer_empty_cpu+0xed/0x170\n  RSP: 0018:ffff88810dd6fc48 EFLAGS: 00000246\n  RAX: 0000000000000000 RBX: 0000000000000246 RCX: ffffffff93d1aaeb\n  RDX: ffff88810a280040 RSI: 0000000000000008 RDI: ffff88811164b218\n  RBP: ffff88811164b218 R08: 0000000000000000 R09: ffff88815156600f\n  R10: ffffed102a2acc01 R11: 0000000000000001 R12: 0000000051651901\n  R13: 0000000000000000 R14: ffff888115e49500 R15: 0000000000000000\n  [...]\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f8d853c2000 CR3: 000000010dcd8000 CR4: 00000000000006e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   __find_next_entry+0x1a8/0x4b0\n   ? peek_next_entry+0x250/0x250\n   ? down_write+0xa5/0x120\n   ? down_write_killable+0x130/0x130\n   trace_find_next_entry_inc+0x3b/0x1d0\n   tracing_read_pipe+0x423/0xae0\n   ? tracing_splice_read_pipe+0xcb0/0xcb0\n   vfs_read+0x16b/0x490\n   ksys_read+0x105/0x210\n   ? __ia32_sys_pwrite64+0x200/0x200\n   ? switch_fpu_return+0x108/0x220\n   do_syscall_64+0x33/0x40\n   entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nThrough the vmcore, I found it's because in tracing_read_pipe(),\nring_buffer_empty_cpu() found some buffer is not empty but then it\ncannot read anything due to \"rb_num_of_entries() == 0\" always true,\nThen it infinitely loop the procedure due to user buffer not been\nfilled, see following code path:\n\n  tracing_read_pipe() {\n    ... ...\n    waitagain:\n      tracing_wait_pipe() // 1. find non-empty buffer here\n      trace_find_next_entry_inc()  // 2. loop here try to find an entry\n        __find_next_entry()\n          ring_buffer_empty_cpu();  // 3. find non-empty buffer\n          peek_next_entry()  // 4. but peek always return NULL\n            ring_buffer_peek()\n              rb_buffer_peek()\n                rb_get_reader_page()\n                  // 5. because rb_num_of_entries() == 0 always true here\n                  //    then return NULL\n      // 6. user buffer not been filled so goto 'waitgain'\n      //    and eventually leads to an deadloop in kernel!!!\n  }\n\nBy some analyzing, I found that when resetting ringbuffer, the 'entries'\nof its pages are not all cleared (see rb_reset_cpu()). Then when reducing\nthe ringbuffer, and if some reduced pages exist dirty 'entries' data, they\nwill be added into 'cpu_buffer-\u003eoverrun' (see rb_remove_pages()), which\ncause wrong 'overrun' count and eventually cause the deadloop issue.\n\nTo fix it, we need to clear every pages in rb_reset_cpu().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53672",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: output extra debug info if we failed to find an inline backref\n\n[BUG]\nSyzbot reported several warning triggered inside\nlookup_inline_extent_backref().\n\n[CAUSE]\nAs usual, the reproducer doesn't reliably trigger locally here, but at\nleast we know the WARN_ON() is triggered when an inline backref can not\nbe found, and it can only be triggered when @insert is true. (I.e.\ninserting a new inline backref, which means the backref should already\nexist)\n\n[ENHANCEMENT]\nAfter the WARN_ON(), dump all the parameters and the extent tree\nleaf to help debug.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53675",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Fix possible desc_ptr out-of-bounds accesses\n\nSanitize possible desc_ptr out-of-bounds accesses in\nses_enclosure_data_process().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53676",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: iscsi: Fix buffer overflow in lio_target_nacl_info_show()\n\nThe function lio_target_nacl_info_show() uses sprintf() in a loop to print\ndetails for every iSCSI connection in a session without checking for the\nbuffer length. With enough iSCSI connections it's possible to overflow the\nbuffer provided by configfs and corrupt the memory.\n\nThis patch replaces sprintf() with sysfs_emit_at() that checks for buffer\nboundries.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53681",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbcache: Fix __bch_btree_node_alloc to make the failure behavior consistent\n\nIn some specific situations, the return value of __bch_btree_node_alloc\nmay be NULL. This may lead to a potential NULL pointer dereference in\ncaller function like a calling chain :\nbtree_split-\u003ebch_btree_node_alloc-\u003e__bch_btree_node_alloc.\n\nFix it by initializing the return value in __bch_btree_node_alloc.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53683",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: hfsplus: remove WARN_ON() from hfsplus_cat_{read,write}_inode()\n\nsyzbot is hitting WARN_ON() in hfsplus_cat_{read,write}_inode(), for\ncrafted filesystem image can contain bogus length. There conditions are\nnot kernel bugs that can justify kernel to panic.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53687",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: serial: samsung_tty: Fix a memory leak in s3c24xx_serial_getclk() when iterating clk\n\nWhen the best clk is searched, we iterate over all possible clk.\n\nIf we find a better match, the previous one, if any, needs to be freed.\nIf a better match has already been found, we still need to free the new\none, otherwise it leaks.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53695",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Detect system inodes linked into directory hierarchy\n\nWhen UDF filesystem is corrupted, hidden system inodes can be linked\ninto directory hierarchy which is an avenue for further serious\ncorruption of the filesystem and kernel confusion as noticed by syzbot\nfuzzed images. Refuse to access system inodes linked into directory\nhierarchy and vice versa.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53696",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix memory leak in qla2x00_probe_one()\n\nThere is a memory leak reported by kmemleak:\n\n  unreferenced object 0xffffc900003f0000 (size 12288):\n    comm \"modprobe\", pid 19117, jiffies 4299751452 (age 42490.264s)\n    hex dump (first 32 bytes):\n      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    backtrace:\n      [\u003c00000000629261a8\u003e] __vmalloc_node_range+0xe56/0x1110\n      [\u003c0000000001906886\u003e] __vmalloc_node+0xbd/0x150\n      [\u003c000000005bb4dc34\u003e] vmalloc+0x25/0x30\n      [\u003c00000000a2dc1194\u003e] qla2x00_create_host+0x7a0/0xe30 [qla2xxx]\n      [\u003c0000000062b14b47\u003e] qla2x00_probe_one+0x2eb8/0xd160 [qla2xxx]\n      [\u003c00000000641ccc04\u003e] local_pci_probe+0xeb/0x1a0\n\nThe root cause is traced to an error-handling path in qla2x00_probe_one()\nwhen the adapter \"base_vha\" initialize failed. The fab_scan_rp \"scan.l\" is\nused to record the port information and it is allocated in\nqla2x00_create_host(). However, it is not released in the error handling\npath \"probe_failed\".\n\nFix this by freeing the memory of \"scan.l\" when an error occurs in the\nadapter initialization process.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53705",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix out-of-bounds access in ipv6_find_tlv()\n\noptlen is fetched without checking whether there is more than one byte to parse.\nIt can lead to out-of-bounds access.\n\nFound by InfoTeCS on behalf of Linux Verification Center\n(linuxtesting.org) with SVACE.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53707",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix integer overflow in amdgpu_cs_pass1\n\nThe type of size is unsigned int, if size is 0x40000000, there will\nbe an integer overflow, size will be zero after size *= sizeof(uint32_t),\nwill cause uninitialized memory to be referenced later.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53715",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: cfg80211: Pass the PMK in binary instead of hex\n\nApparently the hex passphrase mechanism does not work on newer\nchips/firmware (e.g. BCM4387). It seems there was a simple way of\npassing it in binary all along, so use that and avoid the hexification.\n\nOpenBSD has been doing it like this from the beginning, so this should\nwork on all chips.\n\nAlso clear the structure before setting the PMK. This was leaking\nuninitialized stack contents to the device.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53717",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: Fix potential stack-out-of-bounds write in ath9k_wmi_rsp_callback()\n\nFix a stack-out-of-bounds write that occurs in a WMI response callback\nfunction that is called after a timeout occurs in ath9k_wmi_cmd().\nThe callback writes to wmi-\u003ecmd_rsp_buf, a stack-allocated buffer that\ncould no longer be valid when a timeout occurs. Set wmi-\u003elast_seq_id to\n0 when a timeout occurred.\n\nFound by a modified version of syzkaller.\n\nBUG: KASAN: stack-out-of-bounds in ath9k_wmi_ctrl_rx\nWrite of size 4\nCall Trace:\n memcpy\n ath9k_wmi_ctrl_rx\n ath9k_htc_rx_msg\n ath9k_hif_usb_reg_in_cb\n __usb_hcd_giveback_urb\n usb_hcd_giveback_urb\n dummy_timer\n call_timer_fn\n run_timer_softirq\n __do_softirq\n irq_exit_rcu\n sysvec_apic_timer_interrupt",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53722",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: raid1: fix potential OOB in raid1_remove_disk()\n\nIf rddev-\u003eraid_disk is greater than mddev-\u003eraid_disks, there will be\nan out-of-bounds in raid1_remove_disk(). We have already found\nsimilar reports as follows:\n\n1) commit d17f744e883b (\"md-raid10: fix KASAN warning\")\n2) commit 1ebc2cec0b7d (\"dm raid: fix KASAN warning in raid5_remove_disk\")\n\nFix this bug by checking whether the \"number\" variable is\nvalid.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-53733",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: cls_u32: Undo tcf_bind_filter if u32_replace_hw_knode\n\nWhen u32_replace_hw_knode fails, we need to undo the tcf_bind_filter\noperation done at u32_set_parms.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2023-7324",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Fix possible addl_desc_ptr out-of-bounds accesses\n\nSanitize possible addl_desc_ptr out-of-bounds accesses in\nses_enclosure_data_process().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2024-53194",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: Fix use-after-free of slot-\u003ebus on hot remove\n\nDennis reports a boot crash on recent Lenovo laptops with a USB4 dock.\n\nSince commit 0fc70886569c (\"thunderbolt: Reset USB4 v2 host router\") and\ncommit 59a54c5f3dbd (\"thunderbolt: Reset topology created by the boot\nfirmware\"), USB4 v2 and v1 Host Routers are reset on probe of the\nthunderbolt driver.\n\nThe reset clears the Presence Detect State and Data Link Layer Link Active\nbits at the USB4 Host Router's Root Port and thus causes hot removal of the\ndock.\n\nThe crash occurs when pciehp is unbound from one of the dock's Downstream\nPorts:  pciehp creates a pci_slot on bind and destroys it on unbind.  The\npci_slot contains a pointer to the pci_bus below the Downstream Port, but\na reference on that pci_bus is never acquired.  The pci_bus is destroyed\nbefore the pci_slot, so a use-after-free ensues when pci_slot_release()\naccesses slot-\u003ebus.\n\nIn principle this should not happen because pci_stop_bus_device() unbinds\npciehp (and therefore destroys the pci_slot) before the pci_bus is\ndestroyed by pci_remove_bus_device().\n\nHowever the stacktrace provided by Dennis shows that pciehp is unbound from\npci_remove_bus_device() instead of pci_stop_bus_device().  To understand\nthe significance of this, one needs to know that the PCI core uses a two\nstep process to remove a portion of the hierarchy:  It first unbinds all\ndrivers in the sub-hierarchy in pci_stop_bus_device() and then actually\nremoves the devices in pci_remove_bus_device().  There is no precaution to\nprevent driver binding in-between pci_stop_bus_device() and\npci_remove_bus_device().\n\nIn Dennis' case, it seems removal of the hierarchy by pciehp races with\ndriver binding by pci_bus_add_devices().  pciehp is bound to the\nDownstream Port after pci_stop_bus_device() has run, so it is unbound by\npci_remove_bus_device() instead of pci_stop_bus_device().  Because the\npci_bus has already been destroyed at that point, accesses to it result in\na use-after-free.\n\nOne might conclude that driver binding needs to be prevented after\npci_stop_bus_device() has run.  However it seems risky that pci_slot points\nto pci_bus without holding a reference.  Solely relying on correct ordering\nof driver unbind versus pci_bus destruction is certainly not defensive\nprogramming.\n\nIf pci_slot has a need to access data in pci_bus, it ought to acquire a\nreference.  Amend pci_create_slot() accordingly.  Dennis reports that the\ncrash is not reproducible with this change.\n\nAbridged stacktrace:\n\n  pcieport 0000:00:07.0: PME: Signaling with IRQ 156\n  pcieport 0000:00:07.0: pciehp: Slot #12 AttnBtn- PwrCtrl- MRL- AttnInd- PwrInd- HotPlug+ Surprise+ Interlock- NoCompl+ IbPresDis- LLActRep+\n  pci_bus 0000:20: dev 00, created physical slot 12\n  pcieport 0000:00:07.0: pciehp: Slot(12): Card not present\n  ...\n  pcieport 0000:21:02.0: pciehp: pcie_disable_notification: SLOTCTRL d8 write cmd 0\n  Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 13 UID: 0 PID: 134 Comm: irq/156-pciehp Not tainted 6.11.0-devel+ #1\n  RIP: 0010:dev_driver_string+0x12/0x40\n  pci_destroy_slot\n  pciehp_remove\n  pcie_port_remove_service\n  device_release_driver_internal\n  bus_remove_device\n  device_del\n  device_unregister\n  remove_iter\n  device_for_each_child\n  pcie_portdrv_remove\n  pci_device_remove\n  device_release_driver_internal\n  bus_remove_device\n  device_del\n  pci_remove_bus_device (recursive invocation)\n  pci_remove_bus_device\n  pciehp_unconfigure_device\n  pciehp_disable_slot\n  pciehp_handle_presence_or_link_change\n  pciehp_ist",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2024-56633",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_bpf: Fix the sk_mem_uncharge logic in tcp_bpf_sendmsg\n\nThe current sk memory accounting logic in __SK_REDIRECT is pre-uncharging\ntosend bytes, which is either msg-\u003esg.size or a smaller value apply_bytes.\n\nPotential problems with this strategy are as follows:\n\n- If the actual sent bytes are smaller than tosend, we need to charge some\n  bytes back, as in line 487, which is okay but seems not clean.\n\n- When tosend is set to apply_bytes, as in line 417, and (ret \u003c 0), we may\n  miss uncharging (msg-\u003esg.size - apply_bytes) bytes.\n\n[...]\n415 tosend = msg-\u003esg.size;\n416 if (psock-\u003eapply_bytes \u0026\u0026 psock-\u003eapply_bytes \u003c tosend)\n417   tosend = psock-\u003eapply_bytes;\n[...]\n443 sk_msg_return(sk, msg, tosend);\n444 release_sock(sk);\n446 origsize = msg-\u003esg.size;\n447 ret = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,\n448                             msg, tosend, flags);\n449 sent = origsize - msg-\u003esg.size;\n[...]\n454 lock_sock(sk);\n455 if (unlikely(ret \u003c 0)) {\n456   int free = sk_msg_free_nocharge(sk, msg);\n458   if (!cork)\n459     *copied -= free;\n460 }\n[...]\n487 if (eval == __SK_REDIRECT)\n488   sk_mem_charge(sk, tosend - sent);\n[...]\n\nWhen running the selftest test_txmsg_redir_wait_sndmem with txmsg_apply,\nthe following warning will be reported:\n\n------------[ cut here ]------------\nWARNING: CPU: 6 PID: 57 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x190/0x1a0\nModules linked in:\nCPU: 6 UID: 0 PID: 57 Comm: kworker/6:0 Not tainted 6.12.0-rc1.bm.1-amd64+ #43\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nWorkqueue: events sk_psock_destroy\nRIP: 0010:inet_sock_destruct+0x190/0x1a0\nRSP: 0018:ffffad0a8021fe08 EFLAGS: 00010206\nRAX: 0000000000000011 RBX: ffff9aab4475b900 RCX: ffff9aab481a0800\nRDX: 0000000000000303 RSI: 0000000000000011 RDI: ffff9aab4475b900\nRBP: ffff9aab4475b990 R08: 0000000000000000 R09: ffff9aab40050ec0\nR10: 0000000000000000 R11: ffff9aae6fdb1d01 R12: ffff9aab49c60400\nR13: ffff9aab49c60598 R14: ffff9aab49c60598 R15: dead000000000100\nFS:  0000000000000000(0000) GS:ffff9aae6fd80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffec7e47bd8 CR3: 00000001a1a1c004 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\n? __warn+0x89/0x130\n? inet_sock_destruct+0x190/0x1a0\n? report_bug+0xfc/0x1e0\n? handle_bug+0x5c/0xa0\n? exc_invalid_op+0x17/0x70\n? asm_exc_invalid_op+0x1a/0x20\n? inet_sock_destruct+0x190/0x1a0\n__sk_destruct+0x25/0x220\nsk_psock_destroy+0x2b2/0x310\nprocess_scheduled_works+0xa3/0x3e0\nworker_thread+0x117/0x240\n? __pfx_worker_thread+0x10/0x10\nkthread+0xcf/0x100\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x31/0x40\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n\u003c/TASK\u003e\n---[ end trace 0000000000000000 ]---\n\nIn __SK_REDIRECT, a more concise way is delaying the uncharging after sent\nbytes are finalized, and uncharge this value. When (ret \u003c 0), we shall\ninvoke sk_msg_free.\n\nSame thing happens in case __SK_DROP, when tosend is set to apply_bytes,\nwe may miss uncharging (msg-\u003esg.size - apply_bytes) bytes. The same\nwarning will be reported in selftest.\n\n[...]\n468 case __SK_DROP:\n469 default:\n470 sk_msg_free_partial(sk, msg, tosend);\n471 sk_msg_apply_bytes(psock, tosend);\n472 *copied -= (tosend + delta);\n473 return -EACCES;\n[...]\n\nSo instead of sk_msg_free_partial we can do sk_msg_free here.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2024-58240",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntls: separate no-async decryption request handling from async\n\nIf we're not doing async, the handling is much simpler. There's no\nreference counting, we just need to wait for the completion to wake us\nup and return its result.\n\nWe should preferably also use a separate crypto_wait. I'm not seeing a\nUAF as I did in the past, I think aec7961916f3 (\"tls: fix race between\nasync notify and socket close\") took care of it.\n\nThis will make the next fix easier.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2024-6232",
      "Description": "There is a MEDIUM severity vulnerability affecting CPython.\n\n\n\n\n\nRegular expressions that allowed excessive backtracking during tarfile.TarFile header parsing are vulnerable to ReDoS via specifically-crafted tar archives.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-10158",
      "Description": "A malicious client acting as the receiver of an rsync file transfer can trigger an out of bounds read of a heap based buffer, via a negative array index. The \n\nmalicious \n\nrsync client requires at least read access to the remote rsync module in order to trigger the issue.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-10230",
      "Description": "A flaw was found in Samba, in the front-end WINS hook handling: NetBIOS names from registration packets are passed to a shell without proper validation or escaping. Unsanitized NetBIOS name data from WINS registration packets are inserted into a shell command and executed by the Samba Active Directory Domain Controller's wins hook, allowing an unauthenticated network attacker to achieve remote command execution as the Samba process.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "critical"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-11731",
      "Description": "A flaw was found in the exsltFuncResultComp() function of libxslt, which handles EXSLT \u003cfunc:result\u003e elements during stylesheet parsing. Due to improper type handling, the function may treat an XML document node as a regular XML element node, resulting in a type confusion. This can cause unexpected memory reads and potential crashes. While difficult to exploit, the flaw could lead to application instability or denial of service.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-11961",
      "Description": "pcap_ether_aton() is an auxiliary function in libpcap, it takes a string argument and returns a fixed-size allocated buffer.  The string argument must be a well-formed MAC-48 address in one of the supported formats, but this requirement has been poorly documented.  If an application calls the function with an argument that deviates from the expected format, the function can read data beyond the end of the provided string and write data beyond the end of the allocated buffer.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-12084",
      "Description": "When building nested elements using xml.dom.minidom methods such as appendChild() that have a dependency on _clear_id_cache() the algorithm is quadratic. Availability can be impacted when building excessively nested documents.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-13601",
      "Description": "A heap-based buffer overflow problem was found in glib through an incorrect calculation of buffer size in the g_escape_uri_string() function. If the string to escape contains a very large number of unacceptable characters (which would need escaping), the calculation of the length of the escaped string could overflow, leading to a potential write off the end of the newly allocated string.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-13836",
      "Description": "When reading an HTTP response from a server, if no read amount is specified, the default behavior will be to use Content-Length. This allows a malicious server to cause the client to read large amounts of data into memory, potentially causing OOM or other DoS.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-13837",
      "Description": "When loading a plist file, the plistlib module reads data in size specified by the file itself, meaning a malicious file can cause OOM and DoS issues",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-14087",
      "Description": "A flaw was found in GLib (Gnome Lib). This vulnerability allows a remote attacker to cause heap corruption, leading to a denial of service or potential code execution via a buffer-underflow in the GVariant parser when processing maliciously crafted input strings.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-14512",
      "Description": "A flaw was found in glib. This vulnerability allows a heap buffer overflow and denial-of-service (DoS) via an integer overflow in GLib's GIO (GLib Input/Output) escape_byte_string() function when processing malicious file or remote filesystem attribute values.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-14524",
      "Description": "When an OAuth2 bearer token is used for an HTTP(S) transfer, and that transfer\nperforms a cross-protocol redirect to a second URL that uses an IMAP, LDAP,\nPOP3 or SMTP scheme, curl might wrongly pass on the bearer token to the new\ntarget host.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-14819",
      "Description": "When doing TLS related transfers with reused easy or multi handles and\naltering the  `CURLSSLOPT_NO_PARTIALCHAIN` option, libcurl could accidentally\nreuse a CA store cached in memory for which the partial chain option was\nreversed. Contrary to the user's wishes and expectations. This could make\nlibcurl find and accept a trust chain that it otherwise would not.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-15079",
      "Description": "When doing SSH-based transfers using either SCP or SFTP, and setting the\nknown_hosts file, libcurl could still mistakenly accept connecting to hosts\n*not present* in the specified file if they were added as recognized in the\nlibssh *global* known_hosts file.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-22868",
      "Description": "An attacker can pass a malicious malformed token which causes unexpected memory to be consumed during parsing.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-3576",
      "Description": "A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types, an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-37928",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm-bufio: don't schedule in atomic context\n\nA BUG was reported as below when CONFIG_DEBUG_ATOMIC_SLEEP and\ntry_verify_in_tasklet are enabled.\n[  129.444685][  T934] BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2421\n[  129.444723][  T934] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 934, name: kworker/1:4\n[  129.444740][  T934] preempt_count: 201, expected: 0\n[  129.444756][  T934] RCU nest depth: 0, expected: 0\n[  129.444781][  T934] Preemption disabled at:\n[  129.444789][  T934] [\u003cffffffd816231900\u003e] shrink_work+0x21c/0x248\n[  129.445167][  T934] kernel BUG at kernel/sched/walt/walt_debug.c:16!\n[  129.445183][  T934] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n[  129.445204][  T934] Skip md ftrace buffer dump for: 0x1609e0\n[  129.447348][  T934] CPU: 1 PID: 934 Comm: kworker/1:4 Tainted: G        W  OE      6.6.56-android15-8-o-g6f82312b30b9-debug #1 1400000003000000474e5500b3187743670464e8\n[  129.447362][  T934] Hardware name: Qualcomm Technologies, Inc. Parrot QRD, Alpha-M (DT)\n[  129.447373][  T934] Workqueue: dm_bufio_cache shrink_work\n[  129.447394][  T934] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  129.447406][  T934] pc : android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug]\n[  129.447435][  T934] lr : __traceiter_android_rvh_schedule_bug+0x44/0x6c\n[  129.447451][  T934] sp : ffffffc0843dbc90\n[  129.447459][  T934] x29: ffffffc0843dbc90 x28: ffffffffffffffff x27: 0000000000000c8b\n[  129.447479][  T934] x26: 0000000000000040 x25: ffffff804b3d6260 x24: ffffffd816232b68\n[  129.447497][  T934] x23: ffffff805171c5b4 x22: 0000000000000000 x21: ffffffd816231900\n[  129.447517][  T934] x20: ffffff80306ba898 x19: 0000000000000000 x18: ffffffc084159030\n[  129.447535][  T934] x17: 00000000d2b5dd1f x16: 00000000d2b5dd1f x15: ffffffd816720358\n[  129.447554][  T934] x14: 0000000000000004 x13: ffffff89ef978000 x12: 0000000000000003\n[  129.447572][  T934] x11: ffffffd817a823c4 x10: 0000000000000202 x9 : 7e779c5735de9400\n[  129.447591][  T934] x8 : ffffffd81560d004 x7 : 205b5d3938373434 x6 : ffffffd8167397c8\n[  129.447610][  T934] x5 : 0000000000000000 x4 : 0000000000000001 x3 : ffffffc0843db9e0\n[  129.447629][  T934] x2 : 0000000000002f15 x1 : 0000000000000000 x0 : 0000000000000000\n[  129.447647][  T934] Call trace:\n[  129.447655][  T934]  android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug 1400000003000000474e550080cce8a8a78606b6]\n[  129.447681][  T934]  __might_resched+0x190/0x1a8\n[  129.447694][  T934]  shrink_work+0x180/0x248\n[  129.447706][  T934]  process_one_work+0x260/0x624\n[  129.447718][  T934]  worker_thread+0x28c/0x454\n[  129.447729][  T934]  kthread+0x118/0x158\n[  129.447742][  T934]  ret_from_fork+0x10/0x20\n[  129.447761][  T934] Code: ???????? ???????? ???????? d2b5dd1f (d4210000)\n[  129.447772][  T934] ---[ end trace 0000000000000000 ]---\n\ndm_bufio_lock will call spin_lock_bh when try_verify_in_tasklet\nis enabled, and __scan will be called in atomic context.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38436",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/scheduler: signal scheduled fence when kill job\n\nWhen an entity from application B is killed, drm_sched_entity_kill()\nremoves all jobs belonging to that entity through\ndrm_sched_entity_kill_jobs_work(). If application A's job depends on a\nscheduled fence from application B's job, and that fence is not properly\nsignaled during the killing process, application A's dependency cannot be\ncleared.\n\nThis leads to application A hanging indefinitely while waiting for a\ndependency that will never be resolved. Fix this issue by ensuring that\nscheduled fences are properly signaled when an entity is killed, allowing\ndependent applications to continue execution.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38465",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetlink: Fix wraparounds of sk-\u003esk_rmem_alloc.\n\nNetlink has this pattern in some places\n\n  if (atomic_read(\u0026sk-\u003esk_rmem_alloc) \u003e sk-\u003esk_rcvbuf)\n  \tatomic_add(skb-\u003etruesize, \u0026sk-\u003esk_rmem_alloc);\n\n, which has the same problem fixed by commit 5a465a0da13e (\"udp:\nFix multiple wraparounds of sk-\u003esk_rmem_alloc.\").\n\nFor example, if we set INT_MAX to SO_RCVBUFFORCE, the condition\nis always false as the two operands are of int.\n\nThen, a single socket can eat as many skb as possible until OOM\nhappens, and we can see multiple wraparounds of sk-\u003esk_rmem_alloc.\n\nLet's fix it by using atomic_add_return() and comparing the two\nvariables as unsigned int.\n\nBefore:\n  [root@fedora ~]# ss -f netlink\n  Recv-Q      Send-Q Local Address:Port                Peer Address:Port\n  -1668710080 0               rtnl:nl_wraparound/293               *\n\nAfter:\n  [root@fedora ~]# ss -f netlink\n  Recv-Q     Send-Q Local Address:Port                Peer Address:Port\n  2147483072 0               rtnl:nl_wraparound/290               *\n  ^\n  `--- INT_MAX - 576",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38470",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: vlan: fix VLAN 0 refcount imbalance of toggling filtering during runtime\n\nAssuming the \"rx-vlan-filter\" feature is enabled on a net device, the\n8021q module will automatically add or remove VLAN 0 when the net device\nis put administratively up or down, respectively. There are a couple of\nproblems with the above scheme.\n\nThe first problem is a memory leak that can happen if the \"rx-vlan-filter\"\nfeature is disabled while the device is running:\n\n # ip link add bond1 up type bond mode 0\n # ethtool -K bond1 rx-vlan-filter off\n # ip link del dev bond1\n\nWhen the device is put administratively down the \"rx-vlan-filter\"\nfeature is disabled, so the 8021q module will not remove VLAN 0 and the\nmemory will be leaked [1].\n\nAnother problem that can happen is that the kernel can automatically\ndelete VLAN 0 when the device is put administratively down despite not\nadding it when the device was put administratively up since during that\ntime the \"rx-vlan-filter\" feature was disabled. null-ptr-unref or\nbug_on[2] will be triggered by unregister_vlan_dev() for refcount\nimbalance if toggling filtering during runtime:\n\n$ ip link add bond0 type bond mode 0\n$ ip link add link bond0 name vlan0 type vlan id 0 protocol 802.1q\n$ ethtool -K bond0 rx-vlan-filter off\n$ ifconfig bond0 up\n$ ethtool -K bond0 rx-vlan-filter on\n$ ifconfig bond0 down\n$ ip link del vlan0\n\nRoot cause is as below:\nstep1: add vlan0 for real_dev, such as bond, team.\nregister_vlan_dev\n    vlan_vid_add(real_dev,htons(ETH_P_8021Q),0) //refcnt=1\nstep2: disable vlan filter feature and enable real_dev\nstep3: change filter from 0 to 1\nvlan_device_event\n    vlan_filter_push_vids\n        ndo_vlan_rx_add_vid //No refcnt added to real_dev vlan0\nstep4: real_dev down\nvlan_device_event\n    vlan_vid_del(dev, htons(ETH_P_8021Q), 0); //refcnt=0\n        vlan_info_rcu_free //free vlan0\nstep5: delete vlan0\nunregister_vlan_dev\n    BUG_ON(!vlan_info); //vlan_info is null\n\nFix both problems by noting in the VLAN info whether VLAN 0 was\nautomatically added upon NETDEV_UP and based on that decide whether it\nshould be deleted upon NETDEV_DOWN, regardless of the state of the\n\"rx-vlan-filter\" feature.\n\n[1]\nunreferenced object 0xffff8880068e3100 (size 256):\n  comm \"ip\", pid 384, jiffies 4296130254\n  hex dump (first 32 bytes):\n    00 20 30 0d 80 88 ff ff 00 00 00 00 00 00 00 00  . 0.............\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace (crc 81ce31fa):\n    __kmalloc_cache_noprof+0x2b5/0x340\n    vlan_vid_add+0x434/0x940\n    vlan_device_event.cold+0x75/0xa8\n    notifier_call_chain+0xca/0x150\n    __dev_notify_flags+0xe3/0x250\n    rtnl_configure_link+0x193/0x260\n    rtnl_newlink_create+0x383/0x8e0\n    __rtnl_newlink+0x22c/0xa40\n    rtnl_newlink+0x627/0xb00\n    rtnetlink_rcv_msg+0x6fb/0xb70\n    netlink_rcv_skb+0x11f/0x350\n    netlink_unicast+0x426/0x710\n    netlink_sendmsg+0x75a/0xc20\n    __sock_sendmsg+0xc1/0x150\n    ____sys_sendmsg+0x5aa/0x7b0\n    ___sys_sendmsg+0xfc/0x180\n\n[2]\nkernel BUG at net/8021q/vlan.c:99!\nOops: invalid opcode: 0000 [#1] SMP KASAN PTI\nCPU: 0 UID: 0 PID: 382 Comm: ip Not tainted 6.16.0-rc3 #61 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996),\nBIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\nRIP: 0010:unregister_vlan_dev (net/8021q/vlan.c:99 (discriminator 1))\nRSP: 0018:ffff88810badf310 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff88810da84000 RCX: ffffffffb47ceb9a\nRDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88810e8b43c8\nRBP: 0000000000000000 R08: 0000000000000000 R09: fffffbfff6cefe80\nR10: ffffffffb677f407 R11: ffff88810badf3c0 R12: ffff88810e8b4000\nR13: 0000000000000000 R14: ffff88810642a5c0 R15: 000000000000017e\nFS:  00007f1ff68c20c0(0000) GS:ffff888163a24000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f1ff5dad240 CR3: 0000000107e56000 CR4: 00000000000006f0\nCall Trace:\n \u003cTASK\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38488",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free in crypt_message when using async crypto\n\nThe CVE-2024-50047 fix removed asynchronous crypto handling from\ncrypt_message(), assuming all crypto operations are synchronous.\nHowever, when hardware crypto accelerators are used, this can cause\nuse-after-free crashes:\n\n  crypt_message()\n    // Allocate the creq buffer containing the req\n    creq = smb2_get_aead_req(..., \u0026req);\n\n    // Async encryption returns -EINPROGRESS immediately\n    rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);\n\n    // Free creq while async operation is still in progress\n    kvfree_sensitive(creq, ...);\n\nHardware crypto modules often implement async AEAD operations for\nperformance. When crypto_aead_encrypt/decrypt() returns -EINPROGRESS,\nthe operation completes asynchronously. Without crypto_wait_req(),\nthe function immediately frees the request buffer, leading to crashes\nwhen the driver later accesses the freed memory.\n\nThis results in a use-after-free condition when the hardware crypto\ndriver later accesses the freed request structure, leading to kernel\ncrashes with NULL pointer dereferences.\n\nThe issue occurs because crypto_alloc_aead() with mask=0 doesn't\nguarantee synchronous operation. Even without CRYPTO_ALG_ASYNC in\nthe mask, async implementations can be selected.\n\nFix by restoring the async crypto handling:\n- DECLARE_CRYPTO_WAIT(wait) for completion tracking\n- aead_request_set_callback() for async completion notification\n- crypto_wait_req() to wait for operation completion\n\nThis ensures the request buffer isn't freed until the crypto operation\ncompletes, whether synchronous or asynchronous, while preserving the\nCVE-2024-50047 fix.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38527",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free in cifs_oplock_break\n\nA race condition can occur in cifs_oplock_break() leading to a\nuse-after-free of the cinode structure when unmounting:\n\n  cifs_oplock_break()\n    _cifsFileInfo_put(cfile)\n      cifsFileInfo_put_final()\n        cifs_sb_deactive()\n          [last ref, start releasing sb]\n            kill_sb()\n              kill_anon_super()\n                generic_shutdown_super()\n                  evict_inodes()\n                    dispose_list()\n                      evict()\n                        destroy_inode()\n                          call_rcu(\u0026inode-\u003ei_rcu, i_callback)\n    spin_lock(\u0026cinode-\u003eopen_file_lock)  \u003c- OK\n                            [later] i_callback()\n                              cifs_free_inode()\n                                kmem_cache_free(cinode)\n    spin_unlock(\u0026cinode-\u003eopen_file_lock)  \u003c- UAF\n    cifs_done_oplock_break(cinode)       \u003c- UAF\n\nThe issue occurs when umount has already released its reference to the\nsuperblock. When _cifsFileInfo_put() calls cifs_sb_deactive(), this\nreleases the last reference, triggering the immediate cleanup of all\ninodes under RCU. However, cifs_oplock_break() continues to access the\ncinode after this point, resulting in use-after-free.\n\nFix this by holding an extra reference to the superblock during the\nentire oplock break operation. This ensures that the superblock and\nits inodes remain valid until the oplock break completes.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38539",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Add down_write(trace_event_sem) when adding trace event\n\nWhen a module is loaded, it adds trace events defined by the module. It\nmay also need to modify the modules trace printk formats to replace enum\nnames with their values.\n\nIf two modules are loaded at the same time, the adding of the event to the\nftrace_events list can corrupt the walking of the list in the code that is\nmodifying the printk format strings and crash the kernel.\n\nThe addition of the event should take the trace_event_sem for write while\nit adds the new event.\n\nAlso add a lockdep_assert_held() on that semaphore in\n__trace_add_event_dirs() as it iterates the list.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38553",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Restrict conditions for adding duplicating netems to qdisc tree\n\nnetem_enqueue's duplication prevention logic breaks when a netem\nresides in a qdisc tree with other netems - this can lead to a\nsoft lockup and OOM loop in netem_dequeue, as seen in [1].\nEnsure that a duplicating netem cannot exist in a tree with other\nnetems.\n\nPrevious approaches suggested in discussions in chronological order:\n\n1) Track duplication status or ttl in the sk_buff struct. Considered\ntoo specific a use case to extend such a struct, though this would\nbe a resilient fix and address other previous and potential future\nDOS bugs like the one described in loopy fun [2].\n\n2) Restrict netem_enqueue recursion depth like in act_mirred with a\nper cpu variable. However, netem_dequeue can call enqueue on its\nchild, and the depth restriction could be bypassed if the child is a\nnetem.\n\n3) Use the same approach as in 2, but add metadata in netem_skb_cb\nto handle the netem_dequeue case and track a packet's involvement\nin duplication. This is an overly complex approach, and Jamal\nnotes that the skb cb can be overwritten to circumvent this\nsafeguard.\n\n4) Prevent the addition of a netem to a qdisc tree if its ancestral\npath contains a netem. However, filters and actions can cause a\npacket to change paths when re-enqueued to the root from netem\nduplication, leading us to the current solution: prevent a\nduplicating netem from inhabiting the same tree as other netems.\n\n[1] https://lore.kernel.org/netdev/8DuRWwfqjoRDLDmBMlIfbrsZg9Gx50DHJc1ilxsEBNe2D6NMoigR_eIRIG0LOjMc3r10nUUZtArXx4oZBIdUfZQrwjcQhdinnMis_0G7VEk=@willsroot.io/\n[2] https://lwn.net/Articles/719297/",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38572",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: reject malicious packets in ipv6_gso_segment()\n\nsyzbot was able to craft a packet with very long IPv6 extension headers\nleading to an overflow of skb-\u003etransport_header.\n\nThis 16bit field has a limited range.\n\nAdd skb_reset_transport_header_careful() helper and use it\nfrom ipv6_gso_segment()\n\nWARNING: CPU: 0 PID: 5871 at ./include/linux/skbuff.h:3032 skb_reset_transport_header include/linux/skbuff.h:3032 [inline]\nWARNING: CPU: 0 PID: 5871 at ./include/linux/skbuff.h:3032 ipv6_gso_segment+0x15e2/0x21e0 net/ipv6/ip6_offload.c:151\nModules linked in:\nCPU: 0 UID: 0 PID: 5871 Comm: syz-executor211 Not tainted 6.16.0-rc6-syzkaller-g7abc678e3084 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/12/2025\n RIP: 0010:skb_reset_transport_header include/linux/skbuff.h:3032 [inline]\n RIP: 0010:ipv6_gso_segment+0x15e2/0x21e0 net/ipv6/ip6_offload.c:151\nCall Trace:\n \u003cTASK\u003e\n  skb_mac_gso_segment+0x31c/0x640 net/core/gso.c:53\n  nsh_gso_segment+0x54a/0xe10 net/nsh/nsh.c:110\n  skb_mac_gso_segment+0x31c/0x640 net/core/gso.c:53\n  __skb_gso_segment+0x342/0x510 net/core/gso.c:124\n  skb_gso_segment include/net/gso.h:83 [inline]\n  validate_xmit_skb+0x857/0x11b0 net/core/dev.c:3950\n  validate_xmit_skb_list+0x84/0x120 net/core/dev.c:4000\n  sch_direct_xmit+0xd3/0x4b0 net/sched/sch_generic.c:329\n  __dev_xmit_skb net/core/dev.c:4102 [inline]\n  __dev_queue_xmit+0x17b6/0x3a70 net/core/dev.c:4679",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38574",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npptp: ensure minimal skb length in pptp_xmit()\n\nCommit aabc6596ffb3 (\"net: ppp: Add bound checking for skb data\non ppp_sync_txmung\") fixed ppp_sync_txmunge()\n\nWe need a similar fix in pptp_xmit(), otherwise we might\nread uninit data as reported by syzbot.\n\nBUG: KMSAN: uninit-value in pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193\n  pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193\n  ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2290 [inline]\n  ppp_input+0x1d6/0xe60 drivers/net/ppp/ppp_generic.c:2314\n  pppoe_rcv_core+0x1e8/0x760 drivers/net/ppp/pppoe.c:379\n  sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148\n  __release_sock+0x1d3/0x330 net/core/sock.c:3213\n  release_sock+0x6b/0x270 net/core/sock.c:3767\n  pppoe_sendmsg+0x15d/0xcb0 drivers/net/ppp/pppoe.c:904\n  sock_sendmsg_nosec net/socket.c:712 [inline]\n  __sock_sendmsg+0x330/0x3d0 net/socket.c:727\n  ____sys_sendmsg+0x893/0xd80 net/socket.c:2566\n  ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620\n  __sys_sendmmsg+0x2d9/0x7c0 net/socket.c:2709",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38602",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niwlwifi: Add missing check for alloc_ordered_workqueue\n\nAdd check for the return value of alloc_ordered_workqueue since it may\nreturn NULL pointer.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38604",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtl818x: Kill URBs before clearing tx status queue\n\nIn rtl8187_stop() move the call of usb_kill_anchored_urbs() before clearing\nb_tx_status.queue. This change prevents callbacks from using already freed\nskb due to anchor was not killed before freeing such skb.\n\n BUG: kernel NULL pointer dereference, address: 0000000000000080\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: Oops: 0000 [#1] SMP NOPTI\n CPU: 7 UID: 0 PID: 0 Comm: swapper/7 Not tainted 6.15.0 #8 PREEMPT(voluntary)\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015\n RIP: 0010:ieee80211_tx_status_irqsafe+0x21/0xc0 [mac80211]\n Call Trace:\n  \u003cIRQ\u003e\n  rtl8187_tx_cb+0x116/0x150 [rtl8187]\n  __usb_hcd_giveback_urb+0x9d/0x120\n  usb_giveback_urb_bh+0xbb/0x140\n  process_one_work+0x19b/0x3c0\n  bh_worker+0x1a7/0x210\n  tasklet_action+0x10/0x30\n  handle_softirqs+0xf0/0x340\n  __irq_exit_rcu+0xcd/0xf0\n  common_interrupt+0x85/0xa0\n  \u003c/IRQ\u003e\n\nTested on RTL8187BvE device.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38623",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: pnv_php: Fix surprise plug detection and recovery\n\nThe existing PowerNV hotplug code did not handle surprise plug events\ncorrectly, leading to a complete failure of the hotplug system after device\nremoval and a required reboot to detect new devices.\n\nThis comes down to two issues:\n\n 1) When a device is surprise removed, often the bridge upstream\n    port will cause a PE freeze on the PHB.  If this freeze is not\n    cleared, the MSI interrupts from the bridge hotplug notification\n    logic will not be received by the kernel, stalling all plug events\n    on all slots associated with the PE.\n\n 2) When a device is removed from a slot, regardless of surprise or\n    programmatic removal, the associated PHB/PE ls left frozen.\n    If this freeze is not cleared via a fundamental reset, skiboot\n    is unable to clear the freeze and cannot retrain / rescan the\n    slot.  This also requires a reboot to clear the freeze and redetect\n    the device in the slot.\n\nIssue the appropriate unfreeze and rescan commands on hotplug events,\nand don't oops on hotplug if pci_bus_to_OF_node() returns NULL.\n\n[bhelgaas: tidy comments]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38624",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: pnv_php: Clean up allocated IRQs on unplug\n\nWhen the root of a nested PCIe bridge configuration is unplugged, the\npnv_php driver leaked the allocated IRQ resources for the child bridges'\nhotplug event notifications, resulting in a panic.\n\nFix this by walking all child buses and deallocating all its IRQ resources\nbefore calling pci_hp_remove_devices().\n\nAlso modify the lifetime of the workqueue at struct pnv_php_slot::wq so\nthat it is only destroyed in pnv_php_free_slot(), instead of\npnv_php_disable_irq(). This is required since pnv_php_disable_irq() will\nnow be called by workers triggered by hot unplug interrupts, so the\nworkqueue needs to stay allocated.\n\nThe abridged kernel panic that occurs without this patch is as follows:\n\n  WARNING: CPU: 0 PID: 687 at kernel/irq/msi.c:292 msi_device_data_release+0x6c/0x9c\n  CPU: 0 UID: 0 PID: 687 Comm: bash Not tainted 6.14.0-rc5+ #2\n  Call Trace:\n   msi_device_data_release+0x34/0x9c (unreliable)\n   release_nodes+0x64/0x13c\n   devres_release_all+0xc0/0x140\n   device_del+0x2d4/0x46c\n   pci_destroy_dev+0x5c/0x194\n   pci_hp_remove_devices+0x90/0x128\n   pci_hp_remove_devices+0x44/0x128\n   pnv_php_disable_slot+0x54/0xd4\n   power_write_file+0xf8/0x18c\n   pci_slot_attr_store+0x40/0x5c\n   sysfs_kf_write+0x64/0x78\n   kernfs_fop_write_iter+0x1b0/0x290\n   vfs_write+0x3bc/0x50c\n   ksys_write+0x84/0x140\n   system_call_exception+0x124/0x230\n   system_call_vectored_common+0x15c/0x2ec\n\n[bhelgaas: tidy comments]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38632",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npinmux: fix race causing mux_owner NULL with active mux_usecount\n\ncommit 5a3e85c3c397 (\"pinmux: Use sequential access to access\ndesc-\u003epinmux data\") tried to address the issue when two client of the\nsame gpio calls pinctrl_select_state() for the same functionality, was\nresulting in NULL pointer issue while accessing desc-\u003emux_owner.\nHowever, issue was not completely fixed due to the way it was handled\nand it can still result in the same NULL pointer.\n\nThe issue occurs due to the following interleaving:\n\n     cpu0 (process A)                   cpu1 (process B)\n\n      pin_request() {                   pin_free() {\n\n                                         mutex_lock()\n                                         desc-\u003emux_usecount--; //becomes 0\n                                         ..\n                                         mutex_unlock()\n\n  mutex_lock(desc-\u003emux)\n  desc-\u003emux_usecount++; // becomes 1\n  desc-\u003emux_owner = owner;\n  mutex_unlock(desc-\u003emux)\n\n                                         mutex_lock(desc-\u003emux)\n                                         desc-\u003emux_owner = NULL;\n                                         mutex_unlock(desc-\u003emux)\n\nThis sequence leads to a state where the pin appears to be in use\n(`mux_usecount == 1`) but has no owner (`mux_owner == NULL`), which can\ncause NULL pointer on next pin_request on the same pin.\n\nEnsure that updates to mux_usecount and mux_owner are performed\natomically under the same lock. Only clear mux_owner when mux_usecount\nreaches zero and no new owner has been assigned.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38639",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: xt_nfacct: don't assume acct name is null-terminated\n\nBUG: KASAN: slab-out-of-bounds in .. lib/vsprintf.c:721\nRead of size 1 at addr ffff88801eac95c8 by task syz-executor183/5851\n[..]\n string+0x231/0x2b0 lib/vsprintf.c:721\n vsnprintf+0x739/0xf00 lib/vsprintf.c:2874\n [..]\n nfacct_mt_checkentry+0xd2/0xe0 net/netfilter/xt_nfacct.c:41\n xt_check_match+0x3d1/0xab0 net/netfilter/x_tables.c:523\n\nnfnl_acct_find_get() handles non-null input, but the error\nprintk relied on its presence.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38665",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: netlink: can_changelink(): fix NULL pointer deref of struct can_priv::do_set_mode\n\nAndrei Lalaev reported a NULL pointer deref when a CAN device is\nrestarted from Bus Off and the driver does not implement the struct\ncan_priv::do_set_mode callback.\n\nThere are 2 code path that call struct can_priv::do_set_mode:\n- directly by a manual restart from the user space, via\n  can_changelink()\n- delayed automatic restart after bus off (deactivated by default)\n\nTo prevent the NULL pointer deference, refuse a manual restart or\nconfigure the automatic restart delay in can_changelink() and report\nthe error via extack to user space.\n\nAs an additional safety measure let can_restart() return an error if\ncan_priv::do_set_mode is not set instead of dereferencing it\nunchecked.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38680",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Fix 1-byte out-of-bounds read in uvc_parse_format()\n\nThe buffer length check before calling uvc_parse_format() only ensured\nthat the buffer has at least 3 bytes (buflen \u003e 2), buf the function\naccesses buffer[3], requiring at least 4 bytes.\n\nThis can lead to an out-of-bounds read if the buffer has exactly 3 bytes.\n\nFix it by checking that the buffer has at least 4 bytes in\nuvc_parse_format().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38685",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: Fix vmalloc out-of-bounds write in fast_imageblit\n\nThis issue triggers when a userspace program does an ioctl\nFBIOPUT_CON2FBMAP by passing console number and frame buffer number.\nIdeally this maps console to frame buffer and updates the screen if\nconsole is visible.\n\nAs part of mapping it has to do resize of console according to frame\nbuffer info. if this resize fails and returns from vc_do_resize() and\ncontinues further. At this point console and new frame buffer are mapped\nand sets display vars. Despite failure still it continue to proceed\nupdating the screen at later stages where vc_data is related to previous\nframe buffer and frame buffer info and display vars are mapped to new\nframe buffer and eventully leading to out-of-bounds write in\nfast_imageblit(). This bheviour is excepted only when fg_console is\nequal to requested console which is a visible console and updates screen\nwith invalid struct references in fbcon_putcs().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38691",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npNFS: Fix uninited ptr deref in block/scsi layout\n\nThe error occurs on the third attempt to encode extents. When function\next_tree_prepare_commit() reallocates a larger buffer to retry encoding\nextents, the \"layoutupdate_pages\" page array is initialized only after the\nretry loop. But ext_tree_free_commitdata() is called on every iteration\nand tries to put pages in the array, thus dereferencing uninitialized\npointers.\n\nAn additional problem is that there is no limit on the maximum possible\nbuffer_size. When there are too many extents, the client may create a\nlayoutcommit that is larger than the maximum possible RPC size accepted\nby the server.\n\nDuring testing, we observed two typical scenarios. First, one memory page\nfor extents is enough when we work with small files, append data to the\nend of the file, or preallocate extents before writing. But when we fill\na new large file without preallocating, the number of extents can be huge,\nand counting the number of written extents in ext_tree_encode_commit()\ndoes not help much. Since this number increases even more between\nunlocking and locking of ext_tree, the reallocated buffer may not be\nlarge enough again and again.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38695",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Check for hdwq null ptr when cleaning up lpfc_vport structure\n\nIf a call to lpfc_sli4_read_rev() from lpfc_sli4_hba_setup() fails, the\nresultant cleanup routine lpfc_sli4_vport_delete_fcp_xri_aborted() may\noccur before sli4_hba.hdwqs are allocated.  This may result in a null\npointer dereference when attempting to take the abts_io_buf_list_lock for\nthe first hardware queue.  Fix by adding a null ptr check on\nphba-\u003esli4_hba.hdwq and early return because this situation means there\nmust have been an error during port initialization.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38699",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: bfa: Double-free fix\n\nWhen the bfad_im_probe() function fails during initialization, the memory\npointed to by bfad-\u003eim is freed without setting bfad-\u003eim to NULL.\n\nSubsequently, during driver uninstallation, when the state machine enters\nthe bfad_sm_stopping state and calls the bfad_im_probe_undo() function,\nit attempts to free the memory pointed to by bfad-\u003eim again, thereby\ntriggering a double-free vulnerability.\n\nSet bfad-\u003eim to NULL if probing fails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38700",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libiscsi: Initialize iscsi_conn-\u003edd_data only if memory is allocated\n\nIn case of an ib_fast_reg_mr allocation failure during iSER setup, the\nmachine hits a panic because iscsi_conn-\u003edd_data is initialized\nunconditionally, even when no memory is allocated (dd_size == 0).  This\nleads invalid pointer dereference during connection teardown.\n\nFix by setting iscsi_conn-\u003edd_data only if memory is actually allocated.\n\nPanic trace:\n------------\n iser: iser_create_fastreg_desc: Failed to allocate ib_fast_reg_mr err=-12\n iser: iser_alloc_rx_descriptors: failed allocating rx descriptors / data buffers\n BUG: unable to handle page fault for address: fffffffffffffff8\n RIP: 0010:swake_up_locked.part.5+0xa/0x40\n Call Trace:\n  complete+0x31/0x40\n  iscsi_iser_conn_stop+0x88/0xb0 [ib_iser]\n  iscsi_stop_conn+0x66/0xc0 [scsi_transport_iscsi]\n  iscsi_if_stop_conn+0x14a/0x150 [scsi_transport_iscsi]\n  iscsi_if_rx+0x1135/0x1834 [scsi_transport_iscsi]\n  ? netlink_lookup+0x12f/0x1b0\n  ? netlink_deliver_tap+0x2c/0x200\n  netlink_unicast+0x1ab/0x280\n  netlink_sendmsg+0x257/0x4f0\n  ? _copy_from_user+0x29/0x60\n  sock_sendmsg+0x5f/0x70",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38701",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: do not BUG when INLINE_DATA_FL lacks system.data xattr\n\nA syzbot fuzzed image triggered a BUG_ON in ext4_update_inline_data()\nwhen an inode had the INLINE_DATA_FL flag set but was missing the\nsystem.data extended attribute.\n\nSince this can happen due to a maiciouly fuzzed file system, we\nshouldn't BUG, but rather, report it as a corrupted file system.\n\nAdd similar replacements of BUG_ON with EXT4_ERROR_INODE() ii\next4_create_inline_data() and ext4_inline_data_truncate().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38702",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: fix potential buffer overflow in do_register_framebuffer()\n\nThe current implementation may lead to buffer overflow when:\n1.  Unregistration creates NULL gaps in registered_fb[]\n2.  All array slots become occupied despite num_registered_fb \u003c FB_MAX\n3.  The registration loop exceeds array bounds\n\nAdd boundary check to prevent registered_fb[FB_MAX] access.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38705",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/pm: fix null pointer access\n\nWriting a string without delimiters (' ', '\\n', '\\0') to the under\ngpu_od/fan_ctrl sysfs or pp_power_profile_mode for the CUSTOM profile\nwill result in a null pointer dereference.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38712",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: don't use BUG_ON() in hfsplus_create_attributes_file()\n\nWhen the volume header contains erroneous values that do not reflect\nthe actual state of the filesystem, hfsplus_fill_super() assumes that\nthe attributes file is not yet created, which later results in hitting\nBUG_ON() when hfsplus_create_attributes_file() is called. Replace this\nBUG_ON() with -EIO error with a message to suggest running fsck tool.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38713",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()\n\nThe hfsplus_readdir() method is capable to crash by calling\nhfsplus_uni2asc():\n\n[  667.121659][ T9805] ==================================================================\n[  667.122651][ T9805] BUG: KASAN: slab-out-of-bounds in hfsplus_uni2asc+0x902/0xa10\n[  667.123627][ T9805] Read of size 2 at addr ffff88802592f40c by task repro/9805\n[  667.124578][ T9805]\n[  667.124876][ T9805] CPU: 3 UID: 0 PID: 9805 Comm: repro Not tainted 6.16.0-rc3 #1 PREEMPT(full)\n[  667.124886][ T9805] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[  667.124890][ T9805] Call Trace:\n[  667.124893][ T9805]  \u003cTASK\u003e\n[  667.124896][ T9805]  dump_stack_lvl+0x10e/0x1f0\n[  667.124911][ T9805]  print_report+0xd0/0x660\n[  667.124920][ T9805]  ? __virt_addr_valid+0x81/0x610\n[  667.124928][ T9805]  ? __phys_addr+0xe8/0x180\n[  667.124934][ T9805]  ? hfsplus_uni2asc+0x902/0xa10\n[  667.124942][ T9805]  kasan_report+0xc6/0x100\n[  667.124950][ T9805]  ? hfsplus_uni2asc+0x902/0xa10\n[  667.124959][ T9805]  hfsplus_uni2asc+0x902/0xa10\n[  667.124966][ T9805]  ? hfsplus_bnode_read+0x14b/0x360\n[  667.124974][ T9805]  hfsplus_readdir+0x845/0xfc0\n[  667.124984][ T9805]  ? __pfx_hfsplus_readdir+0x10/0x10\n[  667.124994][ T9805]  ? stack_trace_save+0x8e/0xc0\n[  667.125008][ T9805]  ? iterate_dir+0x18b/0xb20\n[  667.125015][ T9805]  ? trace_lock_acquire+0x85/0xd0\n[  667.125022][ T9805]  ? lock_acquire+0x30/0x80\n[  667.125029][ T9805]  ? iterate_dir+0x18b/0xb20\n[  667.125037][ T9805]  ? down_read_killable+0x1ed/0x4c0\n[  667.125044][ T9805]  ? putname+0x154/0x1a0\n[  667.125051][ T9805]  ? __pfx_down_read_killable+0x10/0x10\n[  667.125058][ T9805]  ? apparmor_file_permission+0x239/0x3e0\n[  667.125069][ T9805]  iterate_dir+0x296/0xb20\n[  667.125076][ T9805]  __x64_sys_getdents64+0x13c/0x2c0\n[  667.125084][ T9805]  ? __pfx___x64_sys_getdents64+0x10/0x10\n[  667.125091][ T9805]  ? __x64_sys_openat+0x141/0x200\n[  667.125126][ T9805]  ? __pfx_filldir64+0x10/0x10\n[  667.125134][ T9805]  ? do_user_addr_fault+0x7fe/0x12f0\n[  667.125143][ T9805]  do_syscall_64+0xc9/0x480\n[  667.125151][ T9805]  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[  667.125158][ T9805] RIP: 0033:0x7fa8753b2fc9\n[  667.125164][ T9805] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 48\n[  667.125172][ T9805] RSP: 002b:00007ffe96f8e0f8 EFLAGS: 00000217 ORIG_RAX: 00000000000000d9\n[  667.125181][ T9805] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fa8753b2fc9\n[  667.125185][ T9805] RDX: 0000000000000400 RSI: 00002000000063c0 RDI: 0000000000000004\n[  667.125190][ T9805] RBP: 00007ffe96f8e110 R08: 00007ffe96f8e110 R09: 00007ffe96f8e110\n[  667.125195][ T9805] R10: 0000000000000000 R11: 0000000000000217 R12: 0000556b1e3b4260\n[  667.125199][ T9805] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[  667.125207][ T9805]  \u003c/TASK\u003e\n[  667.125210][ T9805]\n[  667.145632][ T9805] Allocated by task 9805:\n[  667.145991][ T9805]  kasan_save_stack+0x20/0x40\n[  667.146352][ T9805]  kasan_save_track+0x14/0x30\n[  667.146717][ T9805]  __kasan_kmalloc+0xaa/0xb0\n[  667.147065][ T9805]  __kmalloc_noprof+0x205/0x550\n[  667.147448][ T9805]  hfsplus_find_init+0x95/0x1f0\n[  667.147813][ T9805]  hfsplus_readdir+0x220/0xfc0\n[  667.148174][ T9805]  iterate_dir+0x296/0xb20\n[  667.148549][ T9805]  __x64_sys_getdents64+0x13c/0x2c0\n[  667.148937][ T9805]  do_syscall_64+0xc9/0x480\n[  667.149291][ T9805]  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[  667.149809][ T9805]\n[  667.150030][ T9805] The buggy address belongs to the object at ffff88802592f000\n[  667.150030][ T9805]  which belongs to the cache kmalloc-2k of size 2048\n[  667.151282][ T9805] The buggy address is located 0 bytes to the right of\n[  667.151282][ T9805]  allocated 1036-byte region [ffff88802592f000, ffff88802592f40c)\n[  667.1\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38714",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: fix slab-out-of-bounds in hfsplus_bnode_read()\n\nThe hfsplus_bnode_read() method can trigger the issue:\n\n[  174.852007][ T9784] ==================================================================\n[  174.852709][ T9784] BUG: KASAN: slab-out-of-bounds in hfsplus_bnode_read+0x2f4/0x360\n[  174.853412][ T9784] Read of size 8 at addr ffff88810b5fc6c0 by task repro/9784\n[  174.854059][ T9784]\n[  174.854272][ T9784] CPU: 1 UID: 0 PID: 9784 Comm: repro Not tainted 6.16.0-rc3 #7 PREEMPT(full)\n[  174.854281][ T9784] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[  174.854286][ T9784] Call Trace:\n[  174.854289][ T9784]  \u003cTASK\u003e\n[  174.854292][ T9784]  dump_stack_lvl+0x10e/0x1f0\n[  174.854305][ T9784]  print_report+0xd0/0x660\n[  174.854315][ T9784]  ? __virt_addr_valid+0x81/0x610\n[  174.854323][ T9784]  ? __phys_addr+0xe8/0x180\n[  174.854330][ T9784]  ? hfsplus_bnode_read+0x2f4/0x360\n[  174.854337][ T9784]  kasan_report+0xc6/0x100\n[  174.854346][ T9784]  ? hfsplus_bnode_read+0x2f4/0x360\n[  174.854354][ T9784]  hfsplus_bnode_read+0x2f4/0x360\n[  174.854362][ T9784]  hfsplus_bnode_dump+0x2ec/0x380\n[  174.854370][ T9784]  ? __pfx_hfsplus_bnode_dump+0x10/0x10\n[  174.854377][ T9784]  ? hfsplus_bnode_write_u16+0x83/0xb0\n[  174.854385][ T9784]  ? srcu_gp_start+0xd0/0x310\n[  174.854393][ T9784]  ? __mark_inode_dirty+0x29e/0xe40\n[  174.854402][ T9784]  hfsplus_brec_remove+0x3d2/0x4e0\n[  174.854411][ T9784]  __hfsplus_delete_attr+0x290/0x3a0\n[  174.854419][ T9784]  ? __pfx_hfs_find_1st_rec_by_cnid+0x10/0x10\n[  174.854427][ T9784]  ? __pfx___hfsplus_delete_attr+0x10/0x10\n[  174.854436][ T9784]  ? __asan_memset+0x23/0x50\n[  174.854450][ T9784]  hfsplus_delete_all_attrs+0x262/0x320\n[  174.854459][ T9784]  ? __pfx_hfsplus_delete_all_attrs+0x10/0x10\n[  174.854469][ T9784]  ? rcu_is_watching+0x12/0xc0\n[  174.854476][ T9784]  ? __mark_inode_dirty+0x29e/0xe40\n[  174.854483][ T9784]  hfsplus_delete_cat+0x845/0xde0\n[  174.854493][ T9784]  ? __pfx_hfsplus_delete_cat+0x10/0x10\n[  174.854507][ T9784]  hfsplus_unlink+0x1ca/0x7c0\n[  174.854516][ T9784]  ? __pfx_hfsplus_unlink+0x10/0x10\n[  174.854525][ T9784]  ? down_write+0x148/0x200\n[  174.854532][ T9784]  ? __pfx_down_write+0x10/0x10\n[  174.854540][ T9784]  vfs_unlink+0x2fe/0x9b0\n[  174.854549][ T9784]  do_unlinkat+0x490/0x670\n[  174.854557][ T9784]  ? __pfx_do_unlinkat+0x10/0x10\n[  174.854565][ T9784]  ? __might_fault+0xbc/0x130\n[  174.854576][ T9784]  ? getname_flags.part.0+0x1c5/0x550\n[  174.854584][ T9784]  __x64_sys_unlink+0xc5/0x110\n[  174.854592][ T9784]  do_syscall_64+0xc9/0x480\n[  174.854600][ T9784]  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[  174.854608][ T9784] RIP: 0033:0x7f6fdf4c3167\n[  174.854614][ T9784] Code: f0 ff ff 73 01 c3 48 8b 0d 26 0d 0e 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 08\n[  174.854622][ T9784] RSP: 002b:00007ffcb948bca8 EFLAGS: 00000206 ORIG_RAX: 0000000000000057\n[  174.854630][ T9784] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f6fdf4c3167\n[  174.854636][ T9784] RDX: 00007ffcb948bcc0 RSI: 00007ffcb948bcc0 RDI: 00007ffcb948bd50\n[  174.854641][ T9784] RBP: 00007ffcb948cd90 R08: 0000000000000001 R09: 00007ffcb948bb40\n[  174.854645][ T9784] R10: 00007f6fdf564fc0 R11: 0000000000000206 R12: 0000561e1bc9c2d0\n[  174.854650][ T9784] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[  174.854658][ T9784]  \u003c/TASK\u003e\n[  174.854661][ T9784]\n[  174.879281][ T9784] Allocated by task 9784:\n[  174.879664][ T9784]  kasan_save_stack+0x20/0x40\n[  174.880082][ T9784]  kasan_save_track+0x14/0x30\n[  174.880500][ T9784]  __kasan_kmalloc+0xaa/0xb0\n[  174.880908][ T9784]  __kmalloc_noprof+0x205/0x550\n[  174.881337][ T9784]  __hfs_bnode_create+0x107/0x890\n[  174.881779][ T9784]  hfsplus_bnode_find+0x2d0/0xd10\n[  174.882222][ T9784]  hfsplus_brec_find+0x2b0/0x520\n[  174.882659][ T9784]  hfsplus_delete_all_attrs+0x23b/0x3\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38718",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: linearize cloned gso packets in sctp_rcv\n\nA cloned head skb still shares these frag skbs in fraglist with the\noriginal head skb. It's not safe to access these frag skbs.\n\nsyzbot reported two use-of-uninitialized-memory bugs caused by this:\n\n  BUG: KMSAN: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998\n   sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331\n   sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122\n   __release_sock+0x1da/0x330 net/core/sock.c:3106\n   release_sock+0x6b/0x250 net/core/sock.c:3660\n   sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360\n   sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885\n   sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031\n   inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:718 [inline]\n\nand\n\n  BUG: KMSAN: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331\n   sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148\n   __release_sock+0x1d3/0x330 net/core/sock.c:3213\n   release_sock+0x6b/0x270 net/core/sock.c:3767\n   sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367\n   sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886\n   sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032\n   inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:712 [inline]\n\nThis patch fixes it by linearizing cloned gso packets in sctp_rcv().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38724",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: handle get_client_locked() failure in nfsd4_setclientid_confirm()\n\nLei Lu recently reported that nfsd4_setclientid_confirm() did not check\nthe return value from get_client_locked(). a SETCLIENTID_CONFIRM could\nrace with a confirmed client expiring and fail to get a reference. That\ncould later lead to a UAF.\n\nFix this by getting a reference early in the case where there is an\nextant confirmed client. If that fails then treat it as if there were no\nconfirmed client found at all.\n\nIn the case where the unconfirmed client is expiring, just fail and\nreturn the result from get_client_locked().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38729",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 power domain descriptors, too\n\nUAC3 power domain descriptors need to be verified with its variable\nbLength for avoiding the unexpected OOB accesses by malicious\nfirmware, too.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-38735",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngve: prevent ethtool ops after shutdown\n\nA crash can occur if an ethtool operation is invoked\nafter shutdown() is called.\n\nshutdown() is invoked during system shutdown to stop DMA operations\nwithout performing expensive deallocations. It is discouraged to\nunregister the netdev in this path, so the device may still be visible\nto userspace and kernel helpers.\n\nIn gve, shutdown() tears down most internal data structures. If an\nethtool operation is dispatched after shutdown(), it will dereference\nfreed or NULL pointers, leading to a kernel panic. While graceful\nshutdown normally quiesces userspace before invoking the reboot\nsyscall, forced shutdowns (as observed on GCP VMs) can still trigger\nthis path.\n\nFix by calling netif_device_detach() in shutdown().\nThis marks the device as detached so the ethtool ioctl handler\nwill skip dispatching operations to the driver.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39676",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla4xxx: Prevent a potential error pointer dereference\n\nThe qla4xxx_get_ep_fwdb() function is supposed to return NULL on error,\nbut qla4xxx_ep_connect() returns error pointers.  Propagating the error\npointers will lead to an Oops in the caller, so change the error pointers\nto NULL.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39677",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Fix backlog accounting in qdisc_dequeue_internal\n\nThis issue applies for the following qdiscs: hhf, fq, fq_codel, and\nfq_pie, and occurs in their change handlers when adjusting to the new\nlimit. The problem is the following in the values passed to the\nsubsequent qdisc_tree_reduce_backlog call given a tbf parent:\n\n   When the tbf parent runs out of tokens, skbs of these qdiscs will\n   be placed in gso_skb. Their peek handlers are qdisc_peek_dequeued,\n   which accounts for both qlen and backlog. However, in the case of\n   qdisc_dequeue_internal, ONLY qlen is accounted for when pulling\n   from gso_skb. This means that these qdiscs are missing a\n   qdisc_qstats_backlog_dec when dropping packets to satisfy the\n   new limit in their change handlers.\n\n   One can observe this issue with the following (with tc patched to\n   support a limit of 0):\n\n   export TARGET=fq\n   tc qdisc del dev lo root\n   tc qdisc add dev lo root handle 1: tbf rate 8bit burst 100b latency 1ms\n   tc qdisc replace dev lo handle 3: parent 1:1 $TARGET limit 1000\n   echo ''; echo 'add child'; tc -s -d qdisc show dev lo\n   ping -I lo -f -c2 -s32 -W0.001 127.0.0.1 2\u003e\u00261 \u003e/dev/null\n   echo ''; echo 'after ping'; tc -s -d qdisc show dev lo\n   tc qdisc change dev lo handle 3: parent 1:1 $TARGET limit 0\n   echo ''; echo 'after limit drop'; tc -s -d qdisc show dev lo\n   tc qdisc replace dev lo handle 2: parent 1:1 sfq\n   echo ''; echo 'post graft'; tc -s -d qdisc show dev lo\n\n   The second to last show command shows 0 packets but a positive\n   number (74) of backlog bytes. The problem becomes clearer in the\n   last show command, where qdisc_purge_queue triggers\n   qdisc_tree_reduce_backlog with the positive backlog and causes an\n   underflow in the tbf parent's backlog (4096 Mb instead of 0).\n\nTo fix this issue, the codepath for all clients of qdisc_dequeue_internal\nhas been simplified: codel, pie, hhf, fq, fq_pie, and fq_codel.\nqdisc_dequeue_internal handles the backlog adjustments for all cases that\ndo not directly use the dequeue handler.\n\nThe old fq_codel_change limit adjustment loop accumulated the arguments to\nthe subsequent qdisc_tree_reduce_backlog call through the cstats field.\nHowever, this is confusing and error prone as fq_codel_dequeue could also\npotentially mutate this field (which qdisc_dequeue_internal calls in the\nnon gso_skb case), so we have unified the code here with other qdiscs.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39691",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/buffer: fix use-after-free when call bh_read() helper\n\nThere's issue as follows:\nBUG: KASAN: stack-out-of-bounds in end_buffer_read_sync+0xe3/0x110\nRead of size 8 at addr ffffc9000168f7f8 by task swapper/3/0\nCPU: 3 UID: 0 PID: 0 Comm: swapper/3 Not tainted 6.16.0-862.14.0.6.x86_64\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996)\nCall Trace:\n \u003cIRQ\u003e\n dump_stack_lvl+0x55/0x70\n print_address_description.constprop.0+0x2c/0x390\n print_report+0xb4/0x270\n kasan_report+0xb8/0xf0\n end_buffer_read_sync+0xe3/0x110\n end_bio_bh_io_sync+0x56/0x80\n blk_update_request+0x30a/0x720\n scsi_end_request+0x51/0x2b0\n scsi_io_completion+0xe3/0x480\n ? scsi_device_unbusy+0x11e/0x160\n blk_complete_reqs+0x7b/0x90\n handle_softirqs+0xef/0x370\n irq_exit_rcu+0xa5/0xd0\n sysvec_apic_timer_interrupt+0x6e/0x90\n \u003c/IRQ\u003e\n\n Above issue happens when do ntfs3 filesystem mount, issue may happens\n as follows:\n           mount                            IRQ\nntfs_fill_super\n  read_cache_page\n    do_read_cache_folio\n      filemap_read_folio\n        mpage_read_folio\n\t do_mpage_readpage\n\t  ntfs_get_block_vbo\n\t   bh_read\n\t     submit_bh\n\t     wait_on_buffer(bh);\n\t                            blk_complete_reqs\n\t\t\t\t     scsi_io_completion\n\t\t\t\t      scsi_end_request\n\t\t\t\t       blk_update_request\n\t\t\t\t        end_bio_bh_io_sync\n\t\t\t\t\t end_buffer_read_sync\n\t\t\t\t\t  __end_buffer_read_notouch\n\t\t\t\t\t   unlock_buffer\n\n            wait_on_buffer(bh);--\u003e return will return to caller\n\n\t\t\t\t\t  put_bh\n\t\t\t\t\t    --\u003e trigger stack-out-of-bounds\nIn the mpage_read_folio() function, the stack variable 'map_bh' is\npassed to ntfs_get_block_vbo(). Once unlock_buffer() unlocks and\nwait_on_buffer() returns to continue processing, the stack variable\nis likely to be reclaimed. Consequently, during the end_buffer_read_sync()\nprocess, calling put_bh() may result in stack overrun.\n\nIf the bh is not allocated on the stack, it belongs to a folio.  Freeing\na buffer head which belongs to a folio is done by drop_buffers() which\nwill fail to free buffers which are still locked.  So it is safe to call\nput_bh() before __end_buffer_read_notouch().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39702",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: sr: Fix MAC comparison to be constant-time\n\nTo prevent timing attacks, MACs need to be compared in constant time.\nUse the appropriate helper function for this.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39705",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: fix a Null pointer dereference vulnerability\n\n[Why]\nA null pointer dereference vulnerability exists in the AMD display driver's\n(DC module) cleanup function dc_destruct().\nWhen display control context (dc-\u003ectx) construction fails\n(due to memory allocation failure), this pointer remains NULL.\nDuring subsequent error handling when dc_destruct() is called,\nthere's no NULL check before dereferencing the perf_trace member\n(dc-\u003ectx-\u003eperf_trace), causing a kernel null pointer dereference crash.\n\n[How]\nCheck if dc-\u003ectx is non-NULL before dereferencing.\n\n(Updated commit text and removed unnecessary error message)\n(cherry picked from commit 9dd8e2ba268c636c240a918e0a31e6feaee19404)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39706",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: Destroy KFD debugfs after destroy KFD wq\n\nSince KFD proc content was moved to kernel debugfs, we can't destroy KFD\ndebugfs before kfd_process_destroy_wq. Move kfd_process_destroy_wq prior\nto kfd_debugfs_fini to fix a kernel NULL pointer problem. It happens\nwhen /sys/kernel/debug/kfd was already destroyed in kfd_debugfs_fini but\nkfd_process_destroy_wq calls kfd_debugfs_remove_process. This line\n    debugfs_remove_recursive(entry-\u003eproc_dentry);\ntries to remove /sys/kernel/debug/kfd/proc/\u003cpid\u003e while\n/sys/kernel/debug/kfd is already gone. It hangs the kernel by kernel\nNULL pointer.\n\n(cherry picked from commit 0333052d90683d88531558dcfdbf2525cc37c233)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39724",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: 8250: fix panic due to PSLVERR\n\nWhen the PSLVERR_RESP_EN parameter is set to 1, the device generates\nan error response if an attempt is made to read an empty RBR (Receive\nBuffer Register) while the FIFO is enabled.\n\nIn serial8250_do_startup(), calling serial_port_out(port, UART_LCR,\nUART_LCR_WLEN8) triggers dw8250_check_lcr(), which invokes\ndw8250_force_idle() and serial8250_clear_and_reinit_fifos(). The latter\nfunction enables the FIFO via serial_out(p, UART_FCR, p-\u003efcr).\nExecution proceeds to the serial_port_in(port, UART_RX).\nThis satisfies the PSLVERR trigger condition.\n\nWhen another CPU (e.g., using printk()) is accessing the UART (UART\nis busy), the current CPU fails the check (value \u0026 ~UART_LCR_SPAR) ==\n(lcr \u0026 ~UART_LCR_SPAR) in dw8250_check_lcr(), causing it to enter\ndw8250_force_idle().\n\nPut serial_port_out(port, UART_LCR, UART_LCR_WLEN8) under the port-\u003elock\nto fix this issue.\n\nPanic backtrace:\n[    0.442336] Oops - unknown exception [#1]\n[    0.442343] epc : dw8250_serial_in32+0x1e/0x4a\n[    0.442351]  ra : serial8250_do_startup+0x2c8/0x88e\n...\n[    0.442416] console_on_rootfs+0x26/0x70",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39726",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/ism: fix concurrency management in ism_cmd()\n\nThe s390x ISM device data sheet clearly states that only one\nrequest-response sequence is allowable per ISM function at any point in\ntime.  Unfortunately as of today the s390/ism driver in Linux does not\nhonor that requirement. This patch aims to rectify that.\n\nThis problem was discovered based on Aliaksei's bug report which states\nthat for certain workloads the ISM functions end up entering error state\n(with PEC 2 as seen from the logs) after a while and as a consequence\nconnections handled by the respective function break, and for future\nconnection requests the ISM device is not considered -- given it is in a\ndysfunctional state. During further debugging PEC 3A was observed as\nwell.\n\nA kernel message like\n[ 1211.244319] zpci: 061a:00:00.0: Event 0x2 reports an error for PCI function 0x61a\nis a reliable indicator of the stated function entering error state\nwith PEC 2. Let me also point out that a kernel message like\n[ 1211.244325] zpci: 061a:00:00.0: The ism driver bound to the device does not support error recovery\nis a reliable indicator that the ISM function won't be auto-recovered\nbecause the ISM driver currently lacks support for it.\n\nOn a technical level, without this synchronization, commands (inputs to\nthe FW) may be partially or fully overwritten (corrupted) by another CPU\ntrying to issue commands on the same function. There is hard evidence that\nthis can lead to DMB token values being used as DMB IOVAs, leading to\nPEC 2 PCI events indicating invalid DMA. But this is only one of the\nfailure modes imaginable. In theory even completely losing one command\nand executing another one twice and then trying to interpret the outputs\nas if the command we intended to execute was actually executed and not\nthe other one is also possible.  Frankly, I don't feel confident about\nproviding an exhaustive list of possible consequences.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39751",
      "Description": "This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39754",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/smaps: fix race between smaps_hugetlb_range and migration\n\nsmaps_hugetlb_range() handles the pte without holdling ptl, and may be\nconcurrenct with migration, leaing to BUG_ON in pfn_swap_entry_to_page(). \nThe race is as follows.\n\nsmaps_hugetlb_range              migrate_pages\n  huge_ptep_get\n                                   remove_migration_ptes\n\t\t\t\t   folio_unlock\n  pfn_swap_entry_folio\n    BUG_ON\n\nTo fix it, hold ptl lock in smaps_hugetlb_range().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39756",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: Prevent file descriptor table allocations exceeding INT_MAX\n\nWhen sysctl_nr_open is set to a very high value (for example, 1073741816\nas set by systemd), processes attempting to use file descriptors near\nthe limit can trigger massive memory allocation attempts that exceed\nINT_MAX, resulting in a WARNING in mm/slub.c:\n\n  WARNING: CPU: 0 PID: 44 at mm/slub.c:5027 __kvmalloc_node_noprof+0x21a/0x288\n\nThis happens because kvmalloc_array() and kvmalloc() check if the\nrequested size exceeds INT_MAX and emit a warning when the allocation is\nnot flagged with __GFP_NOWARN.\n\nSpecifically, when nr_open is set to 1073741816 (0x3ffffff8) and a\nprocess calls dup2(oldfd, 1073741880), the kernel attempts to allocate:\n- File descriptor array: 1073741880 * 8 bytes = 8,589,935,040 bytes\n- Multiple bitmaps: ~400MB\n- Total allocation size: \u003e 8GB (exceeding INT_MAX = 2,147,483,647)\n\nReproducer:\n1. Set /proc/sys/fs/nr_open to 1073741816:\n   # echo 1073741816 \u003e /proc/sys/fs/nr_open\n\n2. Run a program that uses a high file descriptor:\n   #include \u003cunistd.h\u003e\n   #include \u003csys/resource.h\u003e\n\n   int main() {\n       struct rlimit rlim = {1073741824, 1073741824};\n       setrlimit(RLIMIT_NOFILE, \u0026rlim);\n       dup2(2, 1073741880);  // Triggers the warning\n       return 0;\n   }\n\n3. Observe WARNING in dmesg at mm/slub.c:5027\n\nsystemd commit a8b627a introduced automatic bumping of fs.nr_open to the\nmaximum possible value. The rationale was that systems with memory\ncontrol groups (memcg) no longer need separate file descriptor limits\nsince memory is properly accounted. However, this change overlooked\nthat:\n\n1. The kernel's allocation functions still enforce INT_MAX as a maximum\n   size regardless of memcg accounting\n2. Programs and tests that legitimately test file descriptor limits can\n   inadvertently trigger massive allocations\n3. The resulting allocations (\u003e8GB) are impractical and will always fail\n\nsystemd's algorithm starts with INT_MAX and keeps halving the value\nuntil the kernel accepts it. On most systems, this results in nr_open\nbeing set to 1073741816 (0x3ffffff8), which is just under 1GB of file\ndescriptors.\n\nWhile processes rarely use file descriptors near this limit in normal\noperation, certain selftests (like\ntools/testing/selftests/core/unshare_test.c) and programs that test file\ndescriptor limits can trigger this issue.\n\nFix this by adding a check in alloc_fdtable() to ensure the requested\nallocation size does not exceed INT_MAX. This causes the operation to\nfail with -EMFILE instead of triggering a kernel warning and avoids the\nimpractical \u003e8GB memory allocation request.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39757",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 cluster segment descriptors\n\nUAC3 class segment descriptors need to be verified whether their sizes\nmatch with the declared lengths and whether they fit with the\nallocated buffer sizes, too.  Otherwise malicious firmware may lead to\nthe unexpected OOB accesses.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39760",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: core: config: Prevent OOB read in SS endpoint companion parsing\n\nusb_parse_ss_endpoint_companion() checks descriptor type before length,\nenabling a potentially odd read outside of the buffer size.\n\nFix this up by checking the size first before looking at any of the\nfields in the descriptor.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39763",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: APEI: send SIGBUS to current task if synchronous memory error not recovered\n\nIf a synchronous error is detected as a result of user-space process\ntriggering a 2-bit uncorrected error, the CPU will take a synchronous\nerror exception such as Synchronous External Abort (SEA) on Arm64. The\nkernel will queue a memory_failure() work which poisons the related\npage, unmaps the page, and then sends a SIGBUS to the process, so that\na system wide panic can be avoided.\n\nHowever, no memory_failure() work will be queued when abnormal\nsynchronous errors occur. These errors can include situations like\ninvalid PA, unexpected severity, no memory failure config support,\ninvalid GUID section, etc. In such a case, the user-space process will\ntrigger SEA again.  This loop can potentially exceed the platform\nfirmware threshold or even trigger a kernel hard lockup, leading to a\nsystem reboot.\n\nFix it by performing a force kill if no memory_failure() work is queued\nfor synchronous errors.\n\n[ rjw: Changelog edits ]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39764",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: ctnetlink: remove refcounting in expectation dumpers\n\nSame pattern as previous patch: do not keep the expectation object\nalive via refcount, only store a cookie value and then use that\nas the skip hint for dump resumption.\n\nAFAICS this has the same issue as the one resolved in the conntrack\ndumper, when we do\n  if (!refcount_inc_not_zero(\u0026exp-\u003euse))\n\nto increment the refcount, there is a chance that exp == last, which\ncauses a double-increment of the refcount and subsequent memory leak.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39772",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/hisilicon/hibmc: fix the hibmc loaded failed bug\n\nWhen hibmc loaded failed, the driver use hibmc_unload to free the\nresource, but the mutexes in mode.config are not init, which will\naccess an NULL pointer. Just change goto statement to return, because\nhibnc_hw_init() doesn't need to free anything.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39773",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix soft lockup in br_multicast_query_expired()\n\nWhen set multicast_query_interval to a large value, the local variable\n'time' in br_multicast_send_query() may overflow. If the time is smaller\nthan jiffies, the timer will expire immediately, and then call mod_timer()\nagain, which creates a loop and may trigger the following soft lockup\nissue.\n\n  watchdog: BUG: soft lockup - CPU#1 stuck for 221s! [rb_consumer:66]\n  CPU: 1 UID: 0 PID: 66 Comm: rb_consumer Not tainted 6.16.0+ #259 PREEMPT(none)\n  Call Trace:\n   \u003cIRQ\u003e\n   __netdev_alloc_skb+0x2e/0x3a0\n   br_ip6_multicast_alloc_query+0x212/0x1b70\n   __br_multicast_send_query+0x376/0xac0\n   br_multicast_send_query+0x299/0x510\n   br_multicast_query_expired.constprop.0+0x16d/0x1b0\n   call_timer_fn+0x3b/0x2a0\n   __run_timers+0x619/0x950\n   run_timer_softirq+0x11c/0x220\n   handle_softirqs+0x18e/0x560\n   __irq_exit_rcu+0x158/0x1a0\n   sysvec_apic_timer_interrupt+0x76/0x90\n   \u003c/IRQ\u003e\n\nThis issue can be reproduced with:\n  ip link add br0 type bridge\n  echo 1 \u003e /sys/class/net/br0/bridge/multicast_querier\n  echo 0xffffffffffffffff \u003e\n  \t/sys/class/net/br0/bridge/multicast_query_interval\n  ip link set dev br0 up\n\nThe multicast_startup_query_interval can also cause this issue. Similar to\nthe commit 99b40610956a (\"net: bridge: mcast: add and enforce query\ninterval minimum\"), add check for the query interval maximum to fix this\nissue.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39782",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: prevent softlockup in jbd2_log_do_checkpoint()\n\nBoth jbd2_log_do_checkpoint() and jbd2_journal_shrink_checkpoint_list()\nperiodically release j_list_lock after processing a batch of buffers to\navoid long hold times on the j_list_lock. However, since both functions\ncontend for j_list_lock, the combined time spent waiting and processing\ncan be significant.\n\njbd2_journal_shrink_checkpoint_list() explicitly calls cond_resched() when\nneed_resched() is true to avoid softlockups during prolonged operations.\nBut jbd2_log_do_checkpoint() only exits its loop when need_resched() is\ntrue, relying on potentially sleeping functions like __flush_batch() or\nwait_on_buffer() to trigger rescheduling. If those functions do not sleep,\nthe kernel may hit a softlockup.\n\nwatchdog: BUG: soft lockup - CPU#3 stuck for 156s! [kworker/u129:2:373]\nCPU: 3 PID: 373 Comm: kworker/u129:2 Kdump: loaded Not tainted 6.6.0+ #10\nHardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.27 06/13/2017\nWorkqueue: writeback wb_workfn (flush-7:2)\npstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : native_queued_spin_lock_slowpath+0x358/0x418\nlr : jbd2_log_do_checkpoint+0x31c/0x438 [jbd2]\nCall trace:\n native_queued_spin_lock_slowpath+0x358/0x418\n jbd2_log_do_checkpoint+0x31c/0x438 [jbd2]\n __jbd2_log_wait_for_space+0xfc/0x2f8 [jbd2]\n add_transaction_credits+0x3bc/0x418 [jbd2]\n start_this_handle+0xf8/0x560 [jbd2]\n jbd2__journal_start+0x118/0x228 [jbd2]\n __ext4_journal_start_sb+0x110/0x188 [ext4]\n ext4_do_writepages+0x3dc/0x740 [ext4]\n ext4_writepages+0xa4/0x190 [ext4]\n do_writepages+0x94/0x228\n __writeback_single_inode+0x48/0x318\n writeback_sb_inodes+0x204/0x590\n __writeback_inodes_wb+0x54/0xf8\n wb_writeback+0x2cc/0x3d8\n wb_do_writeback+0x2e0/0x2f8\n wb_workfn+0x80/0x2a8\n process_one_work+0x178/0x3e8\n worker_thread+0x234/0x3b8\n kthread+0xf0/0x108\n ret_from_fork+0x10/0x20\n\nSo explicitly call cond_resched() in jbd2_log_do_checkpoint() to avoid\nsoftlockup.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39787",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: mdt_loader: Ensure we don't read past the ELF header\n\nWhen the MDT loader is used in remoteproc, the ELF header is sanitized\nbeforehand, but that's not necessary the case for other clients.\n\nValidate the size of the firmware buffer to ensure that we don't read\npast the end as we iterate over the header. e_phentsize and e_shentsize\nare validated as well, to ensure that the assumptions about step size in\nthe traversal are valid.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39800",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: abort transaction on unexpected eb generation at btrfs_copy_root()\n\nIf we find an unexpected generation for the extent buffer we are cloning\nat btrfs_copy_root(), we just WARN_ON() and don't error out and abort the\ntransaction, meaning we allow to persist metadata with an unexpected\ngeneration. Instead of warning only, abort the transaction and return\n-EUCLEAN.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39808",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: hid-ntrig: fix unable to handle page fault in ntrig_report_version()\n\nin ntrig_report_version(), hdev parameter passed from hid_probe().\nsending descriptor to /dev/uhid can make hdev-\u003edev.parent-\u003eparent to null\nif hdev-\u003edev.parent-\u003eparent is null, usb_dev has\ninvalid address(0xffffffffffffff58) that hid_to_usb_dev(hdev) returned\nwhen usb_rcvctrlpipe() use usb_dev,it trigger\npage fault error for address(0xffffffffffffff58)\n\nadd null check logic to ntrig_report_version()\nbefore calling hid_to_usb_dev()",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39812",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: initialize more fields in sctp_v6_from_sk()\n\nsyzbot found that sin6_scope_id was not properly initialized,\nleading to undefined behavior.\n\nClear sin6_scope_id and sin6_flowinfo.\n\nBUG: KMSAN: uninit-value in __sctp_v6_cmp_addr+0x887/0x8c0 net/sctp/ipv6.c:649\n  __sctp_v6_cmp_addr+0x887/0x8c0 net/sctp/ipv6.c:649\n  sctp_inet6_cmp_addr+0x4f2/0x510 net/sctp/ipv6.c:983\n  sctp_bind_addr_conflict+0x22a/0x3b0 net/sctp/bind_addr.c:390\n  sctp_get_port_local+0x21eb/0x2440 net/sctp/socket.c:8452\n  sctp_get_port net/sctp/socket.c:8523 [inline]\n  sctp_listen_start net/sctp/socket.c:8567 [inline]\n  sctp_inet_listen+0x710/0xfd0 net/sctp/socket.c:8636\n  __sys_listen_socket net/socket.c:1912 [inline]\n  __sys_listen net/socket.c:1927 [inline]\n  __do_sys_listen net/socket.c:1932 [inline]\n  __se_sys_listen net/socket.c:1930 [inline]\n  __x64_sys_listen+0x343/0x4c0 net/socket.c:1930\n  x64_sys_call+0x271d/0x3e20 arch/x86/include/generated/asm/syscalls_64.h:51\n  do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n  do_syscall_64+0xd9/0x210 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nLocal variable addr.i.i created at:\n  sctp_get_port net/sctp/socket.c:8515 [inline]\n  sctp_listen_start net/sctp/socket.c:8567 [inline]\n  sctp_inet_listen+0x650/0xfd0 net/sctp/socket.c:8636\n  __sys_listen_socket net/socket.c:1912 [inline]\n  __sys_listen net/socket.c:1927 [inline]\n  __do_sys_listen net/socket.c:1932 [inline]\n  __se_sys_listen net/socket.c:1930 [inline]\n  __x64_sys_listen+0x343/0x4c0 net/socket.c:1930",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39813",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix potential warning in trace_printk_seq during ftrace_dump\n\nWhen calling ftrace_dump_one() concurrently with reading trace_pipe,\na WARN_ON_ONCE() in trace_printk_seq() can be triggered due to a race\ncondition.\n\nThe issue occurs because:\n\nCPU0 (ftrace_dump)                              CPU1 (reader)\necho z \u003e /proc/sysrq-trigger\n\n!trace_empty(\u0026iter)\ntrace_iterator_reset(\u0026iter) \u003c- len = size = 0\n                                                cat /sys/kernel/tracing/trace_pipe\ntrace_find_next_entry_inc(\u0026iter)\n  __find_next_entry\n    ring_buffer_empty_cpu \u003c- all empty\n  return NULL\n\ntrace_printk_seq(\u0026iter.seq)\n  WARN_ON_ONCE(s-\u003eseq.len \u003e= s-\u003eseq.size)\n\nIn the context between trace_empty() and trace_find_next_entry_inc()\nduring ftrace_dump, the ring buffer data was consumed by other readers.\nThis caused trace_find_next_entry_inc to return NULL, failing to populate\n`iter.seq`. At this point, due to the prior trace_iterator_reset, both\n`iter.seq.len` and `iter.seq.size` were set to 0. Since they are equal,\nthe WARN_ON_ONCE condition is triggered.\n\nMove the trace_printk_seq() into the if block that checks to make sure the\nreturn value of trace_find_next_entry_inc() is non-NULL in\nftrace_dump_one(), ensuring the 'iter.seq' is properly populated before\nsubsequent operations.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39819",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/smb: Fix inconsistent refcnt update\n\nA possible inconsistent update of refcount was identified in `smb2_compound_op`.\nSuch inconsistent update could lead to possible resource leaks.\n\nWhy it is a possible bug:\n1. In the comment section of the function, it clearly states that the\nreference to `cfile` should be dropped after calling this function.\n2. Every control flow path would check and drop the reference to\n`cfile`, except the patched one.\n3. Existing callers would not handle refcount update of `cfile` if\n-ENOMEM is returned.\n\nTo fix the bug, an extra goto label \"out\" is added, to make sure that the\ncleanup logic would always be respected. As the problem is caused by the\nallocation failure of `vars`, the cleanup logic between label \"finished\"\nand \"out\" can be safely ignored. According to the definition of function\n`is_replayable_error`, the error code of \"-ENOMEM\" is not recoverable.\nTherefore, the replay logic also gets ignored.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39824",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: asus: fix UAF via HID_CLAIMED_INPUT validation\n\nAfter hid_hw_start() is called hidinput_connect() will eventually be\ncalled to set up the device with the input layer since the\nHID_CONNECT_DEFAULT connect mask is used. During hidinput_connect()\nall input and output reports are processed and corresponding hid_inputs\nare allocated and configured via hidinput_configure_usages(). This\nprocess involves slot tagging report fields and configuring usages\nby setting relevant bits in the capability bitmaps. However it is possible\nthat the capability bitmaps are not set at all leading to the subsequent\nhidinput_has_been_populated() check to fail leading to the freeing of the\nhid_input and the underlying input device.\n\nThis becomes problematic because a malicious HID device like a\nASUS ROG N-Key keyboard can trigger the above scenario via a\nspecially crafted descriptor which then leads to a user-after-free\nwhen the name of the freed input device is written to later on after\nhid_hw_start(). Below, report 93 intentionally utilises the\nHID_UP_UNDEFINED Usage Page which is skipped during usage\nconfiguration, leading to the frees.\n\n0x05, 0x0D,        // Usage Page (Digitizer)\n0x09, 0x05,        // Usage (Touch Pad)\n0xA1, 0x01,        // Collection (Application)\n0x85, 0x0D,        //   Report ID (13)\n0x06, 0x00, 0xFF,  //   Usage Page (Vendor Defined 0xFF00)\n0x09, 0xC5,        //   Usage (0xC5)\n0x15, 0x00,        //   Logical Minimum (0)\n0x26, 0xFF, 0x00,  //   Logical Maximum (255)\n0x75, 0x08,        //   Report Size (8)\n0x95, 0x04,        //   Report Count (4)\n0xB1, 0x02,        //   Feature (Data,Var,Abs)\n0x85, 0x5D,        //   Report ID (93)\n0x06, 0x00, 0x00,  //   Usage Page (Undefined)\n0x09, 0x01,        //   Usage (0x01)\n0x15, 0x00,        //   Logical Minimum (0)\n0x26, 0xFF, 0x00,  //   Logical Maximum (255)\n0x75, 0x08,        //   Report Size (8)\n0x95, 0x1B,        //   Report Count (27)\n0x81, 0x02,        //   Input (Data,Var,Abs)\n0xC0,              // End Collection\n\nBelow is the KASAN splat after triggering the UAF:\n\n[   21.672709] ==================================================================\n[   21.673700] BUG: KASAN: slab-use-after-free in asus_probe+0xeeb/0xf80\n[   21.673700] Write of size 8 at addr ffff88810a0ac000 by task kworker/1:2/54\n[   21.673700]\n[   21.673700] CPU: 1 UID: 0 PID: 54 Comm: kworker/1:2 Not tainted 6.16.0-rc4-g9773391cf4dd-dirty #36 PREEMPT(voluntary)\n[   21.673700] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n[   21.673700] Call Trace:\n[   21.673700]  \u003cTASK\u003e\n[   21.673700]  dump_stack_lvl+0x5f/0x80\n[   21.673700]  print_report+0xd1/0x660\n[   21.673700]  kasan_report+0xe5/0x120\n[   21.673700]  __asan_report_store8_noabort+0x1b/0x30\n[   21.673700]  asus_probe+0xeeb/0xf80\n[   21.673700]  hid_device_probe+0x2ee/0x700\n[   21.673700]  really_probe+0x1c6/0x6b0\n[   21.673700]  __driver_probe_device+0x24f/0x310\n[   21.673700]  driver_probe_device+0x4e/0x220\n[...]\n[   21.673700]\n[   21.673700] Allocated by task 54:\n[   21.673700]  kasan_save_stack+0x3d/0x60\n[   21.673700]  kasan_save_track+0x18/0x40\n[   21.673700]  kasan_save_alloc_info+0x3b/0x50\n[   21.673700]  __kasan_kmalloc+0x9c/0xa0\n[   21.673700]  __kmalloc_cache_noprof+0x139/0x340\n[   21.673700]  input_allocate_device+0x44/0x370\n[   21.673700]  hidinput_connect+0xcb6/0x2630\n[   21.673700]  hid_connect+0xf74/0x1d60\n[   21.673700]  hid_hw_start+0x8c/0x110\n[   21.673700]  asus_probe+0x5a3/0xf80\n[   21.673700]  hid_device_probe+0x2ee/0x700\n[   21.673700]  really_probe+0x1c6/0x6b0\n[   21.673700]  __driver_probe_device+0x24f/0x310\n[   21.673700]  driver_probe_device+0x4e/0x220\n[...]\n[   21.673700]\n[   21.673700] Freed by task 54:\n[   21.673700]  kasan_save_stack+0x3d/0x60\n[   21.673700]  kasan_save_track+0x18/0x40\n[   21.673700]  kasan_save_free_info+0x3f/0x60\n[   21.673700]  __kasan_slab_free+0x3c/0x50\n[   21.673700]  kfre\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39833",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmISDN: hfcpci: Fix warning when deleting uninitialized timer\n\nWith CONFIG_DEBUG_OBJECTS_TIMERS unloading hfcpci module leads\nto the following splat:\n\n[  250.215892] ODEBUG: assert_init not available (active state 0) object: ffffffffc01a3dc0 object type: timer_list hint: 0x0\n[  250.217520] WARNING: CPU: 0 PID: 233 at lib/debugobjects.c:612 debug_print_object+0x1b6/0x2c0\n[  250.218775] Modules linked in: hfcpci(-) mISDN_core\n[  250.219537] CPU: 0 UID: 0 PID: 233 Comm: rmmod Not tainted 6.17.0-rc2-g6f713187ac98 #2 PREEMPT(voluntary)\n[  250.220940] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[  250.222377] RIP: 0010:debug_print_object+0x1b6/0x2c0\n[  250.223131] Code: fc ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 75 4f 41 56 48 8b 14 dd a0 4e 01 9f 48 89 ee 48 c7 c7 20 46 01 9f e8 cb 84d\n[  250.225805] RSP: 0018:ffff888015ea7c08 EFLAGS: 00010286\n[  250.226608] RAX: 0000000000000000 RBX: 0000000000000005 RCX: ffffffff9be93a95\n[  250.227708] RDX: 1ffff1100d945138 RSI: 0000000000000008 RDI: ffff88806ca289c0\n[  250.228993] RBP: ffffffff9f014a00 R08: 0000000000000001 R09: ffffed1002bd4f39\n[  250.230043] R10: ffff888015ea79cf R11: 0000000000000001 R12: 0000000000000001\n[  250.231185] R13: ffffffff9eea0520 R14: 0000000000000000 R15: ffff888015ea7cc8\n[  250.232454] FS:  00007f3208f01540(0000) GS:ffff8880caf5a000(0000) knlGS:0000000000000000\n[  250.233851] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  250.234856] CR2: 00007f32090a7421 CR3: 0000000004d63000 CR4: 00000000000006f0\n[  250.236117] Call Trace:\n[  250.236599]  \u003cTASK\u003e\n[  250.236967]  ? trace_irq_enable.constprop.0+0xd4/0x130\n[  250.237920]  debug_object_assert_init+0x1f6/0x310\n[  250.238762]  ? __pfx_debug_object_assert_init+0x10/0x10\n[  250.239658]  ? __lock_acquire+0xdea/0x1c70\n[  250.240369]  __try_to_del_timer_sync+0x69/0x140\n[  250.241172]  ? __pfx___try_to_del_timer_sync+0x10/0x10\n[  250.242058]  ? __timer_delete_sync+0xc6/0x120\n[  250.242842]  ? lock_acquire+0x30/0x80\n[  250.243474]  ? __timer_delete_sync+0xc6/0x120\n[  250.244262]  __timer_delete_sync+0x98/0x120\n[  250.245015]  HFC_cleanup+0x10/0x20 [hfcpci]\n[  250.245704]  __do_sys_delete_module+0x348/0x510\n[  250.246461]  ? __pfx___do_sys_delete_module+0x10/0x10\n[  250.247338]  do_syscall_64+0xc1/0x360\n[  250.247924]  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFix this by initializing hfc_tl timer with DEFINE_TIMER macro.\nAlso, use mod_timer instead of manual timeout update.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39838",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: prevent NULL pointer dereference in UTF16 conversion\n\nThere can be a NULL pointer dereference bug here. NULL is passed to\n__cifs_sfu_make_node without checks, which passes it unchecked to\ncifs_strndup_to_utf16, which in turn passes it to\ncifs_local_to_utf16_bytes where '*from' is dereferenced, causing a crash.\n\nThis patch adds a check for NULL 'src' in cifs_strndup_to_utf16 and\nreturns NULL early to prevent dereferencing NULL pointer.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39841",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix buffer free/clear order in deferred receive path\n\nFix a use-after-free window by correcting the buffer release sequence in\nthe deferred receive path. The code freed the RQ buffer first and only\nthen cleared the context pointer under the lock. Concurrent paths (e.g.,\nABTS and the repost path) also inspect and release the same pointer under\nthe lock, so the old order could lead to double-free/UAF.\n\nNote that the repost path already uses the correct pattern: detach the\npointer under the lock, then free it after dropping the lock. The\ndeferred path should do the same.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39847",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nppp: fix memory leak in pad_compress_skb\n\nIf alloc_skb() fails in pad_compress_skb(), it returns NULL without\nreleasing the old skb. The caller does:\n\n    skb = pad_compress_skb(ppp, skb);\n    if (!skb)\n        goto drop;\n\ndrop:\n    kfree_skb(skb);\n\nWhen pad_compress_skb() returns NULL, the reference to the old skb is\nlost and kfree_skb(skb) ends up doing nothing, leading to a memory leak.\n\nAlign pad_compress_skb() semantics with realloc(): only free the old\nskb if allocation and compression succeed.  At the call site, use the\nnew_skb variable so the original skb is not lost when pad_compress_skb()\nfails.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39853",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: Fix potential invalid access when MAC list is empty\n\nlist_first_entry() never returns NULL - if the list is empty, it still\nreturns a pointer to an invalid object, leading to potential invalid\nmemory access when dereferenced.\n\nFix this by using list_first_entry_or_null instead of list_first_entry.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39860",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix use-after-free in l2cap_sock_cleanup_listen()\n\nsyzbot reported the splat below without a repro.\n\nIn the splat, a single thread calling bt_accept_dequeue() freed sk\nand touched it after that.\n\nThe root cause would be the racy l2cap_sock_cleanup_listen() call\nadded by the cited commit.\n\nbt_accept_dequeue() is called under lock_sock() except for\nl2cap_sock_release().\n\nTwo threads could see the same socket during the list iteration\nin bt_accept_dequeue():\n\n  CPU1                        CPU2 (close())\n  ----                        ----\n  sock_hold(sk)               sock_hold(sk);\n  lock_sock(sk)   \u003c-- block close()\n  sock_put(sk)\n  bt_accept_unlink(sk)\n    sock_put(sk)  \u003c-- refcnt by bt_accept_enqueue()\n  release_sock(sk)\n                              lock_sock(sk)\n                              sock_put(sk)\n                              bt_accept_unlink(sk)\n                                sock_put(sk)        \u003c-- last refcnt\n                              bt_accept_unlink(sk)  \u003c-- UAF\n\nDepending on the timing, the other thread could show up in the\n\"Freed by task\" part.\n\nLet's call l2cap_sock_cleanup_listen() under lock_sock() in\nl2cap_sock_release().\n\n[0]:\nBUG: KASAN: slab-use-after-free in debug_spin_lock_before kernel/locking/spinlock_debug.c:86 [inline]\nBUG: KASAN: slab-use-after-free in do_raw_spin_lock+0x26f/0x2b0 kernel/locking/spinlock_debug.c:115\nRead of size 4 at addr ffff88803b7eb1c4 by task syz.5.3276/16995\nCPU: 3 UID: 0 PID: 16995 Comm: syz.5.3276 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xcd/0x630 mm/kasan/report.c:482\n kasan_report+0xe0/0x110 mm/kasan/report.c:595\n debug_spin_lock_before kernel/locking/spinlock_debug.c:86 [inline]\n do_raw_spin_lock+0x26f/0x2b0 kernel/locking/spinlock_debug.c:115\n spin_lock_bh include/linux/spinlock.h:356 [inline]\n release_sock+0x21/0x220 net/core/sock.c:3746\n bt_accept_dequeue+0x505/0x600 net/bluetooth/af_bluetooth.c:312\n l2cap_sock_cleanup_listen+0x5c/0x2a0 net/bluetooth/l2cap_sock.c:1451\n l2cap_sock_release+0x5c/0x210 net/bluetooth/l2cap_sock.c:1425\n __sock_release+0xb3/0x270 net/socket.c:649\n sock_close+0x1c/0x30 net/socket.c:1439\n __fput+0x3ff/0xb70 fs/file_table.c:468\n task_work_run+0x14d/0x240 kernel/task_work.c:227\n resume_user_mode_work include/linux/resume_user_mode.h:50 [inline]\n exit_to_user_mode_loop+0xeb/0x110 kernel/entry/common.c:43\n exit_to_user_mode_prepare include/linux/irq-entry-common.h:225 [inline]\n syscall_exit_to_user_mode_work include/linux/entry-common.h:175 [inline]\n syscall_exit_to_user_mode include/linux/entry-common.h:210 [inline]\n do_syscall_64+0x3f6/0x4c0 arch/x86/entry/syscall_64.c:100\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f2accf8ebe9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffdb6cb1378 EFLAGS: 00000246 ORIG_RAX: 00000000000001b4\nRAX: 0000000000000000 RBX: 00000000000426fb RCX: 00007f2accf8ebe9\nRDX: 0000000000000000 RSI: 000000000000001e RDI: 0000000000000003\nRBP: 00007f2acd1b7da0 R08: 0000000000000001 R09: 00000012b6cb166f\nR10: 0000001b30e20000 R11: 0000000000000246 R12: 00007f2acd1b609c\nR13: 00007f2acd1b6090 R14: ffffffffffffffff R15: 00007ffdb6cb1490\n \u003c/TASK\u003e\n\nAllocated by task 5326:\n kasan_save_stack+0x33/0x60 mm/kasan/common.c:47\n kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:388 [inline]\n __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:405\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4365 [inline]\n __kmalloc_nopro\n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39863",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info work\n\nThe brcmf_btcoex_detach() only shuts down the btcoex timer, if the\nflag timer_on is false. However, the brcmf_btcoex_timerfunc(), which\nruns as timer handler, sets timer_on to false. This creates critical\nrace conditions:\n\n1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc()\nis executing, it may observe timer_on as false and skip the call to\ntimer_shutdown_sync().\n\n2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_info\nworker after the cancel_work_sync() has been executed, resulting in\nuse-after-free bugs.\n\nThe use-after-free bugs occur in two distinct scenarios, depending on\nthe timing of when the brcmf_btcoex_info struct is freed relative to\nthe execution of its worker thread.\n\nScenario 1: Freed before the worker is scheduled\n\nThe brcmf_btcoex_info is deallocated before the worker is scheduled.\nA race condition can occur when schedule_work(\u0026bt_local-\u003ework) is\ncalled after the target memory has been freed. The sequence of events\nis detailed below:\n\nCPU0                           | CPU1\nbrcmf_btcoex_detach            | brcmf_btcoex_timerfunc\n                               |   bt_local-\u003etimer_on = false;\n  if (cfg-\u003ebtcoex-\u003etimer_on)   |\n    ...                        |\n  cancel_work_sync();          |\n  ...                          |\n  kfree(cfg-\u003ebtcoex); // FREE  |\n                               |   schedule_work(\u0026bt_local-\u003ework); // USE\n\nScenario 2: Freed after the worker is scheduled\n\nThe brcmf_btcoex_info is freed after the worker has been scheduled\nbut before or during its execution. In this case, statements within\nthe brcmf_btcoex_handler() - such as the container_of macro and\nsubsequent dereferences of the brcmf_btcoex_info object will cause\na use-after-free access. The following timeline illustrates this\nscenario:\n\nCPU0                            | CPU1\nbrcmf_btcoex_detach             | brcmf_btcoex_timerfunc\n                                |   bt_local-\u003etimer_on = false;\n  if (cfg-\u003ebtcoex-\u003etimer_on)    |\n    ...                         |\n  cancel_work_sync();           |\n  ...                           |   schedule_work(); // Reschedule\n                                |\n  kfree(cfg-\u003ebtcoex); // FREE   |   brcmf_btcoex_handler() // Worker\n  /*                            |     btci = container_of(....); // USE\n   The kfree() above could      |     ...\n   also occur at any point      |     btci-\u003e // USE\n   during the worker's execution|\n   */                           |\n\nTo resolve the race conditions, drop the conditional check and call\ntimer_shutdown_sync() directly. It can deactivate the timer reliably,\nregardless of its current state. Once stopped, the timer_on state is\nthen set to false.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39865",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntee: fix NULL pointer dereference in tee_shm_put\n\ntee_shm_put have NULL pointer dereference:\n\n__optee_disable_shm_cache --\u003e\n\tshm = reg_pair_to_ptr(...);//shm maybe return NULL\n        tee_shm_free(shm); --\u003e\n\t\ttee_shm_put(shm);//crash\n\nAdd check in tee_shm_put to fix it.\n\npanic log:\nUnable to handle kernel paging request at virtual address 0000000000100cca\nMem abort info:\nESR = 0x0000000096000004\nEC = 0x25: DABT (current EL), IL = 32 bits\nSET = 0, FnV = 0\nEA = 0, S1PTW = 0\nFSC = 0x04: level 0 translation fault\nData abort info:\nISV = 0, ISS = 0x00000004, ISS2 = 0x00000000\nCM = 0, WnR = 0, TnD = 0, TagAccess = 0\nGCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\nuser pgtable: 4k pages, 48-bit VAs, pgdp=0000002049d07000\n[0000000000100cca] pgd=0000000000000000, p4d=0000000000000000\nInternal error: Oops: 0000000096000004 [#1] SMP\nCPU: 2 PID: 14442 Comm: systemd-sleep Tainted: P OE ------- ----\n6.6.0-39-generic #38\nSource Version: 938b255f6cb8817c95b0dd5c8c2944acfce94b07\nHardware name: greatwall GW-001Y1A-FTH, BIOS Great Wall BIOS V3.0\n10/26/2022\npstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : tee_shm_put+0x24/0x188\nlr : tee_shm_free+0x14/0x28\nsp : ffff001f98f9faf0\nx29: ffff001f98f9faf0 x28: ffff0020df543cc0 x27: 0000000000000000\nx26: ffff001f811344a0 x25: ffff8000818dac00 x24: ffff800082d8d048\nx23: ffff001f850fcd18 x22: 0000000000000001 x21: ffff001f98f9fb88\nx20: ffff001f83e76218 x19: ffff001f83e761e0 x18: 000000000000ffff\nx17: 303a30303a303030 x16: 0000000000000000 x15: 0000000000000003\nx14: 0000000000000001 x13: 0000000000000000 x12: 0101010101010101\nx11: 0000000000000001 x10: 0000000000000001 x9 : ffff800080e08d0c\nx8 : ffff001f98f9fb88 x7 : 0000000000000000 x6 : 0000000000000000\nx5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\nx2 : ffff001f83e761e0 x1 : 00000000ffff001f x0 : 0000000000100cca\nCall trace:\ntee_shm_put+0x24/0x188\ntee_shm_free+0x14/0x28\n__optee_disable_shm_cache+0xa8/0x108\noptee_shutdown+0x28/0x38\nplatform_shutdown+0x28/0x40\ndevice_shutdown+0x144/0x2b0\nkernel_power_off+0x3c/0x80\nhibernate+0x35c/0x388\nstate_store+0x64/0x80\nkobj_attr_store+0x14/0x28\nsysfs_kf_write+0x48/0x60\nkernfs_fop_write_iter+0x128/0x1c0\nvfs_write+0x270/0x370\nksys_write+0x6c/0x100\n__arm64_sys_write+0x20/0x30\ninvoke_syscall+0x4c/0x120\nel0_svc_common.constprop.0+0x44/0xf0\ndo_el0_svc+0x24/0x38\nel0_svc+0x24/0x88\nel0t_64_sync_handler+0x134/0x150\nel0t_64_sync+0x14c/0x15",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39866",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: writeback: fix use-after-free in __mark_inode_dirty()\n\nAn use-after-free issue occurred when __mark_inode_dirty() get the\nbdi_writeback that was in the progress of switching.\n\nCPU: 1 PID: 562 Comm: systemd-random- Not tainted 6.6.56-gb4403bd46a8e #1\n......\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __mark_inode_dirty+0x124/0x418\nlr : __mark_inode_dirty+0x118/0x418\nsp : ffffffc08c9dbbc0\n........\nCall trace:\n __mark_inode_dirty+0x124/0x418\n generic_update_time+0x4c/0x60\n file_modified+0xcc/0xd0\n ext4_buffered_write_iter+0x58/0x124\n ext4_file_write_iter+0x54/0x704\n vfs_write+0x1c0/0x308\n ksys_write+0x74/0x10c\n __arm64_sys_write+0x1c/0x28\n invoke_syscall+0x48/0x114\n el0_svc_common.constprop.0+0xc0/0xe0\n do_el0_svc+0x1c/0x28\n el0_svc+0x40/0xe4\n el0t_64_sync_handler+0x120/0x12c\n el0t_64_sync+0x194/0x198\n\nRoot cause is:\n\nsystemd-random-seed                         kworker\n----------------------------------------------------------------------\n___mark_inode_dirty                     inode_switch_wbs_work_fn\n\n  spin_lock(\u0026inode-\u003ei_lock);\n  inode_attach_wb\n  locked_inode_to_wb_and_lock_list\n     get inode-\u003ei_wb\n     spin_unlock(\u0026inode-\u003ei_lock);\n     spin_lock(\u0026wb-\u003elist_lock)\n  spin_lock(\u0026inode-\u003ei_lock)\n  inode_io_list_move_locked\n  spin_unlock(\u0026wb-\u003elist_lock)\n  spin_unlock(\u0026inode-\u003ei_lock)\n                                    spin_lock(\u0026old_wb-\u003elist_lock)\n                                      inode_do_switch_wbs\n                                        spin_lock(\u0026inode-\u003ei_lock)\n                                        inode-\u003ei_wb = new_wb\n                                        spin_unlock(\u0026inode-\u003ei_lock)\n                                    spin_unlock(\u0026old_wb-\u003elist_lock)\n                                    wb_put_many(old_wb, nr_switched)\n                                      cgwb_release\n                                      old wb released\n  wb_wakeup_delayed() accesses wb,\n  then trigger the use-after-free\n  issue\n\nFix this race condition by holding inode spinlock until\nwb_wakeup_delayed() finished.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39869",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: ti: edma: Fix memory allocation size for queue_priority_map\n\nFix a critical memory allocation bug in edma_setup_from_hw() where\nqueue_priority_map was allocated with insufficient memory. The code\ndeclared queue_priority_map as s8 (*)[2] (pointer to array of 2 s8),\nbut allocated memory using sizeof(s8) instead of the correct size.\n\nThis caused out-of-bounds memory writes when accessing:\n  queue_priority_map[i][0] = i;\n  queue_priority_map[i][1] = i;\n\nThe bug manifested as kernel crashes with \"Oops - undefined instruction\"\non ARM platforms (BeagleBoard-X15) during EDMA driver probe, as the\nmemory corruption triggered kernel hardening features on Clang.\n\nChange the allocation to use sizeof(*queue_priority_map) which\nautomatically gets the correct size for the 2D array structure.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39876",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fec: Fix possible NPD in fec_enet_phy_reset_after_clk_enable()\n\nThe function of_phy_find_device may return NULL, so we need to take\ncare before dereferencing phy_dev.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39885",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix recursive semaphore deadlock in fiemap call\n\nsyzbot detected a OCFS2 hang due to a recursive semaphore on a\nFS_IOC_FIEMAP of the extent list on a specially crafted mmap file.\n\ncontext_switch kernel/sched/core.c:5357 [inline]\n   __schedule+0x1798/0x4cc0 kernel/sched/core.c:6961\n   __schedule_loop kernel/sched/core.c:7043 [inline]\n   schedule+0x165/0x360 kernel/sched/core.c:7058\n   schedule_preempt_disabled+0x13/0x30 kernel/sched/core.c:7115\n   rwsem_down_write_slowpath+0x872/0xfe0 kernel/locking/rwsem.c:1185\n   __down_write_common kernel/locking/rwsem.c:1317 [inline]\n   __down_write kernel/locking/rwsem.c:1326 [inline]\n   down_write+0x1ab/0x1f0 kernel/locking/rwsem.c:1591\n   ocfs2_page_mkwrite+0x2ff/0xc40 fs/ocfs2/mmap.c:142\n   do_page_mkwrite+0x14d/0x310 mm/memory.c:3361\n   wp_page_shared mm/memory.c:3762 [inline]\n   do_wp_page+0x268d/0x5800 mm/memory.c:3981\n   handle_pte_fault mm/memory.c:6068 [inline]\n   __handle_mm_fault+0x1033/0x5440 mm/memory.c:6195\n   handle_mm_fault+0x40a/0x8e0 mm/memory.c:6364\n   do_user_addr_fault+0x764/0x1390 arch/x86/mm/fault.c:1387\n   handle_page_fault arch/x86/mm/fault.c:1476 [inline]\n   exc_page_fault+0x76/0xf0 arch/x86/mm/fault.c:1532\n   asm_exc_page_fault+0x26/0x30 arch/x86/include/asm/idtentry.h:623\nRIP: 0010:copy_user_generic arch/x86/include/asm/uaccess_64.h:126 [inline]\nRIP: 0010:raw_copy_to_user arch/x86/include/asm/uaccess_64.h:147 [inline]\nRIP: 0010:_inline_copy_to_user include/linux/uaccess.h:197 [inline]\nRIP: 0010:_copy_to_user+0x85/0xb0 lib/usercopy.c:26\nCode: e8 00 bc f7 fc 4d 39 fc 72 3d 4d 39 ec 77 38 e8 91 b9 f7 fc 4c 89\nf7 89 de e8 47 25 5b fd 0f 01 cb 4c 89 ff 48 89 d9 4c 89 f6 \u003cf3\u003e a4 0f\n1f 00 48 89 cb 0f 01 ca 48 89 d8 5b 41 5c 41 5d 41 5e 41\nRSP: 0018:ffffc9000403f950 EFLAGS: 00050256\nRAX: ffffffff84c7f101 RBX: 0000000000000038 RCX: 0000000000000038\nRDX: 0000000000000000 RSI: ffffc9000403f9e0 RDI: 0000200000000060\nRBP: ffffc9000403fa90 R08: ffffc9000403fa17 R09: 1ffff92000807f42\nR10: dffffc0000000000 R11: fffff52000807f43 R12: 0000200000000098\nR13: 00007ffffffff000 R14: ffffc9000403f9e0 R15: 0000200000000060\n   copy_to_user include/linux/uaccess.h:225 [inline]\n   fiemap_fill_next_extent+0x1c0/0x390 fs/ioctl.c:145\n   ocfs2_fiemap+0x888/0xc90 fs/ocfs2/extent_map.c:806\n   ioctl_fiemap fs/ioctl.c:220 [inline]\n   do_vfs_ioctl+0x1173/0x1430 fs/ioctl.c:532\n   __do_sys_ioctl fs/ioctl.c:596 [inline]\n   __se_sys_ioctl+0x82/0x170 fs/ioctl.c:584\n   do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n   do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f5f13850fd9\nRSP: 002b:00007ffe3b3518b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000200000000000 RCX: 00007f5f13850fd9\nRDX: 0000200000000040 RSI: 00000000c020660b RDI: 0000000000000004\nRBP: 6165627472616568 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007ffe3b3518f0\nR13: 00007ffe3b351b18 R14: 431bde82d7b634db R15: 00007f5f1389a03b\n\nocfs2_fiemap() takes a read lock of the ip_alloc_sem semaphore (since\nv2.6.22-527-g7307de80510a) and calls fiemap_fill_next_extent() to read the\nextent list of this running mmap executable.  The user supplied buffer to\nhold the fiemap information page faults calling ocfs2_page_mkwrite() which\nwill take a write lock (since v2.6.27-38-g00dc417fa3e7) of the same\nsemaphore.  This recursive semaphore will hold filesystem locks and causes\na hang of the fileystem.\n\nThe ip_alloc_sem protects the inode extent list and size.  Release the\nread semphore before calling fiemap_fill_next_extent() in ocfs2_fiemap()\nand ocfs2_fiemap_inline().  This does an unnecessary semaphore lock/unlock\non the last extent but simplifies the error path.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39898",
      "Description": "This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39911",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix IRQ freeing in i40e_vsi_request_irq_msix error path\n\nIf request_irq() in i40e_vsi_request_irq_msix() fails in an iteration\nlater than the first, the error path wants to free the IRQs requested\nso far. However, it uses the wrong dev_id argument for free_irq(), so\nit does not free the IRQs correctly and instead triggers the warning:\n\n Trying to free already-free IRQ 173\n WARNING: CPU: 25 PID: 1091 at kernel/irq/manage.c:1829 __free_irq+0x192/0x2c0\n Modules linked in: i40e(+) [...]\n CPU: 25 UID: 0 PID: 1091 Comm: NetworkManager Not tainted 6.17.0-rc1+ #1 PREEMPT(lazy)\n Hardware name: [...]\n RIP: 0010:__free_irq+0x192/0x2c0\n [...]\n Call Trace:\n  \u003cTASK\u003e\n  free_irq+0x32/0x70\n  i40e_vsi_request_irq_msix.cold+0x63/0x8b [i40e]\n  i40e_vsi_request_irq+0x79/0x80 [i40e]\n  i40e_vsi_open+0x21f/0x2f0 [i40e]\n  i40e_open+0x63/0x130 [i40e]\n  __dev_open+0xfc/0x210\n  __dev_change_flags+0x1fc/0x240\n  netif_change_flags+0x27/0x70\n  do_setlink.isra.0+0x341/0xc70\n  rtnl_newlink+0x468/0x860\n  rtnetlink_rcv_msg+0x375/0x450\n  netlink_rcv_skb+0x5c/0x110\n  netlink_unicast+0x288/0x3c0\n  netlink_sendmsg+0x20d/0x430\n  ____sys_sendmsg+0x3a2/0x3d0\n  ___sys_sendmsg+0x99/0xe0\n  __sys_sendmsg+0x8a/0xf0\n  do_syscall_64+0x82/0x2c0\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  [...]\n  \u003c/TASK\u003e\n ---[ end trace 0000000000000000 ]---\n\nUse the same dev_id for free_irq() as for request_irq().\n\nI tested this with inserting code to fail intentionally.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39923",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: qcom: bam_dma: Fix DT error handling for num-channels/ees\n\nWhen we don't have a clock specified in the device tree, we have no way to\nensure the BAM is on. This is often the case for remotely-controlled or\nremotely-powered BAM instances. In this case, we need to read num-channels\nfrom the DT to have all the necessary information to complete probing.\n\nHowever, at the moment invalid device trees without clock and without\nnum-channels still continue probing, because the error handling is missing\nreturn statements. The driver will then later try to read the number of\nchannels from the registers. This is unsafe, because it relies on boot\nfirmware and lucky timing to succeed. Unfortunately, the lack of proper\nerror handling here has been abused for several Qualcomm SoCs upstream,\ncausing early boot crashes in several situations [1, 2].\n\nAvoid these early crashes by erroring out when any of the required DT\nproperties are missing. Note that this will break some of the existing DTs\nupstream (mainly BAM instances related to the crypto engine). However,\nclearly these DTs have never been tested properly, since the error in the\nkernel log was just ignored. It's safer to disable the crypto engine for\nthese broken DTBs.\n\n[1]: https://lore.kernel.org/r/CY01EKQVWE36.B9X5TDXAREPF@fairphone.com/\n[2]: https://lore.kernel.org/r/20230626145959.646747-1-krzysztof.kozlowski@linaro.org/",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39929",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix smbdirect_recv_io leak in smbd_negotiate() error path\n\nDuring tests of another unrelated patch I was able to trigger this\nerror: Objects remaining on __kmem_cache_shutdown()",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39931",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: af_alg - Set merge to zero early in af_alg_sendmsg\n\nIf an error causes af_alg_sendmsg to abort, ctx-\u003emerge may contain\na garbage value from the previous loop.  This may then trigger a\ncrash on the next entry into af_alg_sendmsg when it attempts to do\na merge that can't be done.\n\nFix this by setting ctx-\u003emerge to zero near the start of the loop.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39945",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncnic: Fix use-after-free bugs in cnic_delete_task\n\nThe original code uses cancel_delayed_work() in cnic_cm_stop_bnx2x_hw(),\nwhich does not guarantee that the delayed work item 'delete_task' has\nfully completed if it was already running. Additionally, the delayed work\nitem is cyclic, the flush_workqueue() in cnic_cm_stop_bnx2x_hw() only\nblocks and waits for work items that were already queued to the\nworkqueue prior to its invocation. Any work items submitted after\nflush_workqueue() is called are not included in the set of tasks that the\nflush operation awaits. This means that after the cyclic work items have\nfinished executing, a delayed work item may still exist in the workqueue.\nThis leads to use-after-free scenarios where the cnic_dev is deallocated\nby cnic_free_dev(), while delete_task remains active and attempt to\ndereference cnic_dev in cnic_delete_task().\n\nA typical race condition is illustrated below:\n\nCPU 0 (cleanup)              | CPU 1 (delayed work callback)\ncnic_netdev_event()          |\n  cnic_stop_hw()             | cnic_delete_task()\n    cnic_cm_stop_bnx2x_hw()  | ...\n      cancel_delayed_work()  | /* the queue_delayed_work()\n      flush_workqueue()      |    executes after flush_workqueue()*/\n                             | queue_delayed_work()\n  cnic_free_dev(dev)//free   | cnic_delete_task() //new instance\n                             |   dev = cp-\u003edev; //use\n\nReplace cancel_delayed_work() with cancel_delayed_work_sync() to ensure\nthat the cyclic delayed work item is properly canceled and that any\nongoing execution of the work item completes before the cnic_dev is\ndeallocated. Furthermore, since cancel_delayed_work_sync() uses\n__flush_work(work, true) to synchronously wait for any currently\nexecuting instance of the work item to finish, the flush_workqueue()\nbecomes redundant and should be removed.\n\nThis bug was identified through static analysis. To reproduce the issue\nand validate the fix, I simulated the cnic PCI device in QEMU and\nintroduced intentional delays - such as inserting calls to ssleep()\nwithin the cnic_delete_task() function - to increase the likelihood\nof triggering the bug.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39949",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nqed: Don't collect too many protection override GRC elements\n\nIn the protection override dump path, the firmware can return far too\nmany GRC elements, resulting in attempting to write past the end of the\npreviously-kmalloc'ed dump buffer.\n\nThis will result in a kernel panic with reason:\n\n BUG: unable to handle kernel paging request at ADDRESS\n\nwhere \"ADDRESS\" is just past the end of the protection override dump\nbuffer. The start address of the buffer is:\n p_hwfn-\u003ecdev-\u003edbg_features[DBG_FEATURE_PROTECTION_OVERRIDE].dump_buf\nand the size of the buffer is buf_size in the same data structure.\n\nThe panic can be arrived at from either the qede Ethernet driver path:\n\n    [exception RIP: qed_grc_dump_addr_range+0x108]\n qed_protection_override_dump at ffffffffc02662ed [qed]\n qed_dbg_protection_override_dump at ffffffffc0267792 [qed]\n qed_dbg_feature at ffffffffc026aa8f [qed]\n qed_dbg_all_data at ffffffffc026b211 [qed]\n qed_fw_fatal_reporter_dump at ffffffffc027298a [qed]\n devlink_health_do_dump at ffffffff82497f61\n devlink_health_report at ffffffff8249cf29\n qed_report_fatal_error at ffffffffc0272baf [qed]\n qede_sp_task at ffffffffc045ed32 [qede]\n process_one_work at ffffffff81d19783\n\nor the qedf storage driver path:\n\n    [exception RIP: qed_grc_dump_addr_range+0x108]\n qed_protection_override_dump at ffffffffc068b2ed [qed]\n qed_dbg_protection_override_dump at ffffffffc068c792 [qed]\n qed_dbg_feature at ffffffffc068fa8f [qed]\n qed_dbg_all_data at ffffffffc0690211 [qed]\n qed_fw_fatal_reporter_dump at ffffffffc069798a [qed]\n devlink_health_do_dump at ffffffff8aa95e51\n devlink_health_report at ffffffff8aa9ae19\n qed_report_fatal_error at ffffffffc0697baf [qed]\n qed_hw_err_notify at ffffffffc06d32d7 [qed]\n qed_spq_post at ffffffffc06b1011 [qed]\n qed_fcoe_destroy_conn at ffffffffc06b2e91 [qed]\n qedf_cleanup_fcport at ffffffffc05e7597 [qedf]\n qedf_rport_event_handler at ffffffffc05e7bf7 [qedf]\n fc_rport_work at ffffffffc02da715 [libfc]\n process_one_work at ffffffff8a319663\n\nResolve this by clamping the firmware's return value to the maximum\nnumber of legal elements the firmware should return.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39955",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: Clear tcp_sk(sk)-\u003efastopen_rsk in tcp_disconnect().\n\nsyzbot reported the splat below where a socket had tcp_sk(sk)-\u003efastopen_rsk\nin the TCP_ESTABLISHED state. [0]\n\nsyzbot reused the server-side TCP Fast Open socket as a new client before\nthe TFO socket completes 3WHS:\n\n  1. accept()\n  2. connect(AF_UNSPEC)\n  3. connect() to another destination\n\nAs of accept(), sk-\u003esk_state is TCP_SYN_RECV, and tcp_disconnect() changes\nit to TCP_CLOSE and makes connect() possible, which restarts timers.\n\nSince tcp_disconnect() forgot to clear tcp_sk(sk)-\u003efastopen_rsk, the\nretransmit timer triggered the warning and the intended packet was not\nretransmitted.\n\nLet's call reqsk_fastopen_remove() in tcp_disconnect().\n\n[0]:\nWARNING: CPU: 2 PID: 0 at net/ipv4/tcp_timer.c:542 tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))\nModules linked in:\nCPU: 2 UID: 0 PID: 0 Comm: swapper/2 Not tainted 6.17.0-rc5-g201825fb4278 #62 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\nRIP: 0010:tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))\nCode: 41 55 41 54 55 53 48 8b af b8 08 00 00 48 89 fb 48 85 ed 0f 84 55 01 00 00 0f b6 47 12 3c 03 74 0c 0f b6 47 12 3c 04 74 04 90 \u003c0f\u003e 0b 90 48 8b 85 c0 00 00 00 48 89 ef 48 8b 40 30 e8 6a 4f 06 3e\nRSP: 0018:ffffc900002f8d40 EFLAGS: 00010293\nRAX: 0000000000000002 RBX: ffff888106911400 RCX: 0000000000000017\nRDX: 0000000002517619 RSI: ffffffff83764080 RDI: ffff888106911400\nRBP: ffff888106d5c000 R08: 0000000000000001 R09: ffffc900002f8de8\nR10: 00000000000000c2 R11: ffffc900002f8ff8 R12: ffff888106911540\nR13: ffff888106911480 R14: ffff888106911840 R15: ffffc900002f8de0\nFS:  0000000000000000(0000) GS:ffff88907b768000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f8044d69d90 CR3: 0000000002c30003 CR4: 0000000000370ef0\nCall Trace:\n \u003cIRQ\u003e\n tcp_write_timer (net/ipv4/tcp_timer.c:738)\n call_timer_fn (kernel/time/timer.c:1747)\n __run_timers (kernel/time/timer.c:1799 kernel/time/timer.c:2372)\n timer_expire_remote (kernel/time/timer.c:2385 kernel/time/timer.c:2376 kernel/time/timer.c:2135)\n tmigr_handle_remote_up (kernel/time/timer_migration.c:944 kernel/time/timer_migration.c:1035)\n __walk_groups.isra.0 (kernel/time/timer_migration.c:533 (discriminator 1))\n tmigr_handle_remote (kernel/time/timer_migration.c:1096)\n handle_softirqs (./arch/x86/include/asm/jump_label.h:36 ./include/trace/events/irq.h:142 kernel/softirq.c:580)\n irq_exit_rcu (kernel/softirq.c:614 kernel/softirq.c:453 kernel/softirq.c:680 kernel/softirq.c:696)\n sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1050 (discriminator 35) arch/x86/kernel/apic/apic.c:1050 (discriminator 35))\n \u003c/IRQ\u003e",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39967",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbcon: fix integer overflow in fbcon_do_set_font\n\nFix integer overflow vulnerabilities in fbcon_do_set_font() where font\nsize calculations could overflow when handling user-controlled font\nparameters.\n\nThe vulnerabilities occur when:\n1. CALC_FONTSZ(h, pitch, charcount) performs h * pith * charcount\n   multiplication with user-controlled values that can overflow.\n2. FONT_EXTRA_WORDS * sizeof(int) + size addition can also overflow\n3. This results in smaller allocations than expected, leading to buffer\n   overflows during font data copying.\n\nAdd explicit overflow checking using check_mul_overflow() and\ncheck_add_overflow() kernel helpers to safety validate all size\ncalculations before allocation.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39968",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: add max boundary check for VF filters\n\nThere is no check for max filters that VF can request. Add it.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39970",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix input validation logic for action_meta\n\nFix condition to check 'greater or equal' to prevent OOB dereference.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39971",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix idx validation in config queues msg\n\nEnsure idx is within range of active/initialized TCs when iterating over\nvf-\u003ech[idx] in i40e_vc_config_queues_msg().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39972",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix idx validation in i40e_validate_queue_map\n\nEnsure idx is within range of active/initialized TCs when iterating over\nvf-\u003ech[idx] in i40e_validate_queue_map().",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39973",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: add validation for ring_len param\n\nThe `ring_len` parameter provided by the virtual function (VF)\nis assigned directly to the hardware memory context (HMC) without\nany validation.\n\nTo address this, introduce an upper boundary check for both Tx and Rx\nqueue lengths. The maximum number of descriptors supported by the\nhardware is 8k-32.\nAdditionally, enforce alignment constraints: Tx rings must be a multiple\nof 8, and Rx rings must be a multiple of 32.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-39997",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: fix race condition to UAF in snd_usbmidi_free\n\nThe previous commit 0718a78f6a9f (\"ALSA: usb-audio: Kill timer properly at\nremoval\") patched a UAF issue caused by the error timer.\n\nHowever, because the error timer kill added in this patch occurs after the\nendpoint delete, a race condition to UAF still occurs, albeit rarely.\n\nAdditionally, since kill-cleanup for urb is also missing, freed memory can\nbe accessed in interrupt context related to urb, which can cause UAF.\n\nTherefore, to prevent this, error timer and urb must be killed before\nfreeing the heap memory.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40001",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mvsas: Fix use-after-free bugs in mvs_work_queue\n\nDuring the detaching of Marvell's SAS/SATA controller, the original code\ncalls cancel_delayed_work() in mvs_free() to cancel the delayed work\nitem mwq-\u003ework_q. However, if mwq-\u003ework_q is already running, the\ncancel_delayed_work() may fail to cancel it. This can lead to\nuse-after-free scenarios where mvs_free() frees the mvs_info while\nmvs_work_queue() is still executing and attempts to access the\nalready-freed mvs_info.\n\nA typical race condition is illustrated below:\n\nCPU 0 (remove)            | CPU 1 (delayed work callback)\nmvs_pci_remove()          |\n  mvs_free()              | mvs_work_queue()\n    cancel_delayed_work() |\n      kfree(mvi)          |\n                          |   mvi-\u003e // UAF\n\nReplace cancel_delayed_work() with cancel_delayed_work_sync() to ensure\nthat the delayed work item is properly canceled and any executing\ndelayed work item completes before the mvs_info is deallocated.\n\nThis bug was found by static analysis.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40018",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipvs: Defer ip_vs_ftp unregister during netns cleanup\n\nOn the netns cleanup path, __ip_vs_ftp_exit() may unregister ip_vs_ftp\nbefore connections with valid cp-\u003eapp pointers are flushed, leading to a\nuse-after-free.\n\nFix this by introducing a global `exiting_module` flag, set to true in\nip_vs_ftp_exit() before unregistering the pernet subsystem. In\n__ip_vs_ftp_exit(), skip ip_vs_ftp unregister if called during netns\ncleanup (when exiting_module is false) and defer it to\n__ip_vs_cleanup_batch(), which unregisters all apps after all connections\nare flushed. If called during module exit, unregister ip_vs_ftp\nimmediately.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40027",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/9p: fix double req put in p9_fd_cancelled\n\nSyzkaller reports a KASAN issue as below:\n\ngeneral protection fault, probably for non-canonical address 0xfbd59c0000000021: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: maybe wild-memory-access in range [0xdead000000000108-0xdead00000000010f]\nCPU: 0 PID: 5083 Comm: syz-executor.2 Not tainted 6.1.134-syzkaller-00037-g855bd1d7d838 #0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nRIP: 0010:__list_del include/linux/list.h:114 [inline]\nRIP: 0010:__list_del_entry include/linux/list.h:137 [inline]\nRIP: 0010:list_del include/linux/list.h:148 [inline]\nRIP: 0010:p9_fd_cancelled+0xe9/0x200 net/9p/trans_fd.c:734\n\nCall Trace:\n \u003cTASK\u003e\n p9_client_flush+0x351/0x440 net/9p/client.c:614\n p9_client_rpc+0xb6b/0xc70 net/9p/client.c:734\n p9_client_version net/9p/client.c:920 [inline]\n p9_client_create+0xb51/0x1240 net/9p/client.c:1027\n v9fs_session_init+0x1f0/0x18f0 fs/9p/v9fs.c:408\n v9fs_mount+0xba/0xcb0 fs/9p/vfs_super.c:126\n legacy_get_tree+0x108/0x220 fs/fs_context.c:632\n vfs_get_tree+0x8e/0x300 fs/super.c:1573\n do_new_mount fs/namespace.c:3056 [inline]\n path_mount+0x6a6/0x1e90 fs/namespace.c:3386\n do_mount fs/namespace.c:3399 [inline]\n __do_sys_mount fs/namespace.c:3607 [inline]\n __se_sys_mount fs/namespace.c:3584 [inline]\n __x64_sys_mount+0x283/0x300 fs/namespace.c:3584\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nThis happens because of a race condition between:\n\n- The 9p client sending an invalid flush request and later cleaning it up;\n- The 9p client in p9_read_work() canceled all pending requests.\n\n      Thread 1                              Thread 2\n    ...\n    p9_client_create()\n    ...\n    p9_fd_create()\n    ...\n    p9_conn_create()\n    ...\n    // start Thread 2\n    INIT_WORK(\u0026m-\u003erq, p9_read_work);\n                                        p9_read_work()\n    ...\n    p9_client_rpc()\n    ...\n                                        ...\n                                        p9_conn_cancel()\n                                        ...\n                                        spin_lock(\u0026m-\u003ereq_lock);\n    ...\n    p9_fd_cancelled()\n    ...\n                                        ...\n                                        spin_unlock(\u0026m-\u003ereq_lock);\n                                        // status rewrite\n                                        p9_client_cb(m-\u003eclient, req, REQ_STATUS_ERROR)\n                                        // first remove\n                                        list_del(\u0026req-\u003ereq_list);\n                                        ...\n\n    spin_lock(\u0026m-\u003ereq_lock)\n    ...\n    // second remove\n    list_del(\u0026req-\u003ereq_list);\n    spin_unlock(\u0026m-\u003ereq_lock)\n  ...\n\nCommit 74d6a5d56629 (\"9p/trans_fd: Fix concurrency del of req_list in\np9_fd_cancelled/p9_read_work\") fixes a concurrency issue in the 9p filesystem\nclient where the req_list could be deleted simultaneously by both\np9_read_work and p9_fd_cancelled functions, but for the case where req-\u003estatus\nequals REQ_STATUS_RCVD.\n\nUpdate the check for req-\u003estatus in p9_fd_cancelled to skip processing not\njust received requests, but anything that is not SENT, as whatever\nchanged the state from SENT also removed the request from its list.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.\n\n[updated the check from status == RECV || status == ERROR to status != SENT]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40030",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: check the return value of pinmux_ops::get_function_name()\n\nWhile the API contract in docs doesn't specify it explicitly, the\ngeneric implementation of the get_function_name() callback from struct\npinmux_ops - pinmux_generic_get_function_name() - can fail and return\nNULL. This is already checked in pinmux_check_ops() so add a similar\ncheck in pinmux_func_name_to_selector() instead of passing the returned\npointer right down to strcmp() where the NULL can get dereferenced. This\nis normal operation when adding new pinfunctions.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40040",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/ksm: fix flag-dropping behavior in ksm_madvise\n\nsyzkaller discovered the following crash: (kernel BUG)\n\n[   44.607039] ------------[ cut here ]------------\n[   44.607422] kernel BUG at mm/userfaultfd.c:2067!\n[   44.608148] Oops: invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN NOPTI\n[   44.608814] CPU: 1 UID: 0 PID: 2475 Comm: reproducer Not tainted 6.16.0-rc6 #1 PREEMPT(none)\n[   44.609635] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[   44.610695] RIP: 0010:userfaultfd_release_all+0x3a8/0x460\n\n\u003csnip other registers, drop unreliable trace\u003e\n\n[   44.617726] Call Trace:\n[   44.617926]  \u003cTASK\u003e\n[   44.619284]  userfaultfd_release+0xef/0x1b0\n[   44.620976]  __fput+0x3f9/0xb60\n[   44.621240]  fput_close_sync+0x110/0x210\n[   44.622222]  __x64_sys_close+0x8f/0x120\n[   44.622530]  do_syscall_64+0x5b/0x2f0\n[   44.622840]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[   44.623244] RIP: 0033:0x7f365bb3f227\n\nKernel panics because it detects UFFD inconsistency during\nuserfaultfd_release_all().  Specifically, a VMA which has a valid pointer\nto vma-\u003evm_userfaultfd_ctx, but no UFFD flags in vma-\u003evm_flags.\n\nThe inconsistency is caused in ksm_madvise(): when user calls madvise()\nwith MADV_UNMEARGEABLE on a VMA that is registered for UFFD in MINOR mode,\nit accidentally clears all flags stored in the upper 32 bits of\nvma-\u003evm_flags.\n\nAssuming x86_64 kernel build, unsigned long is 64-bit and unsigned int and\nint are 32-bit wide.  This setup causes the following mishap during the \u0026=\n~VM_MERGEABLE assignment.\n\nVM_MERGEABLE is a 32-bit constant of type unsigned int, 0x8000'0000. \nAfter ~ is applied, it becomes 0x7fff'ffff unsigned int, which is then\npromoted to unsigned long before the \u0026 operation.  This promotion fills\nupper 32 bits with leading 0s, as we're doing unsigned conversion (and\neven for a signed conversion, this wouldn't help as the leading bit is 0).\n\u0026 operation thus ends up AND-ing vm_flags with 0x0000'0000'7fff'ffff\ninstead of intended 0xffff'ffff'7fff'ffff and hence accidentally clears\nthe upper 32-bits of its value.\n\nFix it by changing `VM_MERGEABLE` constant to unsigned long, using the\nBIT() macro.\n\nNote: other VM_* flags are not affected: This only happens to the\nVM_MERGEABLE flag, as the other VM_* flags are all constants of type int\nand after ~ operation, they end up with leading 1 and are thus converted\nto unsigned long with leading 1s.\n\nNote 2:\nAfter commit 31defc3b01d9 (\"userfaultfd: remove (VM_)BUG_ON()s\"), this is\nno longer a kernel BUG, but a WARNING at the same place:\n\n[   45.595973] WARNING: CPU: 1 PID: 2474 at mm/userfaultfd.c:2067\n\nbut the root-cause (flag-drop) remains the same.\n\n[akpm@linux-foundation.org: rust bindgen wasn't able to handle BIT(), from Miguel]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40044",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: udf: fix OOB read in lengthAllocDescs handling\n\nWhen parsing Allocation Extent Descriptor, lengthAllocDescs comes from\non-disk data and must be validated against the block size. Crafted or\ncorrupted images may set lengthAllocDescs so that the total descriptor\nlength (sizeof(allocExtDesc) + lengthAllocDescs) exceeds the buffer,\nleading udf_update_tag() to call crc_itu_t() on out-of-bounds memory and\ntrigger a KASAN use-after-free read.\n\nBUG: KASAN: use-after-free in crc_itu_t+0x1d5/0x2b0 lib/crc-itu-t.c:60\nRead of size 1 at addr ffff888041e7d000 by task syz-executor317/5309\n\nCPU: 0 UID: 0 PID: 5309 Comm: syz-executor317 Not tainted 6.12.0-rc4-syzkaller-00261-g850925a8133c #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n crc_itu_t+0x1d5/0x2b0 lib/crc-itu-t.c:60\n udf_update_tag+0x70/0x6a0 fs/udf/misc.c:261\n udf_write_aext+0x4d8/0x7b0 fs/udf/inode.c:2179\n extent_trunc+0x2f7/0x4a0 fs/udf/truncate.c:46\n udf_truncate_tail_extent+0x527/0x7e0 fs/udf/truncate.c:106\n udf_release_file+0xc1/0x120 fs/udf/file.c:185\n __fput+0x23f/0x880 fs/file_table.c:431\n task_work_run+0x24f/0x310 kernel/task_work.c:239\n exit_task_work include/linux/task_work.h:43 [inline]\n do_exit+0xa2f/0x28e0 kernel/exit.c:939\n do_group_exit+0x207/0x2c0 kernel/exit.c:1088\n __do_sys_exit_group kernel/exit.c:1099 [inline]\n __se_sys_exit_group kernel/exit.c:1097 [inline]\n __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1097\n x64_sys_call+0x2634/0x2640 arch/x86/include/generated/asm/syscalls_64.h:232\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n \u003c/TASK\u003e\n\nValidate the computed total length against epos-\u003ebh-\u003eb_size.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40048",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuio_hv_generic: Let userspace take care of interrupt mask\n\nRemove the logic to set interrupt mask by default in uio_hv_generic\ndriver as the interrupt mask value is supposed to be controlled\ncompletely by the user space. If the mask bit gets changed\nby the driver, concurrently with user mode operating on the ring,\nthe mask bit may be set when it is supposed to be clear, and the\nuser-mode driver will miss an interrupt which will cause a hang.\n\nFor eg- when the driver sets inbound ring buffer interrupt mask to 1,\nthe host does not interrupt the guest on the UIO VMBus channel.\nHowever, setting the mask does not prevent the host from putting a\nmessage in the inbound ring buffer.  So let's assume that happens,\nthe host puts a message into the ring buffer but does not interrupt.\n\nSubsequently, the user space code in the guest sets the inbound ring\nbuffer interrupt mask to 0, saying \"Hey, I'm ready for interrupts\".\nUser space code then calls pread() to wait for an interrupt.\nThen one of two things happens:\n\n* The host never sends another message. So the pread() waits forever.\n* The host does send another message. But because there's already a\n  message in the ring buffer, it doesn't generate an interrupt.\n  This is the correct behavior, because the host should only send an\n  interrupt when the inbound ring buffer transitions from empty to\n  not-empty. Adding an additional message to a ring buffer that is not\n  empty is not supposed to generate an interrupt on the guest.\n  Since the guest is waiting in pread() and not removing messages from\n  the ring buffer, the pread() waits forever.\n\nThis could be easily reproduced in hv_fcopy_uio_daemon if we delay\nsetting interrupt mask to 0.\n\nSimilarly if hv_uio_channel_cb() sets the interrupt_mask to 1,\nthere's a race condition. Once user space empties the inbound ring\nbuffer, but before user space sets interrupt_mask to 0, the host could\nput another message in the ring buffer but it wouldn't interrupt.\nThen the next pread() would hang.\n\nFix these by removing all instances where interrupt_mask is changed,\nwhile keeping the one in set_event() unchanged to enable userspace\ncontrol the interrupt mask by writing 0/1 to /dev/uioX.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40049",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: fix uninit-value in squashfs_get_parent\n\nSyzkaller reports a \"KMSAN: uninit-value in squashfs_get_parent\" bug.\n\nThis is caused by open_by_handle_at() being called with a file handle\ncontaining an invalid parent inode number.  In particular the inode number\nis that of a symbolic link, rather than a directory.\n\nSquashfs_get_parent() gets called with that symbolic link inode, and\naccesses the parent member field.\n\n\tunsigned int parent_ino = squashfs_i(inode)-\u003eparent;\n\nBecause non-directory inodes in Squashfs do not have a parent value, this\nis uninitialised, and this causes an uninitialised value access.\n\nThe fix is to initialise parent with the invalid inode 0, which will cause\nan EINVAL error to be returned.\n\nRegular inodes used to share the parent field with the block_list_start\nfield.  This is removed in this commit to enable the parent field to\ncontain the invalid inode number 0.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40055",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix double free in user_cluster_connect()\n\nuser_cluster_disconnect() frees \"conn-\u003ecc_private\" which is \"lc\" but then\nthe error handling frees \"lc\" a second time.  Set \"lc\" to NULL on this\npath to avoid a double free.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40070",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npps: fix warning in pps_register_cdev when register device fail\n\nSimilar to previous commit 2a934fdb01db (\"media: v4l2-dev: fix error\nhandling in __video_register_device()\"), the release hook should be set\nbefore device_register(). Otherwise, when device_register() return error\nand put_device() try to callback the release function, the below warning\nmay happen.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 1 PID: 4760 at drivers/base/core.c:2567 device_release+0x1bd/0x240 drivers/base/core.c:2567\n  Modules linked in:\n  CPU: 1 UID: 0 PID: 4760 Comm: syz.4.914 Not tainted 6.17.0-rc3+ #1 NONE\n  RIP: 0010:device_release+0x1bd/0x240 drivers/base/core.c:2567\n  Call Trace:\n   \u003cTASK\u003e\n   kobject_cleanup+0x136/0x410 lib/kobject.c:689\n   kobject_release lib/kobject.c:720 [inline]\n   kref_put include/linux/kref.h:65 [inline]\n   kobject_put+0xe9/0x130 lib/kobject.c:737\n   put_device+0x24/0x30 drivers/base/core.c:3797\n   pps_register_cdev+0x2da/0x370 drivers/pps/pps.c:402\n   pps_register_source+0x2f6/0x480 drivers/pps/kapi.c:108\n   pps_tty_open+0x190/0x310 drivers/pps/clients/pps-ldisc.c:57\n   tty_ldisc_open+0xa7/0x120 drivers/tty/tty_ldisc.c:432\n   tty_set_ldisc+0x333/0x780 drivers/tty/tty_ldisc.c:563\n   tiocsetd drivers/tty/tty_io.c:2429 [inline]\n   tty_ioctl+0x5d1/0x1700 drivers/tty/tty_io.c:2728\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:598 [inline]\n   __se_sys_ioctl fs/ioctl.c:584 [inline]\n   __x64_sys_ioctl+0x194/0x210 fs/ioctl.c:584\n   do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n   do_syscall_64+0x5f/0x2a0 arch/x86/entry/syscall_64.c:94\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n   \u003c/TASK\u003e\n\nBefore commit c79a39dc8d06 (\"pps: Fix a use-after-free\"),\npps_register_cdev() call device_create() to create pps-\u003edev, which will\ninit dev-\u003erelease to device_create_release(). Now the comment is outdated,\njust remove it.\n\nThanks for the reminder from Calvin Owens, 'kfree_pps' should be removed\nin pps_register_source() to avoid a double free in the failure case.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40078",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Explicitly check accesses to bpf_sock_addr\n\nSyzkaller found a kernel warning on the following sock_addr program:\n\n    0: r0 = 0\n    1: r2 = *(u32 *)(r1 +60)\n    2: exit\n\nwhich triggers:\n\n    verifier bug: error during ctx access conversion (0)\n\nThis is happening because offset 60 in bpf_sock_addr corresponds to an\nimplicit padding of 4 bytes, right after msg_src_ip4. Access to this\npadding isn't rejected in sock_addr_is_valid_access and it thus later\nfails to convert the access.\n\nThis patch fixes it by explicitly checking the various fields of\nbpf_sock_addr in sock_addr_is_valid_access.\n\nI checked the other ctx structures and is_valid_access functions and\ndidn't find any other similar cases. Other cases of (properly handled)\npadding are covered in new tests in a subsequent patch.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40082",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()\n\nBUG: KASAN: slab-out-of-bounds in hfsplus_uni2asc+0xa71/0xb90 fs/hfsplus/unicode.c:186\nRead of size 2 at addr ffff8880289ef218 by task syz.6.248/14290\n\nCPU: 0 UID: 0 PID: 14290 Comm: syz.6.248 Not tainted 6.16.4 #1 PREEMPT(full)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1b0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x5f0 mm/kasan/report.c:482\n kasan_report+0xca/0x100 mm/kasan/report.c:595\n hfsplus_uni2asc+0xa71/0xb90 fs/hfsplus/unicode.c:186\n hfsplus_listxattr+0x5b6/0xbd0 fs/hfsplus/xattr.c:738\n vfs_listxattr+0xbe/0x140 fs/xattr.c:493\n listxattr+0xee/0x190 fs/xattr.c:924\n filename_listxattr fs/xattr.c:958 [inline]\n path_listxattrat+0x143/0x360 fs/xattr.c:988\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcb/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fe0e9fae16d\nCode: 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fe0eae67f98 EFLAGS: 00000246 ORIG_RAX: 00000000000000c3\nRAX: ffffffffffffffda RBX: 00007fe0ea205fa0 RCX: 00007fe0e9fae16d\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000200000000000\nRBP: 00007fe0ea0480f0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fe0ea206038 R14: 00007fe0ea205fa0 R15: 00007fe0eae48000\n \u003c/TASK\u003e\n\nAllocated by task 14290:\n kasan_save_stack+0x24/0x50 mm/kasan/common.c:47\n kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4333 [inline]\n __kmalloc_noprof+0x219/0x540 mm/slub.c:4345\n kmalloc_noprof include/linux/slab.h:909 [inline]\n hfsplus_find_init+0x95/0x1f0 fs/hfsplus/bfind.c:21\n hfsplus_listxattr+0x331/0xbd0 fs/hfsplus/xattr.c:697\n vfs_listxattr+0xbe/0x140 fs/xattr.c:493\n listxattr+0xee/0x190 fs/xattr.c:924\n filename_listxattr fs/xattr.c:958 [inline]\n path_listxattrat+0x143/0x360 fs/xattr.c:988\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcb/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nWhen hfsplus_uni2asc is called from hfsplus_listxattr,\nit actually passes in a struct hfsplus_attr_unistr*.\nThe size of the corresponding structure is different from that of hfsplus_unistr,\nso the previous fix (94458781aee6) is insufficient.\nThe pointer on the unicode buffer is still going beyond the allocated memory.\n\nThis patch introduces two warpper functions hfsplus_uni2asc_xattr_str and\nhfsplus_uni2asc_str to process two unicode buffers,\nstruct hfsplus_attr_unistr* and struct hfsplus_unistr* respectively.\nWhen ustrlen value is bigger than the allocated memory size,\nthe ustrlen value is limited to an safe size.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40083",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_qfq: Fix null-deref in agg_dequeue\n\nTo prevent a potential crash in agg_dequeue (net/sched/sch_qfq.c)\nwhen cl-\u003eqdisc-\u003eops-\u003epeek(cl-\u003eqdisc) returns NULL, we check the return\nvalue before using it, similar to the existing approach in sch_hfsc.c.\n\nTo avoid code duplication, the following changes are made:\n\n1. Changed qdisc_warn_nonwc(include/net/pkt_sched.h) into a static\ninline function.\n\n2. Moved qdisc_peek_len from net/sched/sch_hfsc.c to\ninclude/net/pkt_sched.h so that sch_qfq can reuse it.\n\n3. Applied qdisc_peek_len in agg_dequeue to avoid crashing.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40088",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: fix slab-out-of-bounds read in hfsplus_strcasecmp()\n\nThe hfsplus_strcasecmp() logic can trigger the issue:\n\n[  117.317703][ T9855] ==================================================================\n[  117.318353][ T9855] BUG: KASAN: slab-out-of-bounds in hfsplus_strcasecmp+0x1bc/0x490\n[  117.318991][ T9855] Read of size 2 at addr ffff88802160f40c by task repro/9855\n[  117.319577][ T9855]\n[  117.319773][ T9855] CPU: 0 UID: 0 PID: 9855 Comm: repro Not tainted 6.17.0-rc6 #33 PREEMPT(full)\n[  117.319780][ T9855] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[  117.319783][ T9855] Call Trace:\n[  117.319785][ T9855]  \u003cTASK\u003e\n[  117.319788][ T9855]  dump_stack_lvl+0x1c1/0x2a0\n[  117.319795][ T9855]  ? __virt_addr_valid+0x1c8/0x5c0\n[  117.319803][ T9855]  ? __pfx_dump_stack_lvl+0x10/0x10\n[  117.319808][ T9855]  ? rcu_is_watching+0x15/0xb0\n[  117.319816][ T9855]  ? lock_release+0x4b/0x3e0\n[  117.319821][ T9855]  ? __kasan_check_byte+0x12/0x40\n[  117.319828][ T9855]  ? __virt_addr_valid+0x1c8/0x5c0\n[  117.319835][ T9855]  ? __virt_addr_valid+0x4a5/0x5c0\n[  117.319842][ T9855]  print_report+0x17e/0x7e0\n[  117.319848][ T9855]  ? __virt_addr_valid+0x1c8/0x5c0\n[  117.319855][ T9855]  ? __virt_addr_valid+0x4a5/0x5c0\n[  117.319862][ T9855]  ? __phys_addr+0xd3/0x180\n[  117.319869][ T9855]  ? hfsplus_strcasecmp+0x1bc/0x490\n[  117.319876][ T9855]  kasan_report+0x147/0x180\n[  117.319882][ T9855]  ? hfsplus_strcasecmp+0x1bc/0x490\n[  117.319891][ T9855]  hfsplus_strcasecmp+0x1bc/0x490\n[  117.319900][ T9855]  ? __pfx_hfsplus_cat_case_cmp_key+0x10/0x10\n[  117.319906][ T9855]  hfs_find_rec_by_key+0xa9/0x1e0\n[  117.319913][ T9855]  __hfsplus_brec_find+0x18e/0x470\n[  117.319920][ T9855]  ? __pfx_hfsplus_bnode_find+0x10/0x10\n[  117.319926][ T9855]  ? __pfx_hfs_find_rec_by_key+0x10/0x10\n[  117.319933][ T9855]  ? __pfx___hfsplus_brec_find+0x10/0x10\n[  117.319942][ T9855]  hfsplus_brec_find+0x28f/0x510\n[  117.319949][ T9855]  ? __pfx_hfs_find_rec_by_key+0x10/0x10\n[  117.319956][ T9855]  ? __pfx_hfsplus_brec_find+0x10/0x10\n[  117.319963][ T9855]  ? __kmalloc_noprof+0x2a9/0x510\n[  117.319969][ T9855]  ? hfsplus_find_init+0x8c/0x1d0\n[  117.319976][ T9855]  hfsplus_brec_read+0x2b/0x120\n[  117.319983][ T9855]  hfsplus_lookup+0x2aa/0x890\n[  117.319990][ T9855]  ? __pfx_hfsplus_lookup+0x10/0x10\n[  117.320003][ T9855]  ? d_alloc_parallel+0x2f0/0x15e0\n[  117.320008][ T9855]  ? __lock_acquire+0xaec/0xd80\n[  117.320013][ T9855]  ? __pfx_d_alloc_parallel+0x10/0x10\n[  117.320019][ T9855]  ? __raw_spin_lock_init+0x45/0x100\n[  117.320026][ T9855]  ? __init_waitqueue_head+0xa9/0x150\n[  117.320034][ T9855]  __lookup_slow+0x297/0x3d0\n[  117.320039][ T9855]  ? __pfx___lookup_slow+0x10/0x10\n[  117.320045][ T9855]  ? down_read+0x1ad/0x2e0\n[  117.320055][ T9855]  lookup_slow+0x53/0x70\n[  117.320065][ T9855]  walk_component+0x2f0/0x430\n[  117.320073][ T9855]  path_lookupat+0x169/0x440\n[  117.320081][ T9855]  filename_lookup+0x212/0x590\n[  117.320089][ T9855]  ? __pfx_filename_lookup+0x10/0x10\n[  117.320098][ T9855]  ? strncpy_from_user+0x150/0x290\n[  117.320105][ T9855]  ? getname_flags+0x1e5/0x540\n[  117.320112][ T9855]  user_path_at+0x3a/0x60\n[  117.320117][ T9855]  __x64_sys_umount+0xee/0x160\n[  117.320123][ T9855]  ? __pfx___x64_sys_umount+0x10/0x10\n[  117.320129][ T9855]  ? do_syscall_64+0xb7/0x3a0\n[  117.320135][ T9855]  ? entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[  117.320141][ T9855]  ? entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[  117.320145][ T9855]  do_syscall_64+0xf3/0x3a0\n[  117.320150][ T9855]  ? exc_page_fault+0x9f/0xf0\n[  117.320154][ T9855]  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[  117.320158][ T9855] RIP: 0033:0x7f7dd7908b07\n[  117.320163][ T9855] Code: 23 0d 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 31 f6 e9 09 00 00 00 66 0f 1f 84 00 00 08\n[  117.320167][ T9855] RSP: 002b:00007ffd5ebd9698 EFLAGS: 00000202 \n---truncated---",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40173",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/ip6_tunnel: Prevent perpetual tunnel growth\n\nSimilarly to ipv4 tunnel, ipv6 version updates dev-\u003eneeded_headroom, too.\nWhile ipv4 tunnel headroom adjustment growth was limited in\ncommit 5ae1e9922bbd (\"net: ip_tunnel: prevent perpetual headroom growth\"),\nipv6 tunnel yet increases the headroom without any ceiling.\n\nReflect ipv4 tunnel headroom adjustment limit on ipv6 version.\n\nCredits to Francesco Ruggeri, who was originally debugging this issue\nand wrote local Arista-specific patch and a reproducer.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40186",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: Don't call reqsk_fastopen_remove() in tcp_conn_request().\n\nsyzbot reported the splat below in tcp_conn_request(). [0]\n\nIf a listener is close()d while a TFO socket is being processed in\ntcp_conn_request(), inet_csk_reqsk_queue_add() does not set reqsk-\u003esk\nand calls inet_child_forget(), which calls tcp_disconnect() for the\nTFO socket.\n\nAfter the cited commit, tcp_disconnect() calls reqsk_fastopen_remove(),\nwhere reqsk_put() is called due to !reqsk-\u003esk.\n\nThen, reqsk_fastopen_remove() in tcp_conn_request() decrements the\nlast req-\u003ersk_refcnt and frees reqsk, and __reqsk_free() at the\ndrop_and_free label causes the refcount underflow for the listener\nand double-free of the reqsk.\n\nLet's remove reqsk_fastopen_remove() in tcp_conn_request().\n\nNote that other callers make sure tp-\u003efastopen_rsk is not NULL.\n\n[0]:\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 12 PID: 5563 at lib/refcount.c:28 refcount_warn_saturate (lib/refcount.c:28)\nModules linked in:\nCPU: 12 UID: 0 PID: 5563 Comm: syz-executor Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/12/2025\nRIP: 0010:refcount_warn_saturate (lib/refcount.c:28)\nCode: ab e8 8e b4 98 ff 0f 0b c3 cc cc cc cc cc 80 3d a4 e4 d6 01 00 75 9c c6 05 9b e4 d6 01 01 48 c7 c7 e8 df fb ab e8 6a b4 98 ff \u003c0f\u003e 0b e9 03 5b 76 00 cc 80 3d 7d e4 d6 01 00 0f 85 74 ff ff ff c6\nRSP: 0018:ffffa79fc0304a98 EFLAGS: 00010246\nRAX: d83af4db1c6b3900 RBX: ffff9f65c7a69020 RCX: d83af4db1c6b3900\nRDX: 0000000000000000 RSI: 00000000ffff7fff RDI: ffffffffac78a280\nRBP: 000000009d781b60 R08: 0000000000007fff R09: ffffffffac6ca280\nR10: 0000000000017ffd R11: 0000000000000004 R12: ffff9f65c7b4f100\nR13: ffff9f65c7d23c00 R14: ffff9f65c7d26000 R15: ffff9f65c7a64ef8\nFS:  00007f9f962176c0(0000) GS:ffff9f65fcf00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000200000000180 CR3: 000000000dbbe006 CR4: 0000000000372ef0\nCall Trace:\n \u003cIRQ\u003e\n tcp_conn_request (./include/linux/refcount.h:400 ./include/linux/refcount.h:432 ./include/linux/refcount.h:450 ./include/net/sock.h:1965 ./include/net/request_sock.h:131 net/ipv4/tcp_input.c:7301)\n tcp_rcv_state_process (net/ipv4/tcp_input.c:6708)\n tcp_v6_do_rcv (net/ipv6/tcp_ipv6.c:1670)\n tcp_v6_rcv (net/ipv6/tcp_ipv6.c:1906)\n ip6_protocol_deliver_rcu (net/ipv6/ip6_input.c:438)\n ip6_input (net/ipv6/ip6_input.c:500)\n ipv6_rcv (net/ipv6/ip6_input.c:311)\n __netif_receive_skb (net/core/dev.c:6104)\n process_backlog (net/core/dev.c:6456)\n __napi_poll (net/core/dev.c:7506)\n net_rx_action (net/core/dev.c:7569 net/core/dev.c:7696)\n handle_softirqs (kernel/softirq.c:579)\n do_softirq (kernel/softirq.c:480)\n \u003c/IRQ\u003e",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40204",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: Fix MAC comparison to be constant-time\n\nTo prevent timing attacks, MACs need to be compared in constant time.\nUse the appropriate helper function for this.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40205",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: avoid potential out-of-bounds in btrfs_encode_fh()\n\nThe function btrfs_encode_fh() does not properly account for the three\ncases it handles.\n\nBefore writing to the file handle (fh), the function only returns to the\nuser BTRFS_FID_SIZE_NON_CONNECTABLE (5 dwords, 20 bytes) or\nBTRFS_FID_SIZE_CONNECTABLE (8 dwords, 32 bytes).\n\nHowever, when a parent exists and the root ID of the parent and the\ninode are different, the function writes BTRFS_FID_SIZE_CONNECTABLE_ROOT\n(10 dwords, 40 bytes).\n\nIf *max_len is not large enough, this write goes out of bounds because\nBTRFS_FID_SIZE_CONNECTABLE_ROOT is greater than\nBTRFS_FID_SIZE_CONNECTABLE originally returned.\n\nThis results in an 8-byte out-of-bounds write at\nfid-\u003eparent_root_objectid = parent_root_id.\n\nA previous attempt to fix this issue was made but was lost.\n\nhttps://lore.kernel.org/all/4CADAEEC020000780001B32C@vpn.id2.novell.com/\n\nAlthough this issue does not seem to be easily triggerable, it is a\npotential memory corruption bug that should be fixed. This patch\nresolves the issue by ensuring the function returns the appropriate size\nfor all three cases and validates that *max_len is large enough before\nwriting any data.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40300",
      "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/vmscape: Add conditional IBPB mitigation\n\nVMSCAPE is a vulnerability that exploits insufficient branch predictor\nisolation between a guest and a userspace hypervisor (like QEMU). Existing\nmitigations already protect kernel/KVM from a malicious guest. Userspace\ncan additionally be protected by flushing the branch predictors after a\nVMexit.\n\nSince it is the userspace that consumes the poisoned branch predictors,\nconditionally issue an IBPB after a VMexit and before returning to\nuserspace. Workloads that frequently switch between hypervisor and\nuserspace will incur the most overhead from the new IBPB.\n\nThis new IBPB is not integrated with the existing IBPB sites. For\ninstance, a task can use the existing speculation control prctl() to\nget an IBPB at context switch time. With this implementation, the\nIBPB is doubled up: one at context switch and another before running\nuserspace.\n\nThe intent is to integrate and optimize these cases post-embargo.\n\n[ dhansen: elaborate on suboptimal IBPB solution ]",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-40778",
      "Description": "Under certain circumstances, BIND is too lenient when accepting records from answers, allowing an attacker to inject forged data into the cache.\nThis issue affects BIND 9 versions 9.11.0 through 9.16.50, 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.11.3-S1 through 9.16.50-S1, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-4435",
      "Description": "When using a TarFile.errorlevel = 0  and extracting with a filter the documented behavior is that any filtered members would be skipped and not extracted. However the actual behavior of TarFile.errorlevel = 0  in affected versions is that the member would still be extracted and not skipped.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-54771",
      "Description": "A use-after-free vulnerability has been identified in the GNU GRUB (Grand Unified Bootloader). The flaw occurs because the file-closing process incorrectly retains a memory pointer, leaving an invalid reference to a file system structure. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-59375",
      "Description": "libexpat in Expat before 2.7.2 allows attackers to trigger large dynamic memory allocations via a small document that is submitted for parsing.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-6075",
      "Description": "If the value passed to os.path.expandvars() is user-controlled a \nperformance degradation is possible when expanding environment \nvariables.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-61661",
      "Description": "A vulnerability has been identified in the GRUB (Grand Unified Bootloader) component. This flaw occurs because the bootloader mishandles string conversion when reading information from a USB device, allowing an attacker to exploit inconsistent length values. A local attacker can connect a maliciously configured USB device during the boot sequence to trigger this issue. A successful exploitation may lead GRUB to crash, leading to a Denial of Service. Data corruption may be also possible, although given the complexity of the exploit the impact is most likely limited.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-61662",
      "Description": "A Use-After-Free vulnerability has been discovered in GRUB's gettext module. This flaw stems from a programming error where the gettext command remains registered in memory after its module is unloaded. An attacker can exploit this condition by invoking the orphaned command, causing the application to access a memory location that is no longer valid. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-61663",
      "Description": "A vulnerability has been identified in the GRUB2 bootloader's normal command that poses an immediate Denial of Service (DoS) risk. This flaw is a Use-after-Free issue, caused because the normal command is not properly unregistered when the module is unloaded. An attacker who can execute this command can force the system to access memory locations that are no longer valid. Successful exploitation leads directly to system instability, which can result in a complete crash and halt system availability. Impact on the data integrity and confidentiality is also not discarded.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-61664",
      "Description": "A vulnerability in the GRUB2 bootloader has been identified in the normal module. This flaw, a memory Use After Free issue, occurs because the normal_exit command is not properly unregistered when its related module is unloaded. An attacker can exploit this condition by invoking the command after the module has been removed, causing the system to improperly access a previously freed memory location. This leads to a system crash or possible impacts in data confidentiality and integrity.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-61915",
      "Description": "OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. Prior to version 2.4.15, a user in the lpadmin group can use the cups web ui to change the config and insert a malicious line. Then the cupsd process which runs as root will parse the new config and cause an out-of-bound write. This issue has been patched in version 2.4.15.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-61984",
      "Description": "ssh in OpenSSH before 10.1 allows control characters in usernames that originate from certain possibly untrusted sources, potentially leading to code execution when a ProxyCommand is used. The untrusted sources are the command line and %-sequence expansion of a configuration file. (A configuration file that provides a complete literal username is not categorized as an untrusted source.)",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-64505",
      "Description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. Prior to version 1.6.51, a heap buffer over-read vulnerability exists in libpng's png_do_quantize function when processing PNG files with malformed palette indices. The vulnerability occurs when palette_lookup array bounds are not validated against externally-supplied image data, allowing an attacker to craft a PNG file with out-of-range palette indices that trigger out-of-bounds memory access. This issue has been patched in version 1.6.51.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-64506",
      "Description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From version 1.6.0 to before 1.6.51, a heap buffer over-read vulnerability exists in libpng's png_write_image_8bit function when processing 8-bit images through the simplified write API with convert_to_8bit enabled. The vulnerability affects 8-bit grayscale+alpha, RGB/RGBA, and images with incomplete row data. A conditional guard incorrectly allows 8-bit input to enter code expecting 16-bit input, causing reads up to 2 bytes beyond allocated buffer boundaries. This issue has been patched in version 1.6.51.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-64720",
      "Description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From version 1.6.0 to before 1.6.51, an out-of-bounds read vulnerability exists in png_image_read_composite when processing palette images with PNG_FLAG_OPTIMIZE_ALPHA enabled. The palette compositing code in png_init_read_transformations incorrectly applies background compositing during premultiplication, violating the invariant component  alpha x 257 required by the simplified PNG API. This issue has been patched in version 1.6.51.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-65018",
      "Description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From version 1.6.0 to before 1.6.51, there is a heap buffer overflow vulnerability in the libpng simplified API function png_image_finish_read when processing 16-bit interlaced PNGs with 8-bit output format. Attacker-crafted interlaced PNG files cause heap writes beyond allocated buffer bounds. This issue has been patched in version 1.6.51.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-66293",
      "Description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. Prior to 1.6.52, an out-of-bounds read vulnerability in libpng's simplified API allows reading up to 1012 bytes beyond the png_sRGB_base[512] array when processing valid palette PNG images with partial transparency and gamma correction. The PNG files that trigger this vulnerability are valid per the PNG specification; the bug is in libpng's internal state management. Upgrade to libpng 1.6.52 or later.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-7039",
      "Description": "A flaw was found in glib. An integer overflow during temporary file creation leads to an out-of-bounds memory access, allowing an attacker to potentially perform path traversal or access private temporary file content by creating symbolic links. This vulnerability allows a local attacker to manipulate file paths and access unauthorized data. The core issue stems from insufficient validation of file path lengths during temporary file operations.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-8194",
      "Description": "There is a defect in the CPython \"tarfile\" module affecting the \"TarFile\" extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \"tarfile\" module:   https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-8291",
      "Description": "The 'zipfile' module would not check the validity of the ZIP64 End of\nCentral Directory (EOCD) Locator record offset value would not be used to\nlocate the ZIP64 EOCD record, instead the ZIP64 EOCD record would be\nassumed to be the previous record in the ZIP archive. This could be abused\nto create ZIP archives that are handled differently by the 'zipfile' module\ncompared to other ZIP implementations.\n\n\nRemediation maintains this behavior, but checks that the offset specified\nin the ZIP64 EOCD Locator record matches the expected value.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-8732",
      "Description": "A vulnerability was found in libxml2 up to 2.14.5. It has been declared as problematic. This vulnerability affects the function xmlParseSGMLCatalog of the component xmlcatalog. The manipulation leads to uncontrolled recursion. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used. The real existence of this vulnerability is still doubted at the moment. The code maintainer explains, that \"[t]he issue can only be triggered with untrusted SGML catalogs and it makes absolutely no sense to use untrusted catalogs. I also doubt that anyone is still using SGML catalogs at all.\"",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "low"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-8851",
      "Description": "A vulnerability was determined in LibTIFF up to 4.5.1. Affected by this issue is the function readSeparateStripsetoBuffer of the file tools/tiffcrop.c of the component tiffcrop. The manipulation leads to stack-based buffer overflow. Local access is required to approach this attack. The patch is identified as 8a7a48d7a645992ca83062b3a1873c951661e2b3. It is recommended to apply a patch to fix this issue.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-9640",
      "Description": "A flaw was found in Samba, in the vfs_streams_xattr module, where uninitialized heap memory could be written into alternate data streams. This allows an authenticated user to read residual memory content that may include sensitive data, resulting in an information disclosure vulnerability.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-9714",
      "Description": "Uncontrolled recursion in  XPath evaluation  in libxml2 up to and including version 2.9.14 allows a local attacker to cause a stack overflow via crafted expressions. XPath processing functions `xmlXPathRunEval`, `xmlXPathCtxtCompile`, and `xmlXPathEvalExpr` were resetting recursion depth to zero before making potentially recursive calls. When such functions were called recursively this could allow for uncontrolled recursion and lead to a stack overflow. These functions now preserve recursion depth across recursive calls, allowing recursion depth to be controlled.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "moderate"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    },
    {
      "CVE": "CVE-2025-9900",
      "Description": "A flaw was found in Libtiff. This vulnerability is a \"write-what-where\" condition, triggered when the library processes a specially crafted TIFF image file.\n\nBy providing an abnormally large image height value in the file's metadata, an attacker can trick the library into writing attacker-controlled color data to an arbitrary memory location. This memory corruption can be exploited to cause a denial of service (application crash) or to achieve arbitrary code execution with the permissions of the user.",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "important"
        }
      ],
      "References": null,
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": null
        }
      ],
      "CVSSScoreSets": {}
    }
  ]
}