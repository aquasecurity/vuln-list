{
  "Title": "An update for kernel is now available for openEuler-20.03-LTS-SP4",
  "Type": "Security Advisory",
  "Publisher": {
    "ContactDetails": "openeuler-security@openeuler.org",
    "IssuingAuthority": "openEuler security committee"
  },
  "Tracking": {
    "ID": "openEuler-SA-2025-2553",
    "Status": "Final",
    "Version": "1.0",
    "InitialReleaseDate": "2025-10-31",
    "CurrentReleaseDate": "2025-10-31",
    "Generator": {
      "Engine": "openEuler SA Tool V1.0",
      "Date": "2025-10-31"
    },
    "RevisionHistory": [
      {
        "Number": "1.0",
        "Date": "2025-10-31",
        "Description": "Initial"
      }
    ]
  },
  "Notes": [
    {
      "Text": "kernel security update",
      "Title": "Synopsis",
      "Type": "General"
    },
    {
      "Text": "An update for kernel is now available for openEuler-20.03-LTS-SP4",
      "Title": "Summary",
      "Type": "General"
    },
    {
      "Text": "The Linux Kernel, the operating system core itself.\n\nSecurity Fix(es):\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nnet/tunnel: wait until all sk_user_data reader finish before releasing the sock\n\nThere is a race condition in vxlan that when deleting a vxlan device\nduring receiving packets, there is a possibility that the sock is\nreleased after getting vxlan_sock vs from sk_user_data. Then in\nlater vxlan_ecn_decapsulate(), vxlan_get_sk_family() we will got\nNULL pointer dereference. e.g.\n\n   #0 [ffffa25ec6978a38] machine_kexec at ffffffff8c669757\n   #1 [ffffa25ec6978a90] __crash_kexec at ffffffff8c7c0a4d\n   #2 [ffffa25ec6978b58] crash_kexec at ffffffff8c7c1c48\n   #3 [ffffa25ec6978b60] oops_end at ffffffff8c627f2b\n   #4 [ffffa25ec6978b80] page_fault_oops at ffffffff8c678fcb\n   #5 [ffffa25ec6978bd8] exc_page_fault at ffffffff8d109542\n   #6 [ffffa25ec6978c00] asm_exc_page_fault at ffffffff8d200b62\n      [exception RIP: vxlan_ecn_decapsulate+0x3b]\n      RIP: ffffffffc1014e7b  RSP: ffffa25ec6978cb0  RFLAGS: 00010246\n      RAX: 0000000000000008  RBX: ffff8aa000888000  RCX: 0000000000000000\n      RDX: 000000000000000e  RSI: ffff8a9fc7ab803e  RDI: ffff8a9fd1168700\n      RBP: ffff8a9fc7ab803e   R8: 0000000000700000   R9: 00000000000010ae\n      R10: ffff8a9fcb748980  R11: 0000000000000000  R12: ffff8a9fd1168700\n      R13: ffff8aa000888000  R14: 00000000002a0000  R15: 00000000000010ae\n      ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n   #7 [ffffa25ec6978ce8] vxlan_rcv at ffffffffc10189cd [vxlan]\n   #8 [ffffa25ec6978d90] udp_queue_rcv_one_skb at ffffffff8cfb6507\n   #9 [ffffa25ec6978dc0] udp_unicast_rcv_skb at ffffffff8cfb6e45\n  #10 [ffffa25ec6978dc8] __udp4_lib_rcv at ffffffff8cfb8807\n  #11 [ffffa25ec6978e20] ip_protocol_deliver_rcu at ffffffff8cf76951\n  #12 [ffffa25ec6978e48] ip_local_deliver at ffffffff8cf76bde\n  #13 [ffffa25ec6978ea0] __netif_receive_skb_one_core at ffffffff8cecde9b\n  #14 [ffffa25ec6978ec8] process_backlog at ffffffff8cece139\n  #15 [ffffa25ec6978f00] __napi_poll at ffffffff8ceced1a\n  #16 [ffffa25ec6978f28] net_rx_action at ffffffff8cecf1f3\n  #17 [ffffa25ec6978fa0] __softirqentry_text_start at ffffffff8d4000ca\n  #18 [ffffa25ec6978ff0] do_softirq at ffffffff8c6fbdc3\n\nReproducer: https://github.com/Mellanox/ovs-tests/blob/master/test-ovs-vxlan-remove-tunnel-during-traffic.sh\n\nFix this by waiting for all sk_user_data reader to finish before\nreleasing the sock.(CVE-2022-50405)\n\nIn the Linux kernel, there is a vulnerability in the USB host controller interface (xHCI). When the xHC host is dying or being removed, endpoints are not properly cleaned up, remaining in the bandwidth list when freeing the virtual device. This causes a list_del corruption kernel crash when unbinding xhci-pci, as xhci_mem_cleanup() later attempts to delete already freed endpoints from the bandwidth list. This vulnerability only affects hosts that use software bandwidth checking, which currently is only the xHC in Intel Panther Point PCH (Ivy Bridge).(CVE-2022-50470)\n\nIn the Linux kernel, the following vulnerability has been resolved:thermal: intel_powerclamp: Use get_cpu() instead of smp_processor_id() to avoid crashWhen CPU 0 is offline and intel_powerclamp is used to injectidle, it generates kernel BUG:BUG: using smp_processor_id() in preemptible [00000000] code: bash/15687caller is debug_smp_processor_id+0x17/0x20CPU: 4 PID: 15687 Comm: bash Not tainted 5.19.0-rc7+ #57Call Trace:\u003cTASK\u003edump_stack_lvl+0x49/0x63dump_stack+0x10/0x16check_preemption_disabled+0xdd/0xe0debug_smp_processor_id+0x17/0x20powerclamp_set_cur_state+0x7f/0xf9 [intel_powerclamp]......Here CPU 0 is the control CPU by default and changed to the current CPU,if CPU 0 offlined. This check has to be performed under cpus_read_lock(),hence the above warning.Use get_cpu() instead of smp_processor_id() to avoid this BUG.[ rjw: Subject edits ](CVE-2022-50494)\n\nIn the Linux kernel, the following vulnerability has been resolved:iommu/amd: Fix pci device refcount leak in ppr_notifier()As comment of pci_get_domain_bus_and_slot() says, it returnsa pci device with refcount increment, when finish using it,the caller must decrement the reference count by callingpci_dev_put(). So call it before returning from ppr_notifier()to avoid refcount leak.(CVE-2022-50505)\n\nIn the Linux kernel, the following vulnerability has been resolved:usb: host: xhci: Fix potential memory leak in xhci_alloc_stream_info()xhci_alloc_stream_info() allocates stream context array for stream_info-\u003estream_ctx_array with xhci_alloc_stream_ctx(). When some error occurs,stream_info-\u003estream_ctx_array is not released, which will lead to amemory leak.We can fix it by releasing the stream_info-\u003estream_ctx_array withxhci_free_stream_ctx() on the error path to avoid the potential memoryleak.(CVE-2022-50544)\n\nIn the Linux kernel, the following vulnerability has been resolved:mtd: Fix device name leak when register device failed in add_mtd_device()There is a kmemleak when register device failed:  unreferenced object 0xffff888101aab550 (size 8):    comm  insmod , pid 3922, jiffies 4295277753 (age 925.408s)    hex dump (first 8 bytes):      6d 74 64 30 00 88 ff ff                          mtd0....    backtrace:      [\u003c00000000bde26724\u003e] __kmalloc_node_track_caller+0x4e/0x150      [\u003c000000003c32b416\u003e] kvasprintf+0xb0/0x130      [\u003c000000001f7a8f15\u003e] kobject_set_name_vargs+0x2f/0xb0      [\u003c000000006e781163\u003e] dev_set_name+0xab/0xe0      [\u003c00000000e30d0c78\u003e] add_mtd_device+0x4bb/0x700      [\u003c00000000f3d34de7\u003e] mtd_device_parse_register+0x2ac/0x3f0      [\u003c00000000c0d88488\u003e] 0xffffffffa0238457      [\u003c00000000b40d0922\u003e] 0xffffffffa02a008f      [\u003c0000000023d17b9d\u003e] do_one_initcall+0x87/0x2a0      [\u003c00000000770f6ca6\u003e] do_init_module+0xdf/0x320      [\u003c000000007b6768fe\u003e] load_module+0x2f98/0x3330      [\u003c00000000346bed5a\u003e] __do_sys_finit_module+0x113/0x1b0      [\u003c00000000674c2290\u003e] do_syscall_64+0x35/0x80      [\u003c000000004c6a8d97\u003e] entry_SYSCALL_64_after_hwframe+0x46/0xb0If register device failed, should call put_device() to give up thereference.(CVE-2022-50566)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nubi: ensure that VID header offset + VID header size \u003c= alloc, size\n\nEnsure that the VID header offset + VID header size does not exceed\nthe allocated area to avoid slab OOB.\n\nBUG: KASAN: slab-out-of-bounds in crc32_body lib/crc32.c:111 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_generic lib/crc32.c:179 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_base+0x58c/0x626 lib/crc32.c:197\nRead of size 4 at addr ffff88802bb36f00 by task syz-executor136/1555\n\nCPU: 2 PID: 1555 Comm: syz-executor136 Tainted: G        W\n6.0.0-1868 #1\nHardware name: Red Hat KVM, BIOS 1.13.0-2.module+el8.3.0+7860+a7792d29\n04/01/2014\nCall Trace:\n  \u003cTASK\u003e\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x85/0xad lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:317 [inline]\n  print_report.cold.13+0xb6/0x6bb mm/kasan/report.c:433\n  kasan_report+0xa7/0x11b mm/kasan/report.c:495\n  crc32_body lib/crc32.c:111 [inline]\n  crc32_le_generic lib/crc32.c:179 [inline]\n  crc32_le_base+0x58c/0x626 lib/crc32.c:197\n  ubi_io_write_vid_hdr+0x1b7/0x472 drivers/mtd/ubi/io.c:1067\n  create_vtbl+0x4d5/0x9c4 drivers/mtd/ubi/vtbl.c:317\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\nRIP: 0033:0x7f96d5cf753d\nCode:\nRSP: 002b:00007fffd72206f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f96d5cf753d\nRDX: 0000000020000080 RSI: 0000000040186f40 RDI: 0000000000000003\nRBP: 0000000000400cd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400be0\nR13: 00007fffd72207e0 R14: 0000000000000000 R15: 0000000000000000\n  \u003c/TASK\u003e\n\nAllocated by task 1555:\n  kasan_save_stack+0x20/0x3d mm/kasan/common.c:38\n  kasan_set_track mm/kasan/common.c:45 [inline]\n  set_alloc_info mm/kasan/common.c:437 [inline]\n  ____kasan_kmalloc mm/kasan/common.c:516 [inline]\n  __kasan_kmalloc+0x88/0xa3 mm/kasan/common.c:525\n  kasan_kmalloc include/linux/kasan.h:234 [inline]\n  __kmalloc+0x138/0x257 mm/slub.c:4429\n  kmalloc include/linux/slab.h:605 [inline]\n  ubi_alloc_vid_buf drivers/mtd/ubi/ubi.h:1093 [inline]\n  create_vtbl+0xcc/0x9c4 drivers/mtd/ubi/vtbl.c:295\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\n\nThe buggy address belongs to the object at ffff88802bb36e00\n  which belongs to the cache kmalloc-256 of size 256\nThe buggy address is located 0 bytes to the right of\n  256-byte region [ffff88802bb36e00, ffff88802bb36f00)\n\nThe buggy address belongs to the physical page:\npage:00000000ea4d1263 refcount:1 mapcount:0 mapping:0000000000000000\nindex:0x0 pfn:0x2bb36\nhead:00000000ea4d1263 order:1 compound_mapcount:0 compound_pincount:0\nflags: 0xfffffc0010200(slab|head|node=0|zone=1|lastcpupid=0x1fffff)\nraw: 000fffffc0010200 ffffea000066c300 dead000000000003 ffff888100042b40\nraw: 0000000000000000 00000000001\n---truncated---(CVE-2023-53265)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nubi: Fix unreferenced object reported by kmemleak in ubi_resize_volume()\n\nThere is a memory leaks problem reported by kmemleak:\n\nunreferenced object 0xffff888102007a00 (size 128):\n  comm \"ubirsvol\", pid 32090, jiffies 4298464136 (age 2361.231s)\n  hex dump (first 32 bytes):\nff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................\nff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................\n  backtrace:\n[\u003cffffffff8176cecd\u003e] __kmalloc+0x4d/0x150\n[\u003cffffffffa02a9a36\u003e] ubi_eba_create_table+0x76/0x170 [ubi]\n[\u003cffffffffa029764e\u003e] ubi_resize_volume+0x1be/0xbc0 [ubi]\n[\u003cffffffffa02a3321\u003e] ubi_cdev_ioctl+0x701/0x1850 [ubi]\n[\u003cffffffff81975d2d\u003e] __x64_sys_ioctl+0x11d/0x170\n[\u003cffffffff83c142a5\u003e] do_syscall_64+0x35/0x80\n[\u003cffffffff83e0006a\u003e] entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis is due to a mismatch between create and destroy interfaces, and\nin detail that \"new_eba_tbl\" created by ubi_eba_create_table() but\ndestroyed by kfree(), while will causing \"new_eba_tbl-\u003eentries\" not\nfreed.\n\nFix it by replacing kfree(new_eba_tbl) with\nubi_eba_destroy_table(new_eba_tbl)(CVE-2023-53271)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nsctp: check send stream number after wait_for_sndbuf\n\nThis patch fixes a corner case where the asoc out stream count may change\nafter wait_for_sndbuf.\n\nWhen the main thread in the client starts a connection, if its out stream\ncount is set to N while the in stream count in the server is set to N - 2,\nanother thread in the client keeps sending the msgs with stream number\nN - 1, and waits for sndbuf before processing INIT_ACK.\n\nHowever, after processing INIT_ACK, the out stream count in the client is\nshrunk to N - 2, the same to the in stream count in the server. The crash\noccurs when the thread waiting for sndbuf is awake and sends the msg in a\nnon-existing stream(N - 1), the call trace is as below:\n\n  KASAN: null-ptr-deref in range [0x0000000000000038-0x000000000000003f]\n  Call Trace:\n   \u003cTASK\u003e\n   sctp_cmd_send_msg net/sctp/sm_sideeffect.c:1114 [inline]\n   sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1777 [inline]\n   sctp_side_effects net/sctp/sm_sideeffect.c:1199 [inline]\n   sctp_do_sm+0x197d/0x5310 net/sctp/sm_sideeffect.c:1170\n   sctp_primitive_SEND+0x9f/0xc0 net/sctp/primitive.c:163\n   sctp_sendmsg_to_asoc+0x10eb/0x1a30 net/sctp/socket.c:1868\n   sctp_sendmsg+0x8d4/0x1d90 net/sctp/socket.c:2026\n   inet_sendmsg+0x9d/0xe0 net/ipv4/af_inet.c:825\n   sock_sendmsg_nosec net/socket.c:722 [inline]\n   sock_sendmsg+0xde/0x190 net/socket.c:745\n\nThe fix is to add an unlikely check for the send stream number after the\nthread wakes up from the wait_for_sndbuf.(CVE-2023-53296)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nsctp: fix a potential overflow in sctp_ifwdtsn_skip\n\nCurrently, when traversing ifwdtsn skips with _sctp_walk_ifwdtsn, it only\nchecks the pos against the end of the chunk. However, the data left for\nthe last pos may be \u003c sizeof(struct sctp_ifwdtsn_skip), and dereference\nit as struct sctp_ifwdtsn_skip may cause coverflow.\n\nThis patch fixes it by checking the pos against \"the end of the chunk -\nsizeof(struct sctp_ifwdtsn_skip)\" in sctp_ifwdtsn_skip, similar to\nsctp_fwdtsn_skip.(CVE-2023-53372)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: avoid possible NULL skb pointer dereference\n\nIn 'mwifiex_handle_uap_rx_forward()', always check the value\nreturned by 'skb_copy()' to avoid potential NULL pointer\ndereference in 'mwifiex_uap_queue_bridged_pkt()', and drop\noriginal skb in case of copying failure.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.(CVE-2023-53384)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ndrm/radeon: free iio for atombios when driver shutdown\n\nFix below kmemleak when unload radeon driver:\n\nunreferenced object 0xffff9f8608ede200 (size 512):\n  comm \"systemd-udevd\", pid 326, jiffies 4294682822 (age 716.338s)\n  hex dump (first 32 bytes):\n    00 00 00 00 c4 aa ec aa 14 ab 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [\u003c0000000062fadebe\u003e] kmem_cache_alloc_trace+0x2f1/0x500\n    [\u003c00000000b6883cea\u003e] atom_parse+0x117/0x230 [radeon]\n    [\u003c00000000158c23fd\u003e] radeon_atombios_init+0xab/0x170 [radeon]\n    [\u003c00000000683f672e\u003e] si_init+0x57/0x750 [radeon]\n    [\u003c00000000566cc31f\u003e] radeon_device_init+0x559/0x9c0 [radeon]\n    [\u003c0000000046efabb3\u003e] radeon_driver_load_kms+0xc1/0x1a0 [radeon]\n    [\u003c00000000b5155064\u003e] drm_dev_register+0xdd/0x1d0\n    [\u003c0000000045fec835\u003e] radeon_pci_probe+0xbd/0x100 [radeon]\n    [\u003c00000000e69ecca3\u003e] pci_device_probe+0xe1/0x160\n    [\u003c0000000019484b76\u003e] really_probe.part.0+0xc1/0x2c0\n    [\u003c000000003f2649da\u003e] __driver_probe_device+0x96/0x130\n    [\u003c00000000231c5bb1\u003e] driver_probe_device+0x24/0xf0\n    [\u003c0000000000a42377\u003e] __driver_attach+0x77/0x190\n    [\u003c00000000d7574da6\u003e] bus_for_each_dev+0x7f/0xd0\n    [\u003c00000000633166d2\u003e] driver_attach+0x1e/0x30\n    [\u003c00000000313b05b8\u003e] bus_add_driver+0x12c/0x1e0\n\niio was allocated in atom_index_iio() called by atom_parse(),\nbut it doesn't got released when the dirver is shutdown.\nFix this kmemleak by free it in radeon_atombios_fini().(CVE-2023-53453)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nubi: ubi_wl_put_peb: Fix infinite loop when wear-leveling work failed\n\nFollowing process will trigger an infinite loop in ubi_wl_put_peb():\n\n\tubifs_bgt\t\tubi_bgt\nubifs_leb_unmap\n  ubi_leb_unmap\n    ubi_eba_unmap_leb\n      ubi_wl_put_peb\twear_leveling_worker\n                          e1 = rb_entry(rb_first(\u0026ubi-\u003eused)\n\t\t\t  e2 = get_peb_for_wl(ubi)\n\t\t\t  ubi_io_read_vid_hdr  // return err (flash fault)\n\t\t\t  out_error:\n\t\t\t    ubi-\u003emove_from = ubi-\u003emove_to = NULL\n\t\t\t    wl_entry_destroy(ubi, e1)\n\t\t\t      ubi-\u003elookuptbl[e-\u003epnum] = NULL\n      retry:\n        e = ubi-\u003elookuptbl[pnum];\t// return NULL\n\tif (e == ubi-\u003emove_from) {\t// NULL == NULL gets true\n\t  goto retry;\t\t\t// infinite loop !!!\n\n$ top\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     COMMAND\n  7676 root     20   0       0      0      0 R 100.0  0.0  ubifs_bgt0_0\n\nFix it by:\n 1) Letting ubi_wl_put_peb() returns directly if wearl leveling entry has\n    been removed from 'ubi-\u003elookuptbl'.\n 2) Using 'ubi-\u003ewl_lock' protecting wl entry deletion to preventing an\n    use-after-free problem for wl entry in ubi_wl_put_peb().\n\nFetch a reproducer in [Link].(CVE-2023-53481)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-mmio: don't break lifecycle of vm_dev\n\nvm_dev has a separate lifecycle because it has a 'struct device'\nembedded. Thus, having a release callback for it is correct.\n\nAllocating the vm_dev struct with devres totally breaks this protection,\nthough. Instead of waiting for the vm_dev release callback, the memory\nis freed when the platform_device is removed. Resulting in a\nuse-after-free when finally the callback is to be called.\n\nTo easily see the problem, compile the kernel with\nCONFIG_DEBUG_KOBJECT_RELEASE and unbind with sysfs.\n\nThe fix is easy, don't use devres in this case.\n\nFound during my research about object lifetime problems.(CVE-2023-53515)\n\nIn the Linux kernel, the following vulnerability has been resolved:spi: qup: Don t skip cleanup in remove s error pathReturning early in a platform driver s remove callback is wrong. In thiscase the dma resources are not released in the error path. this is neverretried later and so this is a permanent leak. To fix this, only skiphardware disabling if waking the device fails.(CVE-2023-53567)\n\nIn the Linux kernel, the following vulnerability has been resolved:dm integrity: call kmem_cache_destroy() in dm_integrity_init() error pathOtherwise the journal_io_cache will leak if dm_register_target() fails.(CVE-2023-53604)\n\nIn the Linux kernel, the following vulnerability has been resolved:ALSA: ac97: Fix possible NULL dereference in snd_ac97_mixersmatch error:sound/pci/ac97/ac97_codec.c:2354 snd_ac97_mixer() error:we previously assumed  rac97  could be null (see line 2072)remove redundant assignment, return error if rac97 is NULL.(CVE-2023-53648)\n\nIn the Linux kernel, the following vulnerability has been resolved:bcache: Fix __bch_btree_node_alloc to make the failure behavior consistentIn some specific situations, the return value of __bch_btree_node_allocmay be NULL. This may lead to a potential NULL pointer dereference incaller function like a calling chain :btree_split-\u003ebch_btree_node_alloc-\u003e__bch_btree_node_alloc.Fix it by initializing the return value in __bch_btree_node_alloc.(CVE-2023-53681)\n\nIn the Linux kernel, the following vulnerability has been resolved:serial: arc_uart: fix of_iomap leak in `arc_serial_probe`Smatch reports:drivers/tty/serial/arc_uart.c:631 arc_serial_probe() warn: port-\u003emembase  from of_iomap() not released on lines: 631.In arc_serial_probe(), if uart_add_one_port() fails,port-\u003emembase is not released, which would cause a resource leak.To fix this, I replace of_iomap with devm_platform_ioremap_resource.(CVE-2023-53719)\n\nIn the Linux kernel, the following vulnerability has been resolved:posix-timers: Ensure timer ID search-loop limit is validposix_timer_add() tries to allocate a posix timer ID by starting from thecached ID which was stored by the last successful allocation.This is done in a loop searching the ID space for a free slot one byone. The loop has to terminate when the search wrapped around to thestarting point.But that s racy vs. establishing the starting point. That is read outlockless, which leads to the following problem:CPU0                    CPU1posix_timer_add()  start = sig-\u003eposix_timer_id;  lock(hash_lock);  ...       posix_timer_add()  if (++sig-\u003eposix_timer_id \u003c 0)                      start = sig-\u003eposix_timer_id;     sig-\u003eposix_timer_id = 0;So CPU1 can observe a negative start value, i.e. -1, and the loop breaknever happens because the condition can never be true:  if (sig-\u003eposix_timer_id == start)     break;While this is unlikely to ever turn into an endless loop as the ID space ishuge (INT_MAX), the racy read of the start value caught the attention ofKCSAN and Dmitry unearthed that incorrectness.Rewrite it so that all id operations are under the hash lock.(CVE-2023-53728)\n\nIn the Linux kernel, the following vulnerability has been resolved:sunrpc: fix one UAF issue caused by sunrpc kernel tcp socketBUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0Read of size 1 at addr ffff888111f322cd by task swapper/0/0CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1Call Trace: \u003cIRQ\u003e dump_stack_lvl+0x68/0xa0 print_address_description.constprop.0+0x2c/0x3d0 print_report+0xb4/0x270 kasan_report+0xbd/0xf0 tcp_write_timer_handler+0x156/0x3e0 tcp_write_timer+0x66/0x170 call_timer_fn+0xfb/0x1d0 __run_timers+0x3f8/0x480 run_timer_softirq+0x9b/0x100 handle_softirqs+0x153/0x390 __irq_exit_rcu+0x103/0x120 irq_exit_rcu+0xe/0x20 sysvec_apic_timer_interrupt+0x76/0x90 \u003c/IRQ\u003e \u003cTASK\u003e asm_sysvec_apic_timer_interrupt+0x1a/0x20RIP: 0010:default_idle+0xf/0x20Code: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 \u003cfa\u003e c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90RSP: 0018:ffffffffa2007e28 EFLAGS: 00000242RAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590fRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835dR10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000R13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0 default_idle_call+0x6b/0xa0 cpuidle_idle_call+0x1af/0x1f0 do_idle+0xbc/0x130 cpu_startup_entry+0x33/0x40 rest_init+0x11f/0x210 start_kernel+0x39a/0x420 x86_64_start_reservations+0x18/0x30 x86_64_start_kernel+0x97/0xa0 common_startup_64+0x13e/0x141 \u003c/TASK\u003eAllocated by task 595: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_slab_alloc+0x87/0x90 kmem_cache_alloc_noprof+0x12b/0x3f0 copy_net_ns+0x94/0x380 create_new_namespaces+0x24c/0x500 unshare_nsproxy_namespaces+0x75/0xf0 ksys_unshare+0x24e/0x4f0 __x64_sys_unshare+0x1f/0x30 do_syscall_64+0x70/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7eFreed by task 100: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x54/0x70 kmem_cache_free+0x156/0x5d0 cleanup_net+0x5d3/0x670 process_one_work+0x776/0xa90 worker_thread+0x2e2/0x560 kthread+0x1a8/0x1f0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30Reproduction script:mkdir -p /mnt/nfssharemkdir -p /mnt/nfs/netns_1mkfs.ext4 /dev/sdbmount /dev/sdb /mnt/nfssharesystemctl restart nfs-serverchmod 777 /mnt/nfsshareexportfs -i -o rw,no_root_squash *:/mnt/nfsshareip netns add netns_1ip link add name veth_1_peer type veth peer veth_1ifconfig veth_1_peer 11.11.0.254 upip link set veth_1 netns netns_1ip netns exec netns_1 ifconfig veth_1 11.11.0.1ip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp   --tcp-flags FIN FIN  -j DROP(note: In my environment, a DESTROY_CLIENTID operation is always sent immediately, breaking the nfs tcp connection.)ip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1   11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1ip netns del netns_1The reason here is that the tcp socket in netns_1 (nfs side) has beenshutdown and closed (done in xs_destroy), but the FIN message (with ack)is discarded, and the nfsd side keeps sending retransmission messages.As a result, when the tcp sock in netns_1 processes the received message,it sends the message (FIN message) in the sending queue, and the tcp timeris re-established. When the network namespace is deleted, the net structureaccessed by tcp s timer handler function causes problems.To fix this problem, let s hold netns refcnt for the tcp kernel socket asdone in other modules. This is an ugly hack which can easily be backportedto earlier kernels. A proper fix which cleans up the interfaces willfollow, but may not be so easy to backport.(CVE-2024-53168)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nnet: atm: fix /proc/net/atm/lec handling\n\n/proc/net/atm/lec must ensure safety against dev_lec[] changes.\n\nIt appears it had dev_put() calls without prior dev_hold(),\nleading to imbalance and UAF.(CVE-2025-38180)\n\nIn the Linux kernel, a race condition vulnerability exists in the posix-cpu-timers component. When a non-autoreaping exiting task has passed exit_notify() and calls handle_posix_cpu_timers() from IRQ, it can be reaped by its parent or debugger immediately after unlock_task_sighand(). If a concurrent posix_cpu_timer_del() runs at that moment, it will fail to detect timer-\u003eit.cpu.firing != 0 because cpu_timer_task_rcu() and/or lock_task_sighand() will fail. The fix adds a tsk-\u003eexit_state check to run_posix_cpu_timers().(CVE-2025-38352)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 power domain descriptors, too\n\nUAC3 power domain descriptors need to be verified with its variable\nbLength for avoiding the unexpected OOB accesses by malicious\nfirmware, too.(CVE-2025-38729)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla4xxx: Prevent a potential error pointer dereference\n\nThe qla4xxx_get_ep_fwdb() function is supposed to return NULL on error,\nbut qla4xxx_ep_connect() returns error pointers.  Propagating the error\npointers will lead to an Oops in the caller, so change the error pointers\nto NULL.(CVE-2025-39676)\n\nA buffer overflow vulnerability was found in the efivarfs component of the Linux kernel. When dentry-\u003ed_name.len \u003c EFI_VARIABLE_GUID_LEN, \u0026#39;guid\u0026#39; may become negative, causing out-of-bounds reads. This vulnerability can be triggered by parallel search using invalid file names, causing kernel memory to be accessed out of bounds.(CVE-2025-39817)",
      "Title": "Description",
      "Type": "General"
    },
    {
      "Text": "An update for kernel is now available for openEuler-20.03-LTS-SP4.\n\nopenEuler Security has rated this update as having a security impact of high. A Common Vunlnerability Scoring System(CVSS)base score,which gives a detailed severity rating, is available for each vulnerability from the CVElink(s) in the References section.",
      "Title": "Topic",
      "Type": "General"
    },
    {
      "Text": "High",
      "Title": "Severity",
      "Type": "General"
    },
    {
      "Text": "kernel",
      "Title": "Affected Component",
      "Type": "General"
    }
  ],
  "ProductTree": {
    "Branches": [
      {
        "Type": "Product Name",
        "Name": "openEuler",
        "Productions": [
          {
            "ProductID": "openEuler-20.03-LTS-SP4",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "openEuler-20.03-LTS-SP4"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "aarch64",
        "Productions": [
          {
            "ProductID": "bpftool-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "bpftool-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "bpftool-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "bpftool-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-debugsource-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-debugsource-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-devel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-devel-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-source-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-source-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-tools-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-tools-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-devel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-tools-devel-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "perf-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "perf-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "perf-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "perf-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "python2-perf-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python2-perf-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "python2-perf-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python2-perf-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "python3-perf-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python3-perf-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          },
          {
            "ProductID": "python3-perf-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python3-perf-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.aarch64.rpm"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "x86_64",
        "Productions": [
          {
            "ProductID": "bpftool-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "bpftool-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "bpftool-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "bpftool-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-debugsource-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-debugsource-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-devel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-devel-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-source-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-source-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-tools-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-tools-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-devel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-tools-devel-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "perf-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "perf-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "perf-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "perf-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "python2-perf-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python2-perf-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "python2-perf-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python2-perf-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "python3-perf-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python3-perf-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          },
          {
            "ProductID": "python3-perf-debuginfo-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "python3-perf-debuginfo-4.19.90-2510.4.0.0349.oe2003sp4.x86_64.rpm"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "src",
        "Productions": [
          {
            "ProductID": "kernel-4.19.90-2510.4.0.0349",
            "CPE": "cpe:/a:openEuler:openEuler:20.03-LTS-SP4",
            "Text": "kernel-4.19.90-2510.4.0.0349.oe2003sp4.src.rpm"
          }
        ]
      }
    ]
  },
  "References": [
    {
      "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
    },
    {
      "URL": "https://www.openeuler.org/en/security/cve/detail/?cveId=CVE-2025-39817"
    },
    {
      "URL": "https://nvd.nist.gov/vuln/detail/CVE-2025-39817"
    }
  ],
  "Vulnerabilities": [
    {
      "CVE": "CVE-2022-50405",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/tunnel: wait until all sk_user_data reader finish before releasing the sock\n\nThere is a race condition in vxlan that when deleting a vxlan device\nduring receiving packets, there is a possibility that the sock is\nreleased after getting vxlan_sock vs from sk_user_data. Then in\nlater vxlan_ecn_decapsulate(), vxlan_get_sk_family() we will got\nNULL pointer dereference. e.g.\n\n   #0 [ffffa25ec6978a38] machine_kexec at ffffffff8c669757\n   #1 [ffffa25ec6978a90] __crash_kexec at ffffffff8c7c0a4d\n   #2 [ffffa25ec6978b58] crash_kexec at ffffffff8c7c1c48\n   #3 [ffffa25ec6978b60] oops_end at ffffffff8c627f2b\n   #4 [ffffa25ec6978b80] page_fault_oops at ffffffff8c678fcb\n   #5 [ffffa25ec6978bd8] exc_page_fault at ffffffff8d109542\n   #6 [ffffa25ec6978c00] asm_exc_page_fault at ffffffff8d200b62\n      [exception RIP: vxlan_ecn_decapsulate+0x3b]\n      RIP: ffffffffc1014e7b  RSP: ffffa25ec6978cb0  RFLAGS: 00010246\n      RAX: 0000000000000008  RBX: ffff8aa000888000  RCX: 0000000000000000\n      RDX: 000000000000000e  RSI: ffff8a9fc7ab803e  RDI: ffff8a9fd1168700\n      RBP: ffff8a9fc7ab803e   R8: 0000000000700000   R9: 00000000000010ae\n      R10: ffff8a9fcb748980  R11: 0000000000000000  R12: ffff8a9fd1168700\n      R13: ffff8aa000888000  R14: 00000000002a0000  R15: 00000000000010ae\n      ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n   #7 [ffffa25ec6978ce8] vxlan_rcv at ffffffffc10189cd [vxlan]\n   #8 [ffffa25ec6978d90] udp_queue_rcv_one_skb at ffffffff8cfb6507\n   #9 [ffffa25ec6978dc0] udp_unicast_rcv_skb at ffffffff8cfb6e45\n  #10 [ffffa25ec6978dc8] __udp4_lib_rcv at ffffffff8cfb8807\n  #11 [ffffa25ec6978e20] ip_protocol_deliver_rcu at ffffffff8cf76951\n  #12 [ffffa25ec6978e48] ip_local_deliver at ffffffff8cf76bde\n  #13 [ffffa25ec6978ea0] __netif_receive_skb_one_core at ffffffff8cecde9b\n  #14 [ffffa25ec6978ec8] process_backlog at ffffffff8cece139\n  #15 [ffffa25ec6978f00] __napi_poll at ffffffff8ceced1a\n  #16 [ffffa25ec6978f28] net_rx_action at ffffffff8cecf1f3\n  #17 [ffffa25ec6978fa0] __softirqentry_text_start at ffffffff8d4000ca\n  #18 [ffffa25ec6978ff0] do_softirq at ffffffff8c6fbdc3\n\nReproducer: https://github.com/Mellanox/ovs-tests/blob/master/test-ovs-vxlan-remove-tunnel-during-traffic.sh\n\nFix this by waiting for all sk_user_data reader to finish before\nreleasing the sock.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2022-50470",
      "Note": "In the Linux kernel, there is a vulnerability in the USB host controller interface (xHCI). When the xHC host is dying or being removed, endpoints are not properly cleaned up, remaining in the bandwidth list when freeing the virtual device. This causes a list_del corruption kernel crash when unbinding xhci-pci, as xhci_mem_cleanup() later attempts to delete already freed endpoints from the bandwidth list. This vulnerability only affects hosts that use software bandwidth checking, which currently is only the xHC in Intel Panther Point PCH (Ivy Bridge).",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.7",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2022-50494",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:thermal: intel_powerclamp: Use get_cpu() instead of smp_processor_id() to avoid crashWhen CPU 0 is offline and intel_powerclamp is used to injectidle, it generates kernel BUG:BUG: using smp_processor_id() in preemptible [00000000] code: bash/15687caller is debug_smp_processor_id+0x17/0x20CPU: 4 PID: 15687 Comm: bash Not tainted 5.19.0-rc7+ #57Call Trace:\u003cTASK\u003edump_stack_lvl+0x49/0x63dump_stack+0x10/0x16check_preemption_disabled+0xdd/0xe0debug_smp_processor_id+0x17/0x20powerclamp_set_cur_state+0x7f/0xf9 [intel_powerclamp]......Here CPU 0 is the control CPU by default and changed to the current CPU,if CPU 0 offlined. This check has to be performed under cpus_read_lock(),hence the above warning.Use get_cpu() instead of smp_processor_id() to avoid this BUG.[ rjw: Subject edits ]",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.7",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2022-50505",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:iommu/amd: Fix pci device refcount leak in ppr_notifier()As comment of pci_get_domain_bus_and_slot() says, it returnsa pci device with refcount increment, when finish using it,the caller must decrement the reference count by callingpci_dev_put(). So call it before returning from ppr_notifier()to avoid refcount leak.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2022-50544",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:usb: host: xhci: Fix potential memory leak in xhci_alloc_stream_info()xhci_alloc_stream_info() allocates stream context array for stream_info-\u003estream_ctx_array with xhci_alloc_stream_ctx(). When some error occurs,stream_info-\u003estream_ctx_array is not released, which will lead to amemory leak.We can fix it by releasing the stream_info-\u003estream_ctx_array withxhci_free_stream_ctx() on the error path to avoid the potential memoryleak.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2022-50566",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:mtd: Fix device name leak when register device failed in add_mtd_device()There is a kmemleak when register device failed:  unreferenced object 0xffff888101aab550 (size 8):    comm  insmod , pid 3922, jiffies 4295277753 (age 925.408s)    hex dump (first 8 bytes):      6d 74 64 30 00 88 ff ff                          mtd0....    backtrace:      [\u003c00000000bde26724\u003e] __kmalloc_node_track_caller+0x4e/0x150      [\u003c000000003c32b416\u003e] kvasprintf+0xb0/0x130      [\u003c000000001f7a8f15\u003e] kobject_set_name_vargs+0x2f/0xb0      [\u003c000000006e781163\u003e] dev_set_name+0xab/0xe0      [\u003c00000000e30d0c78\u003e] add_mtd_device+0x4bb/0x700      [\u003c00000000f3d34de7\u003e] mtd_device_parse_register+0x2ac/0x3f0      [\u003c00000000c0d88488\u003e] 0xffffffffa0238457      [\u003c00000000b40d0922\u003e] 0xffffffffa02a008f      [\u003c0000000023d17b9d\u003e] do_one_initcall+0x87/0x2a0      [\u003c00000000770f6ca6\u003e] do_init_module+0xdf/0x320      [\u003c000000007b6768fe\u003e] load_module+0x2f98/0x3330      [\u003c00000000346bed5a\u003e] __do_sys_finit_module+0x113/0x1b0      [\u003c00000000674c2290\u003e] do_syscall_64+0x35/0x80      [\u003c000000004c6a8d97\u003e] entry_SYSCALL_64_after_hwframe+0x46/0xb0If register device failed, should call put_device() to give up thereference.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53265",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: ensure that VID header offset + VID header size \u003c= alloc, size\n\nEnsure that the VID header offset + VID header size does not exceed\nthe allocated area to avoid slab OOB.\n\nBUG: KASAN: slab-out-of-bounds in crc32_body lib/crc32.c:111 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_generic lib/crc32.c:179 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_base+0x58c/0x626 lib/crc32.c:197\nRead of size 4 at addr ffff88802bb36f00 by task syz-executor136/1555\n\nCPU: 2 PID: 1555 Comm: syz-executor136 Tainted: G        W\n6.0.0-1868 #1\nHardware name: Red Hat KVM, BIOS 1.13.0-2.module+el8.3.0+7860+a7792d29\n04/01/2014\nCall Trace:\n  \u003cTASK\u003e\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x85/0xad lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:317 [inline]\n  print_report.cold.13+0xb6/0x6bb mm/kasan/report.c:433\n  kasan_report+0xa7/0x11b mm/kasan/report.c:495\n  crc32_body lib/crc32.c:111 [inline]\n  crc32_le_generic lib/crc32.c:179 [inline]\n  crc32_le_base+0x58c/0x626 lib/crc32.c:197\n  ubi_io_write_vid_hdr+0x1b7/0x472 drivers/mtd/ubi/io.c:1067\n  create_vtbl+0x4d5/0x9c4 drivers/mtd/ubi/vtbl.c:317\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\nRIP: 0033:0x7f96d5cf753d\nCode:\nRSP: 002b:00007fffd72206f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f96d5cf753d\nRDX: 0000000020000080 RSI: 0000000040186f40 RDI: 0000000000000003\nRBP: 0000000000400cd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400be0\nR13: 00007fffd72207e0 R14: 0000000000000000 R15: 0000000000000000\n  \u003c/TASK\u003e\n\nAllocated by task 1555:\n  kasan_save_stack+0x20/0x3d mm/kasan/common.c:38\n  kasan_set_track mm/kasan/common.c:45 [inline]\n  set_alloc_info mm/kasan/common.c:437 [inline]\n  ____kasan_kmalloc mm/kasan/common.c:516 [inline]\n  __kasan_kmalloc+0x88/0xa3 mm/kasan/common.c:525\n  kasan_kmalloc include/linux/kasan.h:234 [inline]\n  __kmalloc+0x138/0x257 mm/slub.c:4429\n  kmalloc include/linux/slab.h:605 [inline]\n  ubi_alloc_vid_buf drivers/mtd/ubi/ubi.h:1093 [inline]\n  create_vtbl+0xcc/0x9c4 drivers/mtd/ubi/vtbl.c:295\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\n\nThe buggy address belongs to the object at ffff88802bb36e00\n  which belongs to the cache kmalloc-256 of size 256\nThe buggy address is located 0 bytes to the right of\n  256-byte region [ffff88802bb36e00, ffff88802bb36f00)\n\nThe buggy address belongs to the physical page:\npage:00000000ea4d1263 refcount:1 mapcount:0 mapping:0000000000000000\nindex:0x0 pfn:0x2bb36\nhead:00000000ea4d1263 order:1 compound_mapcount:0 compound_pincount:0\nflags: 0xfffffc0010200(slab|head|node=0|zone=1|lastcpupid=0x1fffff)\nraw: 000fffffc0010200 ffffea000066c300 dead000000000003 ffff888100042b40\nraw: 0000000000000000 00000000001\n---truncated---",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53271",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: Fix unreferenced object reported by kmemleak in ubi_resize_volume()\n\nThere is a memory leaks problem reported by kmemleak:\n\nunreferenced object 0xffff888102007a00 (size 128):\n  comm \"ubirsvol\", pid 32090, jiffies 4298464136 (age 2361.231s)\n  hex dump (first 32 bytes):\nff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................\nff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................\n  backtrace:\n[\u003cffffffff8176cecd\u003e] __kmalloc+0x4d/0x150\n[\u003cffffffffa02a9a36\u003e] ubi_eba_create_table+0x76/0x170 [ubi]\n[\u003cffffffffa029764e\u003e] ubi_resize_volume+0x1be/0xbc0 [ubi]\n[\u003cffffffffa02a3321\u003e] ubi_cdev_ioctl+0x701/0x1850 [ubi]\n[\u003cffffffff81975d2d\u003e] __x64_sys_ioctl+0x11d/0x170\n[\u003cffffffff83c142a5\u003e] do_syscall_64+0x35/0x80\n[\u003cffffffff83e0006a\u003e] entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis is due to a mismatch between create and destroy interfaces, and\nin detail that \"new_eba_tbl\" created by ubi_eba_create_table() but\ndestroyed by kfree(), while will causing \"new_eba_tbl-\u003eentries\" not\nfreed.\n\nFix it by replacing kfree(new_eba_tbl) with\nubi_eba_destroy_table(new_eba_tbl)",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53296",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: check send stream number after wait_for_sndbuf\n\nThis patch fixes a corner case where the asoc out stream count may change\nafter wait_for_sndbuf.\n\nWhen the main thread in the client starts a connection, if its out stream\ncount is set to N while the in stream count in the server is set to N - 2,\nanother thread in the client keeps sending the msgs with stream number\nN - 1, and waits for sndbuf before processing INIT_ACK.\n\nHowever, after processing INIT_ACK, the out stream count in the client is\nshrunk to N - 2, the same to the in stream count in the server. The crash\noccurs when the thread waiting for sndbuf is awake and sends the msg in a\nnon-existing stream(N - 1), the call trace is as below:\n\n  KASAN: null-ptr-deref in range [0x0000000000000038-0x000000000000003f]\n  Call Trace:\n   \u003cTASK\u003e\n   sctp_cmd_send_msg net/sctp/sm_sideeffect.c:1114 [inline]\n   sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1777 [inline]\n   sctp_side_effects net/sctp/sm_sideeffect.c:1199 [inline]\n   sctp_do_sm+0x197d/0x5310 net/sctp/sm_sideeffect.c:1170\n   sctp_primitive_SEND+0x9f/0xc0 net/sctp/primitive.c:163\n   sctp_sendmsg_to_asoc+0x10eb/0x1a30 net/sctp/socket.c:1868\n   sctp_sendmsg+0x8d4/0x1d90 net/sctp/socket.c:2026\n   inet_sendmsg+0x9d/0xe0 net/ipv4/af_inet.c:825\n   sock_sendmsg_nosec net/socket.c:722 [inline]\n   sock_sendmsg+0xde/0x190 net/socket.c:745\n\nThe fix is to add an unlikely check for the send stream number after the\nthread wakes up from the wait_for_sndbuf.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53372",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: fix a potential overflow in sctp_ifwdtsn_skip\n\nCurrently, when traversing ifwdtsn skips with _sctp_walk_ifwdtsn, it only\nchecks the pos against the end of the chunk. However, the data left for\nthe last pos may be \u003c sizeof(struct sctp_ifwdtsn_skip), and dereference\nit as struct sctp_ifwdtsn_skip may cause coverflow.\n\nThis patch fixes it by checking the pos against \"the end of the chunk -\nsizeof(struct sctp_ifwdtsn_skip)\" in sctp_ifwdtsn_skip, similar to\nsctp_fwdtsn_skip.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53384",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: avoid possible NULL skb pointer dereference\n\nIn 'mwifiex_handle_uap_rx_forward()', always check the value\nreturned by 'skb_copy()' to avoid potential NULL pointer\ndereference in 'mwifiex_uap_queue_bridged_pkt()', and drop\noriginal skb in case of copying failure.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53453",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/radeon: free iio for atombios when driver shutdown\n\nFix below kmemleak when unload radeon driver:\n\nunreferenced object 0xffff9f8608ede200 (size 512):\n  comm \"systemd-udevd\", pid 326, jiffies 4294682822 (age 716.338s)\n  hex dump (first 32 bytes):\n    00 00 00 00 c4 aa ec aa 14 ab 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [\u003c0000000062fadebe\u003e] kmem_cache_alloc_trace+0x2f1/0x500\n    [\u003c00000000b6883cea\u003e] atom_parse+0x117/0x230 [radeon]\n    [\u003c00000000158c23fd\u003e] radeon_atombios_init+0xab/0x170 [radeon]\n    [\u003c00000000683f672e\u003e] si_init+0x57/0x750 [radeon]\n    [\u003c00000000566cc31f\u003e] radeon_device_init+0x559/0x9c0 [radeon]\n    [\u003c0000000046efabb3\u003e] radeon_driver_load_kms+0xc1/0x1a0 [radeon]\n    [\u003c00000000b5155064\u003e] drm_dev_register+0xdd/0x1d0\n    [\u003c0000000045fec835\u003e] radeon_pci_probe+0xbd/0x100 [radeon]\n    [\u003c00000000e69ecca3\u003e] pci_device_probe+0xe1/0x160\n    [\u003c0000000019484b76\u003e] really_probe.part.0+0xc1/0x2c0\n    [\u003c000000003f2649da\u003e] __driver_probe_device+0x96/0x130\n    [\u003c00000000231c5bb1\u003e] driver_probe_device+0x24/0xf0\n    [\u003c0000000000a42377\u003e] __driver_attach+0x77/0x190\n    [\u003c00000000d7574da6\u003e] bus_for_each_dev+0x7f/0xd0\n    [\u003c00000000633166d2\u003e] driver_attach+0x1e/0x30\n    [\u003c00000000313b05b8\u003e] bus_add_driver+0x12c/0x1e0\n\niio was allocated in atom_index_iio() called by atom_parse(),\nbut it doesn't got released when the dirver is shutdown.\nFix this kmemleak by free it in radeon_atombios_fini().",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.1",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53481",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: ubi_wl_put_peb: Fix infinite loop when wear-leveling work failed\n\nFollowing process will trigger an infinite loop in ubi_wl_put_peb():\n\n\tubifs_bgt\t\tubi_bgt\nubifs_leb_unmap\n  ubi_leb_unmap\n    ubi_eba_unmap_leb\n      ubi_wl_put_peb\twear_leveling_worker\n                          e1 = rb_entry(rb_first(\u0026ubi-\u003eused)\n\t\t\t  e2 = get_peb_for_wl(ubi)\n\t\t\t  ubi_io_read_vid_hdr  // return err (flash fault)\n\t\t\t  out_error:\n\t\t\t    ubi-\u003emove_from = ubi-\u003emove_to = NULL\n\t\t\t    wl_entry_destroy(ubi, e1)\n\t\t\t      ubi-\u003elookuptbl[e-\u003epnum] = NULL\n      retry:\n        e = ubi-\u003elookuptbl[pnum];\t// return NULL\n\tif (e == ubi-\u003emove_from) {\t// NULL == NULL gets true\n\t  goto retry;\t\t\t// infinite loop !!!\n\n$ top\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     COMMAND\n  7676 root     20   0       0      0      0 R 100.0  0.0  ubifs_bgt0_0\n\nFix it by:\n 1) Letting ubi_wl_put_peb() returns directly if wearl leveling entry has\n    been removed from 'ubi-\u003elookuptbl'.\n 2) Using 'ubi-\u003ewl_lock' protecting wl entry deletion to preventing an\n    use-after-free problem for wl entry in ubi_wl_put_peb().\n\nFetch a reproducer in [Link].",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53515",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-mmio: don't break lifecycle of vm_dev\n\nvm_dev has a separate lifecycle because it has a 'struct device'\nembedded. Thus, having a release callback for it is correct.\n\nAllocating the vm_dev struct with devres totally breaks this protection,\nthough. Instead of waiting for the vm_dev release callback, the memory\nis freed when the platform_device is removed. Resulting in a\nuse-after-free when finally the callback is to be called.\n\nTo easily see the problem, compile the kernel with\nCONFIG_DEBUG_KOBJECT_RELEASE and unbind with sysfs.\n\nThe fix is easy, don't use devres in this case.\n\nFound during my research about object lifetime problems.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.4",
        "Vector": "AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53567",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:spi: qup: Don t skip cleanup in remove s error pathReturning early in a platform driver s remove callback is wrong. In thiscase the dma resources are not released in the error path. this is neverretried later and so this is a permanent leak. To fix this, only skiphardware disabling if waking the device fails.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53604",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:dm integrity: call kmem_cache_destroy() in dm_integrity_init() error pathOtherwise the journal_io_cache will leak if dm_register_target() fails.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53648",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:ALSA: ac97: Fix possible NULL dereference in snd_ac97_mixersmatch error:sound/pci/ac97/ac97_codec.c:2354 snd_ac97_mixer() error:we previously assumed  rac97  could be null (see line 2072)remove redundant assignment, return error if rac97 is NULL.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53681",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:bcache: Fix __bch_btree_node_alloc to make the failure behavior consistentIn some specific situations, the return value of __bch_btree_node_allocmay be NULL. This may lead to a potential NULL pointer dereference incaller function like a calling chain :btree_split-\u003ebch_btree_node_alloc-\u003e__bch_btree_node_alloc.Fix it by initializing the return value in __bch_btree_node_alloc.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53719",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:serial: arc_uart: fix of_iomap leak in `arc_serial_probe`Smatch reports:drivers/tty/serial/arc_uart.c:631 arc_serial_probe() warn: port-\u003emembase  from of_iomap() not released on lines: 631.In arc_serial_probe(), if uart_add_one_port() fails,port-\u003emembase is not released, which would cause a resource leak.To fix this, I replace of_iomap with devm_platform_ioremap_resource.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2023-53728",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:posix-timers: Ensure timer ID search-loop limit is validposix_timer_add() tries to allocate a posix timer ID by starting from thecached ID which was stored by the last successful allocation.This is done in a loop searching the ID space for a free slot one byone. The loop has to terminate when the search wrapped around to thestarting point.But that s racy vs. establishing the starting point. That is read outlockless, which leads to the following problem:CPU0                    CPU1posix_timer_add()  start = sig-\u003eposix_timer_id;  lock(hash_lock);  ...       posix_timer_add()  if (++sig-\u003eposix_timer_id \u003c 0)                      start = sig-\u003eposix_timer_id;     sig-\u003eposix_timer_id = 0;So CPU1 can observe a negative start value, i.e. -1, and the loop breaknever happens because the condition can never be true:  if (sig-\u003eposix_timer_id == start)     break;While this is unlikely to ever turn into an endless loop as the ID space ishuge (INT_MAX), the racy read of the start value caught the attention ofKCSAN and Dmitry unearthed that incorrectness.Rewrite it so that all id operations are under the hash lock.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2024-53168",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:sunrpc: fix one UAF issue caused by sunrpc kernel tcp socketBUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0Read of size 1 at addr ffff888111f322cd by task swapper/0/0CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1Call Trace: \u003cIRQ\u003e dump_stack_lvl+0x68/0xa0 print_address_description.constprop.0+0x2c/0x3d0 print_report+0xb4/0x270 kasan_report+0xbd/0xf0 tcp_write_timer_handler+0x156/0x3e0 tcp_write_timer+0x66/0x170 call_timer_fn+0xfb/0x1d0 __run_timers+0x3f8/0x480 run_timer_softirq+0x9b/0x100 handle_softirqs+0x153/0x390 __irq_exit_rcu+0x103/0x120 irq_exit_rcu+0xe/0x20 sysvec_apic_timer_interrupt+0x76/0x90 \u003c/IRQ\u003e \u003cTASK\u003e asm_sysvec_apic_timer_interrupt+0x1a/0x20RIP: 0010:default_idle+0xf/0x20Code: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 \u003cfa\u003e c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90RSP: 0018:ffffffffa2007e28 EFLAGS: 00000242RAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590fRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835dR10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000R13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0 default_idle_call+0x6b/0xa0 cpuidle_idle_call+0x1af/0x1f0 do_idle+0xbc/0x130 cpu_startup_entry+0x33/0x40 rest_init+0x11f/0x210 start_kernel+0x39a/0x420 x86_64_start_reservations+0x18/0x30 x86_64_start_kernel+0x97/0xa0 common_startup_64+0x13e/0x141 \u003c/TASK\u003eAllocated by task 595: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_slab_alloc+0x87/0x90 kmem_cache_alloc_noprof+0x12b/0x3f0 copy_net_ns+0x94/0x380 create_new_namespaces+0x24c/0x500 unshare_nsproxy_namespaces+0x75/0xf0 ksys_unshare+0x24e/0x4f0 __x64_sys_unshare+0x1f/0x30 do_syscall_64+0x70/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7eFreed by task 100: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x54/0x70 kmem_cache_free+0x156/0x5d0 cleanup_net+0x5d3/0x670 process_one_work+0x776/0xa90 worker_thread+0x2e2/0x560 kthread+0x1a8/0x1f0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30Reproduction script:mkdir -p /mnt/nfssharemkdir -p /mnt/nfs/netns_1mkfs.ext4 /dev/sdbmount /dev/sdb /mnt/nfssharesystemctl restart nfs-serverchmod 777 /mnt/nfsshareexportfs -i -o rw,no_root_squash *:/mnt/nfsshareip netns add netns_1ip link add name veth_1_peer type veth peer veth_1ifconfig veth_1_peer 11.11.0.254 upip link set veth_1 netns netns_1ip netns exec netns_1 ifconfig veth_1 11.11.0.1ip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp   --tcp-flags FIN FIN  -j DROP(note: In my environment, a DESTROY_CLIENTID operation is always sent immediately, breaking the nfs tcp connection.)ip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1   11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1ip netns del netns_1The reason here is that the tcp socket in netns_1 (nfs side) has beenshutdown and closed (done in xs_destroy), but the FIN message (with ack)is discarded, and the nfsd side keeps sending retransmission messages.As a result, when the tcp sock in netns_1 processes the received message,it sends the message (FIN message) in the sending queue, and the tcp timeris re-established. When the network namespace is deleted, the net structureaccessed by tcp s timer handler function causes problems.To fix this problem, let s hold netns refcnt for the tcp kernel socket asdone in other modules. This is an ugly hack which can easily be backportedto earlier kernels. A proper fix which cleans up the interfaces willfollow, but may not be so easy to backport.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2025-38180",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atm: fix /proc/net/atm/lec handling\n\n/proc/net/atm/lec must ensure safety against dev_lec[] changes.\n\nIt appears it had dev_put() calls without prior dev_hold(),\nleading to imbalance and UAF.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.8",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2025-38352",
      "Note": "In the Linux kernel, a race condition vulnerability exists in the posix-cpu-timers component. When a non-autoreaping exiting task has passed exit_notify() and calls handle_posix_cpu_timers() from IRQ, it can be reaped by its parent or debugger immediately after unlock_task_sighand(). If a concurrent posix_cpu_timer_del() runs at that moment, it will fail to detect timer-\u003eit.cpu.firing != 0 because cpu_timer_task_rcu() and/or lock_task_sighand() will fail. The fix adds a tsk-\u003eexit_state check to run_posix_cpu_timers().",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.6",
        "Vector": "AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2025-38729",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 power domain descriptors, too\n\nUAC3 power domain descriptors need to be verified with its variable\nbLength for avoiding the unexpected OOB accesses by malicious\nfirmware, too.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2025-39676",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla4xxx: Prevent a potential error pointer dereference\n\nThe qla4xxx_get_ep_fwdb() function is supposed to return NULL on error,\nbut qla4xxx_ep_connect() returns error pointers.  Propagating the error\npointers will lead to an Oops in the caller, so change the error pointers\nto NULL.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.1",
        "Vector": "AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    },
    {
      "CVE": "CVE-2025-39817",
      "Note": "A buffer overflow vulnerability was found in the efivarfs component of the Linux kernel. When dentry-\u003ed_name.len \u003c EFI_VARIABLE_GUID_LEN, \u0026#39;guid\u0026#39; may become negative, causing out-of-bounds reads. This vulnerability can be triggered by parallel search using invalid file names, causing kernel memory to be accessed out of bounds.",
      "ReleaseDate": "2025-10-31",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-20.03-LTS-SP4"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-31",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2553"
      }
    }
  ]
}