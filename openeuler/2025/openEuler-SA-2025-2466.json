{
  "Title": "An update for kernel is now available for openEuler-24.03-LTS-SP1",
  "Type": "Security Advisory",
  "Publisher": {
    "ContactDetails": "openeuler-security@openeuler.org",
    "IssuingAuthority": "openEuler security committee"
  },
  "Tracking": {
    "ID": "openEuler-SA-2025-2466",
    "Status": "Final",
    "Version": "1.0",
    "InitialReleaseDate": "2025-10-17",
    "CurrentReleaseDate": "2025-10-17",
    "Generator": {
      "Engine": "openEuler SA Tool V1.0",
      "Date": "2025-10-17"
    },
    "RevisionHistory": [
      {
        "Number": "1.0",
        "Date": "2025-10-17",
        "Description": "Initial"
      }
    ]
  },
  "Notes": [
    {
      "Text": "kernel security update",
      "Title": "Synopsis",
      "Type": "General"
    },
    {
      "Text": "An update for kernel is now available for openEuler-24.03-LTS-SP1",
      "Title": "Summary",
      "Type": "General"
    },
    {
      "Text": "The Linux Kernel, the operating system core itself.\n\nSecurity Fix(es):\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_conn: Use disable_delayed_work_sync\n\nThis makes use of disable_delayed_work_sync instead\ncancel_delayed_work_sync as it not only cancel the ongoing work but also\ndisables new submit which is disarable since the object holding the work\nis about to be freed.(CVE-2024-56591)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix memleak of nhc_pcpu_rth_output in fib_check_nh_v6_gw().\n\nfib_check_nh_v6_gw() expects that fib6_nh_init() cleans up everything\nwhen it fails.\n\nCommit 7dd73168e273 (\"ipv6: Always allocate pcpu memory in a fib6_nh\")\nmoved fib_nh_common_init() before alloc_percpu_gfp() within fib6_nh_init()\nbut forgot to add cleanup for fib6_nh-\u003enh_common.nhc_pcpu_rth_output in\ncase it fails to allocate fib6_nh-\u003ert6i_pcpu, resulting in memleak.\n\nLet's call fib_nh_common_release() and clear nhc_pcpu_rth_output in the\nerror path.\n\nNote that we can remove the fib6_nh_release() call in nh_create_ipv6()\nlater in net-next.git.(CVE-2025-22005)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nfs/ntfs3: Fix a couple integer overflows on 32bit systems\n\nOn 32bit systems the \"off + sizeof(struct NTFS_DE)\" addition can\nhave an integer wrapping issue.  Fix it by using size_add().(CVE-2025-22081)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\njfs: Prevent copying of nlink with value 0 from disk inode\n\nsyzbot report a deadlock in diFree. [1]\n\nWhen calling \"ioctl$LOOP_SET_STATUS64\", the offset value passed in is 4,\nwhich does not match the mounted loop device, causing the mapping of the\nmounted loop device to be invalidated.\n\nWhen creating the directory and creating the inode of iag in diReadSpecial(),\nread the page of fixed disk inode (AIT) in raw mode in read_metapage(), the\nmetapage data it returns is corrupted, which causes the nlink value of 0 to be\nassigned to the iag inode when executing copy_from_dinode(), which ultimately\ncauses a deadlock when entering diFree().\n\nTo avoid this, first check the nlink value of dinode before setting iag inode.\n\n[1]\nWARNING: possible recursive locking detected\n6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0 Not tainted\n--------------------------------------------\nsyz-executor301/5309 is trying to acquire lock:\nffff888044548920 (\u0026(imap-\u003eim_aglock[index])){+.+.}-{3:3}, at: diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889\n\nbut task is already holding lock:\nffff888044548920 (\u0026(imap-\u003eim_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(\u0026(imap-\u003eim_aglock[index]));\n  lock(\u0026(imap-\u003eim_aglock[index]));\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n5 locks held by syz-executor301/5309:\n #0: ffff8880422a4420 (sb_writers#9){.+.+}-{0:0}, at: mnt_want_write+0x3f/0x90 fs/namespace.c:515\n #1: ffff88804755b390 (\u0026type-\u003ei_mutex_dir_key#6/1){+.+.}-{3:3}, at: inode_lock_nested include/linux/fs.h:850 [inline]\n #1: ffff88804755b390 (\u0026type-\u003ei_mutex_dir_key#6/1){+.+.}-{3:3}, at: filename_create+0x260/0x540 fs/namei.c:4026\n #2: ffff888044548920 (\u0026(imap-\u003eim_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630\n #3: ffff888044548890 (\u0026imap-\u003eim_freelock){+.+.}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2460 [inline]\n #3: ffff888044548890 (\u0026imap-\u003eim_freelock){+.+.}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]\n #3: ffff888044548890 (\u0026imap-\u003eim_freelock){+.+.}-{3:3}, at: diAllocAG+0x4b7/0x1e50 fs/jfs/jfs_imap.c:1669\n #4: ffff88804755a618 (\u0026jfs_ip-\u003erdwrlock/1){++++}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2477 [inline]\n #4: ffff88804755a618 (\u0026jfs_ip-\u003erdwrlock/1){++++}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]\n #4: ffff88804755a618 (\u0026jfs_ip-\u003erdwrlock/1){++++}-{3:3}, at: diAllocAG+0x869/0x1e50 fs/jfs/jfs_imap.c:1669\n\nstack backtrace:\nCPU: 0 UID: 0 PID: 5309 Comm: syz-executor301 Not tainted 6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_deadlock_bug+0x483/0x620 kernel/locking/lockdep.c:3037\n check_deadlock kernel/locking/lockdep.c:3089 [inline]\n validate_chain+0x15e2/0x5920 kernel/locking/lockdep.c:3891\n __lock_acquire+0x1384/0x2050 kernel/locking/lockdep.c:5202\n lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825\n __mutex_lock_common kernel/locking/mutex.c:608 [inline]\n __mutex_lock+0x136/0xd70 kernel/locking/mutex.c:752\n diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889\n jfs_evict_inode+0x32d/0x440 fs/jfs/inode.c:156\n evict+0x4e8/0x9b0 fs/inode.c:725\n diFreeSpecial fs/jfs/jfs_imap.c:552 [inline]\n duplicateIXtree+0x3c6/0x550 fs/jfs/jfs_imap.c:3022\n diNewIAG fs/jfs/jfs_imap.c:2597 [inline]\n diAllocExt fs/jfs/jfs_imap.c:1905 [inline]\n diAllocAG+0x17dc/0x1e50 fs/jfs/jfs_imap.c:1669\n diAlloc+0x1d2/0x1630 fs/jfs/jfs_imap.c:1590\n ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56\n jfs_mkdir+0x1c5/0xba0 fs/jfs/namei.c:225\n vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257\n do_mkdirat+0x264/0x3a0 fs/namei.c:4280\n __do_sys_mkdirat fs/namei.c:4295 [inline]\n __se_sys_mkdirat fs/namei.c:4293 [inline]\n __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293\n do_syscall_x64 arch/x86/en\n---truncated---(CVE-2025-37741)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nnet: ch9200: fix uninitialised access during mii_nway_restart\n\nIn mii_nway_restart() the code attempts to call\nmii-\u003emdio_read which is ch9200_mdio_read(). ch9200_mdio_read()\nutilises a local buffer called \"buff\", which is initialised\nwith control_read(). However \"buff\" is conditionally\ninitialised inside control_read():\n\n        if (err == size) {\n                memcpy(data, buf, size);\n        }\n\nIf the condition of \"err == size\" is not met, then\n\"buff\" remains uninitialised. Once this happens the\nuninitialised \"buff\" is accessed and returned during\nch9200_mdio_read():\n\n        return (buff[0] | buff[1] \u003c\u003c 8);\n\nThe problem stems from the fact that ch9200_mdio_read()\nignores the return value of control_read(), leading to\nuinit-access of \"buff\".\n\nTo fix this we should check the return value of\ncontrol_read() and return early on error.(CVE-2025-38086)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/pp: Fix potential NULL pointer dereference in atomctrl_initialize_mc_reg_table\n\nThe function atomctrl_initialize_mc_reg_table() and\natomctrl_initialize_mc_reg_table_v2_2() does not check the return\nvalue of smu_atom_get_data_table(). If smu_atom_get_data_table()\nfails to retrieve vram_info, it returns NULL which is later\ndereferenced.(CVE-2025-38319)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Limit access to parser-\u003ebuffer when trace_get_user failed\n\nWhen the length of the string written to set_ftrace_filter exceeds\nFTRACE_BUFF_MAX, the following KASAN alarm will be triggered:\n\nBUG: KASAN: slab-out-of-bounds in strsep+0x18c/0x1b0\nRead of size 1 at addr ffff0000d00bd5ba by task ash/165\n\nCPU: 1 UID: 0 PID: 165 Comm: ash Not tainted 6.16.0-g6bcdbd62bd56-dirty\nHardware name: linux,dummy-virt (DT)\nCall trace:\n show_stack+0x34/0x50 (C)\n dump_stack_lvl+0xa0/0x158\n print_address_description.constprop.0+0x88/0x398\n print_report+0xb0/0x280\n kasan_report+0xa4/0xf0\n __asan_report_load1_noabort+0x20/0x30\n strsep+0x18c/0x1b0\n ftrace_process_regex.isra.0+0x100/0x2d8\n ftrace_regex_release+0x484/0x618\n __fput+0x364/0xa58\n ____fput+0x28/0x40\n task_work_run+0x154/0x278\n do_notify_resume+0x1f0/0x220\n el0_svc+0xec/0xf0\n el0t_64_sync_handler+0xa0/0xe8\n el0t_64_sync+0x1ac/0x1b0\n\nThe reason is that trace_get_user will fail when processing a string\nlonger than FTRACE_BUFF_MAX, but not set the end of parser-\u003ebuffer to 0.\nThen an OOB access will be triggered in ftrace_regex_release-\u003e\nftrace_process_regex-\u003estrsep-\u003estrpbrk. We can solve this problem by\nlimiting access to parser-\u003ebuffer when trace_get_user failed.(CVE-2025-39683)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Revise gateway LWS calls to probe user read access\n\nWe use load and stbys,e instructions to trigger memory reference\ninterruptions without writing to memory. Because of the way read\naccess support is implemented, read access interruptions are only\ntriggered at privilege levels 2 and 3. The kernel and gateway\npage execute at privilege level 0, so this code never triggers\na read access interruption. Thus, it is currently possible for\nuser code to execute a LWS compare and swap operation at an\naddress that is read protected at privilege level 3 (PRIV_USER).\n\nFix this by probing read access rights at privilege level 3 and\nbranching to lws_fault if access isn't allowed.(CVE-2025-39715)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\niommu/arm-smmu-qcom: Add SM6115 MDSS compatible\n\nAdd the SM6115 MDSS compatible to clients compatible list, as it also\nneeds that workaround.\nWithout this workaround, for example, QRB4210 RB2 which is based on\nSM4250/SM6115 generates a lot of smmu unhandled context faults during\nboot:\n\narm_smmu_context_fault: 116854 callbacks suppressed\narm-smmu c600000.iommu: Unhandled context fault: fsr=0x402,\niova=0x5c0ec600, fsynr=0x320021, cbfrsynra=0x420, cb=5\narm-smmu c600000.iommu: FSR    = 00000402 [Format=2 TF], SID=0x420\narm-smmu c600000.iommu: FSYNR0 = 00320021 [S1CBNDX=50 PNU PLVL=1]\narm-smmu c600000.iommu: Unhandled context fault: fsr=0x402,\niova=0x5c0d7800, fsynr=0x320021, cbfrsynra=0x420, cb=5\narm-smmu c600000.iommu: FSR    = 00000402 [Format=2 TF], SID=0x420\n\nand also failed initialisation of lontium lt9611uxc, gpu and dpu is\nobserved:\n(binding MDSS components triggered by lt9611uxc have failed)\n\n ------------[ cut here ]------------\n !aspace\n WARNING: CPU: 6 PID: 324 at drivers/gpu/drm/msm/msm_gem_vma.c:130 msm_gem_vma_init+0x150/0x18c [msm]\n Modules linked in: ... (long list of modules)\n CPU: 6 UID: 0 PID: 324 Comm: (udev-worker) Not tainted 6.15.0-03037-gaacc73ceeb8b #4 PREEMPT\n Hardware name: Qualcomm Technologies, Inc. QRB4210 RB2 (DT)\n pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : msm_gem_vma_init+0x150/0x18c [msm]\n lr : msm_gem_vma_init+0x150/0x18c [msm]\n sp : ffff80008144b280\n  \t\t...\n Call trace:\n  msm_gem_vma_init+0x150/0x18c [msm] (P)\n  get_vma_locked+0xc0/0x194 [msm]\n  msm_gem_get_and_pin_iova_range+0x4c/0xdc [msm]\n  msm_gem_kernel_new+0x48/0x160 [msm]\n  msm_gpu_init+0x34c/0x53c [msm]\n  adreno_gpu_init+0x1b0/0x2d8 [msm]\n  a6xx_gpu_init+0x1e8/0x9e0 [msm]\n  adreno_bind+0x2b8/0x348 [msm]\n  component_bind_all+0x100/0x230\n  msm_drm_bind+0x13c/0x3d0 [msm]\n  try_to_bring_up_aggregate_device+0x164/0x1d0\n  __component_add+0xa4/0x174\n  component_add+0x14/0x20\n  dsi_dev_attach+0x20/0x34 [msm]\n  dsi_host_attach+0x58/0x98 [msm]\n  devm_mipi_dsi_attach+0x34/0x90\n  lt9611uxc_attach_dsi.isra.0+0x94/0x124 [lontium_lt9611uxc]\n  lt9611uxc_probe+0x540/0x5fc [lontium_lt9611uxc]\n  i2c_device_probe+0x148/0x2a8\n  really_probe+0xbc/0x2c0\n  __driver_probe_device+0x78/0x120\n  driver_probe_device+0x3c/0x154\n  __driver_attach+0x90/0x1a0\n  bus_for_each_dev+0x68/0xb8\n  driver_attach+0x24/0x30\n  bus_add_driver+0xe4/0x208\n  driver_register+0x68/0x124\n  i2c_register_driver+0x48/0xcc\n  lt9611uxc_driver_init+0x20/0x1000 [lontium_lt9611uxc]\n  do_one_initcall+0x60/0x1d4\n  do_init_module+0x54/0x1fc\n  load_module+0x1748/0x1c8c\n  init_module_from_file+0x74/0xa0\n  __arm64_sys_finit_module+0x130/0x2f8\n  invoke_syscall+0x48/0x104\n  el0_svc_common.constprop.0+0xc0/0xe0\n  do_el0_svc+0x1c/0x28\n  el0_svc+0x2c/0x80\n  el0t_64_sync_handler+0x10c/0x138\n  el0t_64_sync+0x198/0x19c\n ---[ end trace 0000000000000000 ]---\n msm_dpu 5e01000.display-controller: [drm:msm_gpu_init [msm]] *ERROR* could not allocate memptrs: -22\n msm_dpu 5e01000.display-controller: failed to load adreno gpu\n platform a400000.remoteproc:glink-edge:apr:service@7:dais: Adding to iommu group 19\n msm_dpu 5e01000.display-controller: failed to bind 5900000.gpu (ops a3xx_ops [msm]): -22\n msm_dpu 5e01000.display-controller: adev bind failed: -22\n lt9611uxc 0-002b: failed to attach dsi to host\n lt9611uxc 0-002b: probe with driver lt9611uxc failed with error -22(CVE-2025-39739)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nARM: rockchip: fix kernel hang during smp initialization\n\nIn order to bring up secondary CPUs main CPU write trampoline\ncode to SRAM. The trampoline code is written while secondary\nCPUs are powered on (at least that true for RK3188 CPU).\nSometimes that leads to kernel hang. Probably because secondary\nCPU execute trampoline code while kernel doesn't expect.\n\nThe patch moves SRAM initialization step to the point where all\nsecondary CPUs are powered down.\n\nThat fixes rarely hangs on RK3188:\n[    0.091568] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000\n[    0.091996] rockchip_smp_prepare_cpus: ncores 4(CVE-2025-39752)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nusb: core: config: Prevent OOB read in SS endpoint companion parsing\n\nusb_parse_ss_endpoint_companion() checks descriptor type before length,\nenabling a potentially odd read outside of the buffer size.\n\nFix this up by checking the size first before looking at any of the\nfields in the descriptor.(CVE-2025-39760)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nfs/smb: Fix inconsistent refcnt update\n\nA possible inconsistent update of refcount was identified in `smb2_compound_op`.\nSuch inconsistent update could lead to possible resource leaks.\n\nWhy it is a possible bug:\n1. In the comment section of the function, it clearly states that the\nreference to `cfile` should be dropped after calling this function.\n2. Every control flow path would check and drop the reference to\n`cfile`, except the patched one.\n3. Existing callers would not handle refcount update of `cfile` if\n-ENOMEM is returned.\n\nTo fix the bug, an extra goto label \"out\" is added, to make sure that the\ncleanup logic would always be respected. As the problem is caused by the\nallocation failure of `vars`, the cleanup logic between label \"finished\"\nand \"out\" can be safely ignored. According to the definition of function\n`is_replayable_error`, the error code of \"-ENOMEM\" is not recoverable.\nTherefore, the replay logic also gets ignored.(CVE-2025-39819)\n\nA use-after-free vulnerability exists in the ASUS HID driver of the Linux kernel. After hid_hw_start() is called, hidinput_connect() configures the device with the input layer. When processing input and output reports, if the capability bitmaps are not properly set, the hidinput_has_been_populated() check fails, leading to the freeing of hid_input and the underlying input device. A malicious HID device (such as an ASUS ROG N-Key keyboard) can trigger this scenario via a specially crafted descriptor, resulting in use-after-free when writing to the name of the freed input device after hid_hw_start().(CVE-2025-39824)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nmm: move page table sync declarations to linux/pgtable.h\n\nDuring our internal testing, we started observing intermittent boot\nfailures when the machine uses 4-level paging and has a large amount of\npersistent memory:\n\n  BUG: unable to handle page fault for address: ffffe70000000034\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0002) - not-present page\n  PGD 0 P4D 0 \n  Oops: 0002 [#1] SMP NOPTI\n  RIP: 0010:__init_single_page+0x9/0x6d\n  Call Trace:\n   \u003cTASK\u003e\n   __init_zone_device_page+0x17/0x5d\n   memmap_init_zone_device+0x154/0x1bb\n   pagemap_range+0x2e0/0x40f\n   memremap_pages+0x10b/0x2f0\n   devm_memremap_pages+0x1e/0x60\n   dev_dax_probe+0xce/0x2ec [device_dax]\n   dax_bus_probe+0x6d/0xc9\n   [... snip ...]\n   \u003c/TASK\u003e\n\nIt turns out that the kernel panics while initializing vmemmap (struct\npage array) when the vmemmap region spans two PGD entries, because the new\nPGD entry is only installed in init_mm.pgd, but not in the page tables of\nother tasks.\n\nAnd looking at __populate_section_memmap():\n  if (vmemmap_can_optimize(altmap, pgmap))                                \n          // does not sync top level page tables\n          r = vmemmap_populate_compound_pages(pfn, start, end, nid, pgmap);\n  else                                                                    \n          // sync top level page tables in x86\n          r = vmemmap_populate(start, end, nid, altmap);\n\nIn the normal path, vmemmap_populate() in arch/x86/mm/init_64.c\nsynchronizes the top level page table (See commit 9b861528a801 (\"x86-64,\nmem: Update all PGDs for direct mapping and vmemmap mapping changes\")) so\nthat all tasks in the system can see the new vmemmap area.\n\nHowever, when vmemmap_can_optimize() returns true, the optimized path\nskips synchronization of top-level page tables.  This is because\nvmemmap_populate_compound_pages() is implemented in core MM code, which\ndoes not handle synchronization of the top-level page tables.  Instead,\nthe core MM has historically relied on each architecture to perform this\nsynchronization manually.\n\nWe're not the first party to encounter a crash caused by not-sync'd top\nlevel page tables: earlier this year, Gwan-gyeong Mun attempted to address\nthe issue [1] [2] after hitting a kernel panic when x86 code accessed the\nvmemmap area before the corresponding top-level entries were synced.  At\nthat time, the issue was believed to be triggered only when struct page\nwas enlarged for debugging purposes, and the patch did not get further\nupdates.\n\nIt turns out that current approach of relying on each arch to handle the\npage table sync manually is fragile because 1) it's easy to forget to sync\nthe top level page table, and 2) it's also easy to overlook that the\nkernel should not access the vmemmap and direct mapping areas before the\nsync.\n\n# The solution: Make page table sync more code robust and harder to miss\n\nTo address this, Dave Hansen suggested [3] [4] introducing\n{pgd,p4d}_populate_kernel() for updating kernel portion of the page tables\nand allow each architecture to explicitly perform synchronization when\ninstalling top-level entries.  With this approach, we no longer need to\nworry about missing the sync step, reducing the risk of future\nregressions.\n\nThe new interface reuses existing ARCH_PAGE_TABLE_SYNC_MASK,\nPGTBL_P*D_MODIFIED and arch_sync_kernel_mappings() facility used by\nvmalloc and ioremap to synchronize page tables.\n\npgd_populate_kernel() looks like this:\nstatic inline void pgd_populate_kernel(unsigned long addr, pgd_t *pgd,\n                                       p4d_t *p4d)\n{\n        pgd_populate(\u0026init_mm, pgd, p4d);\n        if (ARCH_PAGE_TABLE_SYNC_MASK \u0026 PGTBL_PGD_MODIFIED)\n                arch_sync_kernel_mappings(addr, addr);\n}\n\nIt is worth noting that vmalloc() and apply_to_range() carefully\nsynchronizes page tables by calling p*d_alloc_track() and\narch_sync_kernel_mappings(), and thus they are not affected by\n---truncated---(CVE-2025-39844)\n\nIn the Linux kernel, a vulnerability was found in the x86/mm/64 architecture regarding page table synchronization. The issue defines ARCH_PAGE_TABLE_SYNC_MASK and arch_sync_kernel_mappings() to ensure proper page table synchronization when calling p*d_populate_kernel(). For 5-level paging, synchronization is performed via pgd_populate_kernel(). In 4-level paging, pgd_populate() is a no-op, so synchronization is instead performed at the P4D level via p4d_populate_kernel(). This fixes intermittent boot failures on systems using 4-level paging and a large amount of persistent memory, as well as crashes in vmemmap_set_pmd() caused by accessing vmemmap before sync_global_pgds().(CVE-2025-39845)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nvxlan: Fix NPD in {arp,neigh}_reduce() when using nexthop objects\n\nWhen the \"proxy\" option is enabled on a VXLAN device, the device will\nsuppress ARP requests and IPv6 Neighbor Solicitation messages if it is\nable to reply on behalf of the remote host. That is, if a matching and\nvalid neighbor entry is configured on the VXLAN device whose MAC address\nis not behind the \"any\" remote (0.0.0.0 / ::).\n\nThe code currently assumes that the FDB entry for the neighbor's MAC\naddress points to a valid remote destination, but this is incorrect if\nthe entry is associated with an FDB nexthop group. This can result in a\nNPD [1][3] which can be reproduced using [2][4].\n\nFix by checking that the remote destination exists before dereferencing\nit.\n\n[1]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nCPU: 4 UID: 0 PID: 365 Comm: arping Not tainted 6.17.0-rc2-virtme-g2a89cb21162c #2 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014\nRIP: 0010:vxlan_xmit+0xb58/0x15f0\n[...]\nCall Trace:\n \u003cTASK\u003e\n dev_hard_start_xmit+0x5d/0x1c0\n __dev_queue_xmit+0x246/0xfd0\n packet_sendmsg+0x113a/0x1850\n __sock_sendmsg+0x38/0x70\n __sys_sendto+0x126/0x180\n __x64_sys_sendto+0x24/0x30\n do_syscall_64+0xa4/0x260\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\n[2]\n #!/bin/bash\n\n ip address add 192.0.2.1/32 dev lo\n\n ip nexthop add id 1 via 192.0.2.2 fdb\n ip nexthop add id 10 group 1 fdb\n\n ip link add name vx0 up type vxlan id 10010 local 192.0.2.1 dstport 4789 proxy\n\n ip neigh add 192.0.2.3 lladdr 00:11:22:33:44:55 nud perm dev vx0\n\n bridge fdb add 00:11:22:33:44:55 dev vx0 self static nhid 10\n\n arping -b -c 1 -s 192.0.2.1 -I vx0 192.0.2.3\n\n[3]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nCPU: 13 UID: 0 PID: 372 Comm: ndisc6 Not tainted 6.17.0-rc2-virtmne-g6ee90cb26014 #3 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1v996), BIOS 1.17.0-4.fc41 04/01/2x014\nRIP: 0010:vxlan_xmit+0x803/0x1600\n[...]\nCall Trace:\n \u003cTASK\u003e\n dev_hard_start_xmit+0x5d/0x1c0\n __dev_queue_xmit+0x246/0xfd0\n ip6_finish_output2+0x210/0x6c0\n ip6_finish_output+0x1af/0x2b0\n ip6_mr_output+0x92/0x3e0\n ip6_send_skb+0x30/0x90\n rawv6_sendmsg+0xe6e/0x12e0\n __sock_sendmsg+0x38/0x70\n __sys_sendto+0x126/0x180\n __x64_sys_sendto+0x24/0x30\n do_syscall_64+0xa4/0x260\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\nRIP: 0033:0x7f383422ec77\n\n[4]\n #!/bin/bash\n\n ip address add 2001:db8:1::1/128 dev lo\n\n ip nexthop add id 1 via 2001:db8:1::1 fdb\n ip nexthop add id 10 group 1 fdb\n\n ip link add name vx0 up type vxlan id 10010 local 2001:db8:1::1 dstport 4789 proxy\n\n ip neigh add 2001:db8:1::3 lladdr 00:11:22:33:44:55 nud perm dev vx0\n\n bridge fdb add 00:11:22:33:44:55 dev vx0 self static nhid 10\n\n ndisc6 -r 1 -s 2001:db8:1::1 -w 1 2001:db8:1::3 vx0(CVE-2025-39850)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nvxlan: Fix NPD when refreshing an FDB entry with a nexthop object\n\nVXLAN FDB entries can point to either a remote destination or an FDB\nnexthop group. The latter is usually used in EVPN deployments where\nlearning is disabled.\n\nHowever, when learning is enabled, an incoming packet might try to\nrefresh an FDB entry that points to an FDB nexthop group and therefore\ndoes not have a remote. Such packets should be dropped, but they are\nonly dropped after dereferencing the non-existent remote, resulting in a\nNPD [1] which can be reproduced using [2].\n\nFix by dropping such packets earlier. Remove the misleading comment from\nfirst_remote_rcu().\n\n[1]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nCPU: 13 UID: 0 PID: 361 Comm: mausezahn Not tainted 6.17.0-rc1-virtme-g9f6b606b6b37 #1 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014\nRIP: 0010:vxlan_snoop+0x98/0x1e0\n[...]\nCall Trace:\n \u003cTASK\u003e\n vxlan_encap_bypass+0x209/0x240\n encap_bypass_if_local+0xb1/0x100\n vxlan_xmit_one+0x1375/0x17e0\n vxlan_xmit+0x6b4/0x15f0\n dev_hard_start_xmit+0x5d/0x1c0\n __dev_queue_xmit+0x246/0xfd0\n packet_sendmsg+0x113a/0x1850\n __sock_sendmsg+0x38/0x70\n __sys_sendto+0x126/0x180\n __x64_sys_sendto+0x24/0x30\n do_syscall_64+0xa4/0x260\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\n[2]\n #!/bin/bash\n\n ip address add 192.0.2.1/32 dev lo\n ip address add 192.0.2.2/32 dev lo\n\n ip nexthop add id 1 via 192.0.2.3 fdb\n ip nexthop add id 10 group 1 fdb\n\n ip link add name vx0 up type vxlan id 10010 local 192.0.2.1 dstport 12345 localbypass\n ip link add name vx1 up type vxlan id 10020 local 192.0.2.2 dstport 54321 learning\n\n bridge fdb add 00:11:22:33:44:55 dev vx0 self static dst 192.0.2.2 port 54321 vni 10020\n bridge fdb add 00:aa:bb:cc:dd:ee dev vx1 self static nhid 10\n\n mausezahn vx0 -a 00:aa:bb:cc:dd:ee -b 00:11:22:33:44:55 -c 1 -q(CVE-2025-39851)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ni40e: Fix potential invalid access when MAC list is empty\n\nlist_first_entry() never returns NULL - if the list is empty, it still\nreturns a pointer to an invalid object, leading to potential invalid\nmemory access when dereferenced.\n\nFix this by using list_first_entry_or_null instead of list_first_entry.(CVE-2025-39853)\n\nA NULL pointer dereference vulnerability was discovered in the TEE subsystem of the Linux kernel. The tee_shm_put function has a NULL pointer dereference issue: in the __optee_disable_shm_cache function, reg_pair_to_ptr may return a NULL pointer, but when tee_shm_free calls tee_shm_put, no NULL pointer check is performed, causing system crashes. This vulnerability affects multiple Linux kernel versions and can lead to denial of service.(CVE-2025-39865)\n\nA vulnerability was found in Linux Kernel up to 6.1.152/6.6.106/6.12.47/6.16.7/6.17-rc5. The issue exists in the unpoison_memory function of the mm/memory-failure module, where it tries to check the PG_HWPoison flags of an uninitialized page, triggering VM_BUG_ON_PAGE(PagePoisoned(page)) and causing kernel panic. An attacker can trigger this vulnerability by offlining a memory block and writing an uninitialized page frame number to unpoison-pfn, leading to system crash and impacting confidentiality, integrity, and availability.(CVE-2025-39883)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Tell memcg to use allow_spinning=false path in bpf_timer_init()\n\nCurrently, calling bpf_map_kmalloc_node() from __bpf_async_init() can\ncause various locking issues; see the following stack trace (edited for\nstyle) as one example:\n\n...\n [10.011566]  do_raw_spin_lock.cold\n [10.011570]  try_to_wake_up             (5) double-acquiring the same\n [10.011575]  kick_pool                      rq_lock, causing a hardlockup\n [10.011579]  __queue_work\n [10.011582]  queue_work_on\n [10.011585]  kernfs_notify\n [10.011589]  cgroup_file_notify\n [10.011593]  try_charge_memcg           (4) memcg accounting raises an\n [10.011597]  obj_cgroup_charge_pages        MEMCG_MAX event\n [10.011599]  obj_cgroup_charge_account\n [10.011600]  __memcg_slab_post_alloc_hook\n [10.011603]  __kmalloc_node_noprof\n...\n [10.011611]  bpf_map_kmalloc_node\n [10.011612]  __bpf_async_init\n [10.011615]  bpf_timer_init             (3) BPF calls bpf_timer_init()\n [10.011617]  bpf_prog_xxxxxxxxxxxxxxxx_fcg_runnable\n [10.011619]  bpf__sched_ext_ops_runnable\n [10.011620]  enqueue_task_scx           (2) BPF runs with rq_lock held\n [10.011622]  enqueue_task\n [10.011626]  ttwu_do_activate\n [10.011629]  sched_ttwu_pending         (1) grabs rq_lock\n...\n\nThe above was reproduced on bpf-next (b338cf849ec8) by modifying\n./tools/sched_ext/scx_flatcg.bpf.c to call bpf_timer_init() during\nops.runnable(), and hacking the memcg accounting code a bit to make\na bpf_timer_init() call more likely to raise an MEMCG_MAX event.\n\nWe have also run into other similar variants (both internally and on\nbpf-next), including double-acquiring cgroup_file_kn_lock, the same\nworker_pool::lock, etc.\n\nAs suggested by Shakeel, fix this by using __GFP_HIGH instead of\nGFP_ATOMIC in __bpf_async_init(), so that e.g. if try_charge_memcg()\nraises an MEMCG_MAX event, we call __memcg_memory_event() with\n@allow_spinning=false and avoid calling cgroup_file_notify() there.\n\nDepends on mm patch\n\"memcg: skip cgroup_file_notify if spinning is not allowed\":\nhttps://lore.kernel.org/bpf/(CVE-2025-39886)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nsched: Fix sched_numa_find_nth_cpu() if mask offline\n\nsched_numa_find_nth_cpu() uses a bsearch to look for the 'closest'\nCPU in sched_domains_numa_masks and given cpus mask. However they\nmight not intersect if all CPUs in the cpus mask are offline. bsearch\nwill return NULL in that case, bail out instead of dereferencing a\nbogus pointer.\n\nThe previous behaviour lead to this bug when using maxcpus=4 on an\nrk3399 (LLLLbb) (i.e. booting with all big CPUs offline):\n\n[    1.422922] Unable to handle kernel paging request at virtual address ffffff8000000000\n[    1.423635] Mem abort info:\n[    1.423889]   ESR = 0x0000000096000006\n[    1.424227]   EC = 0x25: DABT (current EL), IL = 32 bits\n[    1.424715]   SET = 0, FnV = 0\n[    1.424995]   EA = 0, S1PTW = 0\n[    1.425279]   FSC = 0x06: level 2 translation fault\n[    1.425735] Data abort info:\n[    1.425998]   ISV = 0, ISS = 0x00000006, ISS2 = 0x00000000\n[    1.426499]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n[    1.426952]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n[    1.427428] swapper pgtable: 4k pages, 39-bit VAs, pgdp=0000000004a9f000\n[    1.428038] [ffffff8000000000] pgd=18000000f7fff403, p4d=18000000f7fff403, pud=18000000f7fff403, pmd=0000000000000000\n[    1.429014] Internal error: Oops: 0000000096000006 [#1]  SMP\n[    1.429525] Modules linked in:\n[    1.429813] CPU: 3 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.17.0-rc4-dirty #343 PREEMPT\n[    1.430559] Hardware name: Pine64 RockPro64 v2.1 (DT)\n[    1.431012] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    1.431634] pc : sched_numa_find_nth_cpu+0x2a0/0x488\n[    1.432094] lr : sched_numa_find_nth_cpu+0x284/0x488\n[    1.432543] sp : ffffffc084e1b960\n[    1.432843] x29: ffffffc084e1b960 x28: ffffff80078a8800 x27: ffffffc0846eb1d0\n[    1.433495] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000\n[    1.434144] x23: 0000000000000000 x22: fffffffffff7f093 x21: ffffffc081de6378\n[    1.434792] x20: 0000000000000000 x19: 0000000ffff7f093 x18: 00000000ffffffff\n[    1.435441] x17: 3030303866666666 x16: 66663d736b73616d x15: ffffffc104e1b5b7\n[    1.436091] x14: 0000000000000000 x13: ffffffc084712860 x12: 0000000000000372\n[    1.436739] x11: 0000000000000126 x10: ffffffc08476a860 x9 : ffffffc084712860\n[    1.437389] x8 : 00000000ffffefff x7 : ffffffc08476a860 x6 : 0000000000000000\n[    1.438036] x5 : 000000000000bff4 x4 : 0000000000000000 x3 : 0000000000000000\n[    1.438683] x2 : 0000000000000000 x1 : ffffffc0846eb000 x0 : ffffff8000407b68\n[    1.439332] Call trace:\n[    1.439559]  sched_numa_find_nth_cpu+0x2a0/0x488 (P)\n[    1.440016]  smp_call_function_any+0xc8/0xd0\n[    1.440416]  armv8_pmu_init+0x58/0x27c\n[    1.440770]  armv8_cortex_a72_pmu_init+0x20/0x2c\n[    1.441199]  arm_pmu_device_probe+0x1e4/0x5e8\n[    1.441603]  armv8_pmu_device_probe+0x1c/0x28\n[    1.442007]  platform_probe+0x5c/0xac\n[    1.442347]  really_probe+0xbc/0x298\n[    1.442683]  __driver_probe_device+0x78/0x12c\n[    1.443087]  driver_probe_device+0xdc/0x160\n[    1.443475]  __driver_attach+0x94/0x19c\n[    1.443833]  bus_for_each_dev+0x74/0xd4\n[    1.444190]  driver_attach+0x24/0x30\n[    1.444525]  bus_add_driver+0xe4/0x208\n[    1.444874]  driver_register+0x60/0x128\n[    1.445233]  __platform_driver_register+0x24/0x30\n[    1.445662]  armv8_pmu_driver_init+0x28/0x4c\n[    1.446059]  do_one_initcall+0x44/0x25c\n[    1.446416]  kernel_init_freeable+0x1dc/0x3bc\n[    1.446820]  kernel_init+0x20/0x1d8\n[    1.447151]  ret_from_fork+0x10/0x20\n[    1.447493] Code: 90022e21 f000e5f5 910de2b5 2a1703e2 (f8767803)\n[    1.448040] ---[ end trace 0000000000000000 ]---\n[    1.448483] note: swapper/0[1] exited with preempt_count 1\n[    1.449047] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n[    1.449741] SMP: stopping secondary CPUs\n[    1.450105] Kernel Offset: disabled\n[    1.450419] CPU features: 0x000000,00080000,20002001,0400421b\n[    \n---truncated---(CVE-2025-39895)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Silence warning when chunk allocation fails in trace_pid_write\n\nSyzkaller trigger a fault injection warning:\n\nWARNING: CPU: 1 PID: 12326 at tracepoint_add_func+0xbfc/0xeb0\nModules linked in:\nCPU: 1 UID: 0 PID: 12326 Comm: syz.6.10325 Tainted: G U 6.14.0-rc5-syzkaller #0\nTainted: [U]=USER\nHardware name: Google Compute Engine/Google Compute Engine\nRIP: 0010:tracepoint_add_func+0xbfc/0xeb0 kernel/tracepoint.c:294\nCode: 09 fe ff 90 0f 0b 90 0f b6 74 24 43 31 ff 41 bc ea ff ff ff\nRSP: 0018:ffffc9000414fb48 EFLAGS: 00010283\nRAX: 00000000000012a1 RBX: ffffffff8e240ae0 RCX: ffffc90014b78000\nRDX: 0000000000080000 RSI: ffffffff81bbd78b RDI: 0000000000000001\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffffffffffffffef\nR13: 0000000000000000 R14: dffffc0000000000 R15: ffffffff81c264f0\nFS:  00007f27217f66c0(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000001b2e80dff8 CR3: 00000000268f8000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n \u003cTASK\u003e\n tracepoint_probe_register_prio+0xc0/0x110 kernel/tracepoint.c:464\n register_trace_prio_sched_switch include/trace/events/sched.h:222 [inline]\n register_pid_events kernel/trace/trace_events.c:2354 [inline]\n event_pid_write.isra.0+0x439/0x7a0 kernel/trace/trace_events.c:2425\n vfs_write+0x24c/0x1150 fs/read_write.c:677\n ksys_write+0x12b/0x250 fs/read_write.c:731\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nWe can reproduce the warning by following the steps below:\n1. echo 8 \u003e\u003e set_event_notrace_pid. Let tr-\u003efiltered_pids owns one pid\n   and register sched_switch tracepoint.\n2. echo ' ' \u003e\u003e set_event_pid, and perform fault injection during chunk\n   allocation of trace_pid_list_alloc. Let pid_list with no pid and\nassign to tr-\u003efiltered_pids.\n3. echo ' ' \u003e\u003e set_event_pid. Let pid_list is NULL and assign to\n   tr-\u003efiltered_pids.\n4. echo 9 \u003e\u003e set_event_pid, will trigger the double register\n   sched_switch tracepoint warning.\n\nThe reason is that syzkaller injects a fault into the chunk allocation\nin trace_pid_list_alloc, causing a failure in trace_pid_list_set, which\nmay trigger double register of the same tracepoint. This only occurs\nwhen the system is about to crash, but to suppress this warning, let's\nadd failure handling logic to trace_pid_list_set.(CVE-2025-39914)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ncgroup: split cgroup_destroy_wq into 3 workqueues\n\nA hung task can occur during [1] LTP cgroup testing when repeatedly\nmounting/unmounting perf_event and net_prio controllers with\nsystemd.unified_cgroup_hierarchy=1. The hang manifests in\ncgroup_lock_and_drain_offline() during root destruction.\n\nRelated case:\ncgroup_fj_function_perf_event cgroup_fj_function.sh perf_event\ncgroup_fj_function_net_prio cgroup_fj_function.sh net_prio\n\nCall Trace:\n\tcgroup_lock_and_drain_offline+0x14c/0x1e8\n\tcgroup_destroy_root+0x3c/0x2c0\n\tcss_free_rwork_fn+0x248/0x338\n\tprocess_one_work+0x16c/0x3b8\n\tworker_thread+0x22c/0x3b0\n\tkthread+0xec/0x100\n\tret_from_fork+0x10/0x20\n\nRoot Cause:\n\nCPU0                            CPU1\nmount perf_event                umount net_prio\ncgroup1_get_tree                cgroup_kill_sb\nrebind_subsystems               // root destruction enqueues\n\t\t\t\t// cgroup_destroy_wq\n// kill all perf_event css\n                                // one perf_event css A is dying\n                                // css A offline enqueues cgroup_destroy_wq\n                                // root destruction will be executed first\n                                css_free_rwork_fn\n                                cgroup_destroy_root\n                                cgroup_lock_and_drain_offline\n                                // some perf descendants are dying\n                                // cgroup_destroy_wq max_active = 1\n                                // waiting for css A to die\n\nProblem scenario:\n1. CPU0 mounts perf_event (rebind_subsystems)\n2. CPU1 unmounts net_prio (cgroup_kill_sb), queuing root destruction work\n3. A dying perf_event CSS gets queued for offline after root destruction\n4. Root destruction waits for offline completion, but offline work is\n   blocked behind root destruction in cgroup_destroy_wq (max_active=1)\n\nSolution:\nSplit cgroup_destroy_wq into three dedicated workqueues:\ncgroup_offline_wq – Handles CSS offline operations\ncgroup_release_wq – Manages resource release\ncgroup_free_wq – Performs final memory deallocation\n\nThis separation eliminates blocking in the CSS free path while waiting for\noffline operations to complete.\n\n[1] https://github.com/linux-test-project/ltp/blob/master/runtest/controllers(CVE-2025-39953)",
      "Title": "Description",
      "Type": "General"
    },
    {
      "Text": "An update for kernel is now available for openEuler-24.03-LTS-SP1.\n\nopenEuler Security has rated this update as having a security impact of high. A Common Vunlnerability Scoring System(CVSS)base score,which gives a detailed severity rating, is available for each vulnerability from the CVElink(s) in the References section.",
      "Title": "Topic",
      "Type": "General"
    },
    {
      "Text": "High",
      "Title": "Severity",
      "Type": "General"
    },
    {
      "Text": "kernel",
      "Title": "Affected Component",
      "Type": "General"
    }
  ],
  "ProductTree": {
    "Branches": [
      {
        "Type": "Product Name",
        "Name": "openEuler",
        "Productions": [
          {
            "ProductID": "openEuler-24.03-LTS-SP1",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "openEuler-24.03-LTS-SP1"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "aarch64",
        "Productions": [
          {
            "ProductID": "bpftool-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "bpftool-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "bpftool-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "bpftool-debuginfo-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-debuginfo-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-debugsource-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-debugsource-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-devel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-devel-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-headers-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-headers-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-source-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-source-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-tools-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-tools-debuginfo-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-devel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-tools-devel-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "perf-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "perf-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "perf-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "perf-debuginfo-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "python3-perf-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "python3-perf-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          },
          {
            "ProductID": "python3-perf-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "python3-perf-debuginfo-6.6.0-112.0.0.115.oe2403sp1.aarch64.rpm"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "x86_64",
        "Productions": [
          {
            "ProductID": "bpftool-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "bpftool-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "bpftool-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "bpftool-debuginfo-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-debuginfo-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-debugsource-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-debugsource-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-devel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-devel-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-headers-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-headers-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-source-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-source-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-tools-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-tools-debuginfo-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-devel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-tools-devel-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "perf-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "perf-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "perf-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "perf-debuginfo-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "python3-perf-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "python3-perf-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          },
          {
            "ProductID": "python3-perf-debuginfo-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "python3-perf-debuginfo-6.6.0-112.0.0.115.oe2403sp1.x86_64.rpm"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "src",
        "Productions": [
          {
            "ProductID": "kernel-6.6.0-112.0.0.115",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS-SP1",
            "Text": "kernel-6.6.0-112.0.0.115.oe2403sp1.src.rpm"
          }
        ]
      }
    ]
  },
  "References": [
    {
      "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
    },
    {
      "URL": "https://www.openeuler.org/en/security/cve/detail/?cveId=CVE-2025-39953"
    },
    {
      "URL": "https://nvd.nist.gov/vuln/detail/CVE-2025-39953"
    }
  ],
  "Vulnerabilities": [
    {
      "CVE": "CVE-2024-56591",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_conn: Use disable_delayed_work_sync\n\nThis makes use of disable_delayed_work_sync instead\ncancel_delayed_work_sync as it not only cancel the ongoing work but also\ndisables new submit which is disarable since the object holding the work\nis about to be freed.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-22005",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix memleak of nhc_pcpu_rth_output in fib_check_nh_v6_gw().\n\nfib_check_nh_v6_gw() expects that fib6_nh_init() cleans up everything\nwhen it fails.\n\nCommit 7dd73168e273 (\"ipv6: Always allocate pcpu memory in a fib6_nh\")\nmoved fib_nh_common_init() before alloc_percpu_gfp() within fib6_nh_init()\nbut forgot to add cleanup for fib6_nh-\u003enh_common.nhc_pcpu_rth_output in\ncase it fails to allocate fib6_nh-\u003ert6i_pcpu, resulting in memleak.\n\nLet's call fib_nh_common_release() and clear nhc_pcpu_rth_output in the\nerror path.\n\nNote that we can remove the fib6_nh_release() call in nh_create_ipv6()\nlater in net-next.git.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-22081",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/ntfs3: Fix a couple integer overflows on 32bit systems\n\nOn 32bit systems the \"off + sizeof(struct NTFS_DE)\" addition can\nhave an integer wrapping issue.  Fix it by using size_add().",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-37741",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: Prevent copying of nlink with value 0 from disk inode\n\nsyzbot report a deadlock in diFree. [1]\n\nWhen calling \"ioctl$LOOP_SET_STATUS64\", the offset value passed in is 4,\nwhich does not match the mounted loop device, causing the mapping of the\nmounted loop device to be invalidated.\n\nWhen creating the directory and creating the inode of iag in diReadSpecial(),\nread the page of fixed disk inode (AIT) in raw mode in read_metapage(), the\nmetapage data it returns is corrupted, which causes the nlink value of 0 to be\nassigned to the iag inode when executing copy_from_dinode(), which ultimately\ncauses a deadlock when entering diFree().\n\nTo avoid this, first check the nlink value of dinode before setting iag inode.\n\n[1]\nWARNING: possible recursive locking detected\n6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0 Not tainted\n--------------------------------------------\nsyz-executor301/5309 is trying to acquire lock:\nffff888044548920 (\u0026(imap-\u003eim_aglock[index])){+.+.}-{3:3}, at: diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889\n\nbut task is already holding lock:\nffff888044548920 (\u0026(imap-\u003eim_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(\u0026(imap-\u003eim_aglock[index]));\n  lock(\u0026(imap-\u003eim_aglock[index]));\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n5 locks held by syz-executor301/5309:\n #0: ffff8880422a4420 (sb_writers#9){.+.+}-{0:0}, at: mnt_want_write+0x3f/0x90 fs/namespace.c:515\n #1: ffff88804755b390 (\u0026type-\u003ei_mutex_dir_key#6/1){+.+.}-{3:3}, at: inode_lock_nested include/linux/fs.h:850 [inline]\n #1: ffff88804755b390 (\u0026type-\u003ei_mutex_dir_key#6/1){+.+.}-{3:3}, at: filename_create+0x260/0x540 fs/namei.c:4026\n #2: ffff888044548920 (\u0026(imap-\u003eim_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630\n #3: ffff888044548890 (\u0026imap-\u003eim_freelock){+.+.}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2460 [inline]\n #3: ffff888044548890 (\u0026imap-\u003eim_freelock){+.+.}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]\n #3: ffff888044548890 (\u0026imap-\u003eim_freelock){+.+.}-{3:3}, at: diAllocAG+0x4b7/0x1e50 fs/jfs/jfs_imap.c:1669\n #4: ffff88804755a618 (\u0026jfs_ip-\u003erdwrlock/1){++++}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2477 [inline]\n #4: ffff88804755a618 (\u0026jfs_ip-\u003erdwrlock/1){++++}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]\n #4: ffff88804755a618 (\u0026jfs_ip-\u003erdwrlock/1){++++}-{3:3}, at: diAllocAG+0x869/0x1e50 fs/jfs/jfs_imap.c:1669\n\nstack backtrace:\nCPU: 0 UID: 0 PID: 5309 Comm: syz-executor301 Not tainted 6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_deadlock_bug+0x483/0x620 kernel/locking/lockdep.c:3037\n check_deadlock kernel/locking/lockdep.c:3089 [inline]\n validate_chain+0x15e2/0x5920 kernel/locking/lockdep.c:3891\n __lock_acquire+0x1384/0x2050 kernel/locking/lockdep.c:5202\n lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825\n __mutex_lock_common kernel/locking/mutex.c:608 [inline]\n __mutex_lock+0x136/0xd70 kernel/locking/mutex.c:752\n diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889\n jfs_evict_inode+0x32d/0x440 fs/jfs/inode.c:156\n evict+0x4e8/0x9b0 fs/inode.c:725\n diFreeSpecial fs/jfs/jfs_imap.c:552 [inline]\n duplicateIXtree+0x3c6/0x550 fs/jfs/jfs_imap.c:3022\n diNewIAG fs/jfs/jfs_imap.c:2597 [inline]\n diAllocExt fs/jfs/jfs_imap.c:1905 [inline]\n diAllocAG+0x17dc/0x1e50 fs/jfs/jfs_imap.c:1669\n diAlloc+0x1d2/0x1630 fs/jfs/jfs_imap.c:1590\n ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56\n jfs_mkdir+0x1c5/0xba0 fs/jfs/namei.c:225\n vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257\n do_mkdirat+0x264/0x3a0 fs/namei.c:4280\n __do_sys_mkdirat fs/namei.c:4295 [inline]\n __se_sys_mkdirat fs/namei.c:4293 [inline]\n __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293\n do_syscall_x64 arch/x86/en\n---truncated---",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.1",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-38086",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ch9200: fix uninitialised access during mii_nway_restart\n\nIn mii_nway_restart() the code attempts to call\nmii-\u003emdio_read which is ch9200_mdio_read(). ch9200_mdio_read()\nutilises a local buffer called \"buff\", which is initialised\nwith control_read(). However \"buff\" is conditionally\ninitialised inside control_read():\n\n        if (err == size) {\n                memcpy(data, buf, size);\n        }\n\nIf the condition of \"err == size\" is not met, then\n\"buff\" remains uninitialised. Once this happens the\nuninitialised \"buff\" is accessed and returned during\nch9200_mdio_read():\n\n        return (buff[0] | buff[1] \u003c\u003c 8);\n\nThe problem stems from the fact that ch9200_mdio_read()\nignores the return value of control_read(), leading to\nuinit-access of \"buff\".\n\nTo fix this we should check the return value of\ncontrol_read() and return early on error.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-38319",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/pp: Fix potential NULL pointer dereference in atomctrl_initialize_mc_reg_table\n\nThe function atomctrl_initialize_mc_reg_table() and\natomctrl_initialize_mc_reg_table_v2_2() does not check the return\nvalue of smu_atom_get_data_table(). If smu_atom_get_data_table()\nfails to retrieve vram_info, it returns NULL which is later\ndereferenced.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39683",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Limit access to parser-\u003ebuffer when trace_get_user failed\n\nWhen the length of the string written to set_ftrace_filter exceeds\nFTRACE_BUFF_MAX, the following KASAN alarm will be triggered:\n\nBUG: KASAN: slab-out-of-bounds in strsep+0x18c/0x1b0\nRead of size 1 at addr ffff0000d00bd5ba by task ash/165\n\nCPU: 1 UID: 0 PID: 165 Comm: ash Not tainted 6.16.0-g6bcdbd62bd56-dirty\nHardware name: linux,dummy-virt (DT)\nCall trace:\n show_stack+0x34/0x50 (C)\n dump_stack_lvl+0xa0/0x158\n print_address_description.constprop.0+0x88/0x398\n print_report+0xb0/0x280\n kasan_report+0xa4/0xf0\n __asan_report_load1_noabort+0x20/0x30\n strsep+0x18c/0x1b0\n ftrace_process_regex.isra.0+0x100/0x2d8\n ftrace_regex_release+0x484/0x618\n __fput+0x364/0xa58\n ____fput+0x28/0x40\n task_work_run+0x154/0x278\n do_notify_resume+0x1f0/0x220\n el0_svc+0xec/0xf0\n el0t_64_sync_handler+0xa0/0xe8\n el0t_64_sync+0x1ac/0x1b0\n\nThe reason is that trace_get_user will fail when processing a string\nlonger than FTRACE_BUFF_MAX, but not set the end of parser-\u003ebuffer to 0.\nThen an OOB access will be triggered in ftrace_regex_release-\u003e\nftrace_process_regex-\u003estrsep-\u003estrpbrk. We can solve this problem by\nlimiting access to parser-\u003ebuffer when trace_get_user failed.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.4",
        "Vector": "AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39715",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Revise gateway LWS calls to probe user read access\n\nWe use load and stbys,e instructions to trigger memory reference\ninterruptions without writing to memory. Because of the way read\naccess support is implemented, read access interruptions are only\ntriggered at privilege levels 2 and 3. The kernel and gateway\npage execute at privilege level 0, so this code never triggers\na read access interruption. Thus, it is currently possible for\nuser code to execute a LWS compare and swap operation at an\naddress that is read protected at privilege level 3 (PRIV_USER).\n\nFix this by probing read access rights at privilege level 3 and\nbranching to lws_fault if access isn't allowed.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39739",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/arm-smmu-qcom: Add SM6115 MDSS compatible\n\nAdd the SM6115 MDSS compatible to clients compatible list, as it also\nneeds that workaround.\nWithout this workaround, for example, QRB4210 RB2 which is based on\nSM4250/SM6115 generates a lot of smmu unhandled context faults during\nboot:\n\narm_smmu_context_fault: 116854 callbacks suppressed\narm-smmu c600000.iommu: Unhandled context fault: fsr=0x402,\niova=0x5c0ec600, fsynr=0x320021, cbfrsynra=0x420, cb=5\narm-smmu c600000.iommu: FSR    = 00000402 [Format=2 TF], SID=0x420\narm-smmu c600000.iommu: FSYNR0 = 00320021 [S1CBNDX=50 PNU PLVL=1]\narm-smmu c600000.iommu: Unhandled context fault: fsr=0x402,\niova=0x5c0d7800, fsynr=0x320021, cbfrsynra=0x420, cb=5\narm-smmu c600000.iommu: FSR    = 00000402 [Format=2 TF], SID=0x420\n\nand also failed initialisation of lontium lt9611uxc, gpu and dpu is\nobserved:\n(binding MDSS components triggered by lt9611uxc have failed)\n\n ------------[ cut here ]------------\n !aspace\n WARNING: CPU: 6 PID: 324 at drivers/gpu/drm/msm/msm_gem_vma.c:130 msm_gem_vma_init+0x150/0x18c [msm]\n Modules linked in: ... (long list of modules)\n CPU: 6 UID: 0 PID: 324 Comm: (udev-worker) Not tainted 6.15.0-03037-gaacc73ceeb8b #4 PREEMPT\n Hardware name: Qualcomm Technologies, Inc. QRB4210 RB2 (DT)\n pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : msm_gem_vma_init+0x150/0x18c [msm]\n lr : msm_gem_vma_init+0x150/0x18c [msm]\n sp : ffff80008144b280\n  \t\t...\n Call trace:\n  msm_gem_vma_init+0x150/0x18c [msm] (P)\n  get_vma_locked+0xc0/0x194 [msm]\n  msm_gem_get_and_pin_iova_range+0x4c/0xdc [msm]\n  msm_gem_kernel_new+0x48/0x160 [msm]\n  msm_gpu_init+0x34c/0x53c [msm]\n  adreno_gpu_init+0x1b0/0x2d8 [msm]\n  a6xx_gpu_init+0x1e8/0x9e0 [msm]\n  adreno_bind+0x2b8/0x348 [msm]\n  component_bind_all+0x100/0x230\n  msm_drm_bind+0x13c/0x3d0 [msm]\n  try_to_bring_up_aggregate_device+0x164/0x1d0\n  __component_add+0xa4/0x174\n  component_add+0x14/0x20\n  dsi_dev_attach+0x20/0x34 [msm]\n  dsi_host_attach+0x58/0x98 [msm]\n  devm_mipi_dsi_attach+0x34/0x90\n  lt9611uxc_attach_dsi.isra.0+0x94/0x124 [lontium_lt9611uxc]\n  lt9611uxc_probe+0x540/0x5fc [lontium_lt9611uxc]\n  i2c_device_probe+0x148/0x2a8\n  really_probe+0xbc/0x2c0\n  __driver_probe_device+0x78/0x120\n  driver_probe_device+0x3c/0x154\n  __driver_attach+0x90/0x1a0\n  bus_for_each_dev+0x68/0xb8\n  driver_attach+0x24/0x30\n  bus_add_driver+0xe4/0x208\n  driver_register+0x68/0x124\n  i2c_register_driver+0x48/0xcc\n  lt9611uxc_driver_init+0x20/0x1000 [lontium_lt9611uxc]\n  do_one_initcall+0x60/0x1d4\n  do_init_module+0x54/0x1fc\n  load_module+0x1748/0x1c8c\n  init_module_from_file+0x74/0xa0\n  __arm64_sys_finit_module+0x130/0x2f8\n  invoke_syscall+0x48/0x104\n  el0_svc_common.constprop.0+0xc0/0xe0\n  do_el0_svc+0x1c/0x28\n  el0_svc+0x2c/0x80\n  el0t_64_sync_handler+0x10c/0x138\n  el0t_64_sync+0x198/0x19c\n ---[ end trace 0000000000000000 ]---\n msm_dpu 5e01000.display-controller: [drm:msm_gpu_init [msm]] *ERROR* could not allocate memptrs: -22\n msm_dpu 5e01000.display-controller: failed to load adreno gpu\n platform a400000.remoteproc:glink-edge:apr:service@7:dais: Adding to iommu group 19\n msm_dpu 5e01000.display-controller: failed to bind 5900000.gpu (ops a3xx_ops [msm]): -22\n msm_dpu 5e01000.display-controller: adev bind failed: -22\n lt9611uxc 0-002b: failed to attach dsi to host\n lt9611uxc 0-002b: probe with driver lt9611uxc failed with error -22",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39752",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nARM: rockchip: fix kernel hang during smp initialization\n\nIn order to bring up secondary CPUs main CPU write trampoline\ncode to SRAM. The trampoline code is written while secondary\nCPUs are powered on (at least that true for RK3188 CPU).\nSometimes that leads to kernel hang. Probably because secondary\nCPU execute trampoline code while kernel doesn't expect.\n\nThe patch moves SRAM initialization step to the point where all\nsecondary CPUs are powered down.\n\nThat fixes rarely hangs on RK3188:\n[    0.091568] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000\n[    0.091996] rockchip_smp_prepare_cpus: ncores 4",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39760",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: core: config: Prevent OOB read in SS endpoint companion parsing\n\nusb_parse_ss_endpoint_companion() checks descriptor type before length,\nenabling a potentially odd read outside of the buffer size.\n\nFix this up by checking the size first before looking at any of the\nfields in the descriptor.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39819",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/smb: Fix inconsistent refcnt update\n\nA possible inconsistent update of refcount was identified in `smb2_compound_op`.\nSuch inconsistent update could lead to possible resource leaks.\n\nWhy it is a possible bug:\n1. In the comment section of the function, it clearly states that the\nreference to `cfile` should be dropped after calling this function.\n2. Every control flow path would check and drop the reference to\n`cfile`, except the patched one.\n3. Existing callers would not handle refcount update of `cfile` if\n-ENOMEM is returned.\n\nTo fix the bug, an extra goto label \"out\" is added, to make sure that the\ncleanup logic would always be respected. As the problem is caused by the\nallocation failure of `vars`, the cleanup logic between label \"finished\"\nand \"out\" can be safely ignored. According to the definition of function\n`is_replayable_error`, the error code of \"-ENOMEM\" is not recoverable.\nTherefore, the replay logic also gets ignored.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39824",
      "Note": "A use-after-free vulnerability exists in the ASUS HID driver of the Linux kernel. After hid_hw_start() is called, hidinput_connect() configures the device with the input layer. When processing input and output reports, if the capability bitmaps are not properly set, the hidinput_has_been_populated() check fails, leading to the freeing of hid_input and the underlying input device. A malicious HID device (such as an ASUS ROG N-Key keyboard) can trigger this scenario via a specially crafted descriptor, resulting in use-after-free when writing to the name of the freed input device after hid_hw_start().",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39844",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: move page table sync declarations to linux/pgtable.h\n\nDuring our internal testing, we started observing intermittent boot\nfailures when the machine uses 4-level paging and has a large amount of\npersistent memory:\n\n  BUG: unable to handle page fault for address: ffffe70000000034\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0002) - not-present page\n  PGD 0 P4D 0 \n  Oops: 0002 [#1] SMP NOPTI\n  RIP: 0010:__init_single_page+0x9/0x6d\n  Call Trace:\n   \u003cTASK\u003e\n   __init_zone_device_page+0x17/0x5d\n   memmap_init_zone_device+0x154/0x1bb\n   pagemap_range+0x2e0/0x40f\n   memremap_pages+0x10b/0x2f0\n   devm_memremap_pages+0x1e/0x60\n   dev_dax_probe+0xce/0x2ec [device_dax]\n   dax_bus_probe+0x6d/0xc9\n   [... snip ...]\n   \u003c/TASK\u003e\n\nIt turns out that the kernel panics while initializing vmemmap (struct\npage array) when the vmemmap region spans two PGD entries, because the new\nPGD entry is only installed in init_mm.pgd, but not in the page tables of\nother tasks.\n\nAnd looking at __populate_section_memmap():\n  if (vmemmap_can_optimize(altmap, pgmap))                                \n          // does not sync top level page tables\n          r = vmemmap_populate_compound_pages(pfn, start, end, nid, pgmap);\n  else                                                                    \n          // sync top level page tables in x86\n          r = vmemmap_populate(start, end, nid, altmap);\n\nIn the normal path, vmemmap_populate() in arch/x86/mm/init_64.c\nsynchronizes the top level page table (See commit 9b861528a801 (\"x86-64,\nmem: Update all PGDs for direct mapping and vmemmap mapping changes\")) so\nthat all tasks in the system can see the new vmemmap area.\n\nHowever, when vmemmap_can_optimize() returns true, the optimized path\nskips synchronization of top-level page tables.  This is because\nvmemmap_populate_compound_pages() is implemented in core MM code, which\ndoes not handle synchronization of the top-level page tables.  Instead,\nthe core MM has historically relied on each architecture to perform this\nsynchronization manually.\n\nWe're not the first party to encounter a crash caused by not-sync'd top\nlevel page tables: earlier this year, Gwan-gyeong Mun attempted to address\nthe issue [1] [2] after hitting a kernel panic when x86 code accessed the\nvmemmap area before the corresponding top-level entries were synced.  At\nthat time, the issue was believed to be triggered only when struct page\nwas enlarged for debugging purposes, and the patch did not get further\nupdates.\n\nIt turns out that current approach of relying on each arch to handle the\npage table sync manually is fragile because 1) it's easy to forget to sync\nthe top level page table, and 2) it's also easy to overlook that the\nkernel should not access the vmemmap and direct mapping areas before the\nsync.\n\n# The solution: Make page table sync more code robust and harder to miss\n\nTo address this, Dave Hansen suggested [3] [4] introducing\n{pgd,p4d}_populate_kernel() for updating kernel portion of the page tables\nand allow each architecture to explicitly perform synchronization when\ninstalling top-level entries.  With this approach, we no longer need to\nworry about missing the sync step, reducing the risk of future\nregressions.\n\nThe new interface reuses existing ARCH_PAGE_TABLE_SYNC_MASK,\nPGTBL_P*D_MODIFIED and arch_sync_kernel_mappings() facility used by\nvmalloc and ioremap to synchronize page tables.\n\npgd_populate_kernel() looks like this:\nstatic inline void pgd_populate_kernel(unsigned long addr, pgd_t *pgd,\n                                       p4d_t *p4d)\n{\n        pgd_populate(\u0026init_mm, pgd, p4d);\n        if (ARCH_PAGE_TABLE_SYNC_MASK \u0026 PGTBL_PGD_MODIFIED)\n                arch_sync_kernel_mappings(addr, addr);\n}\n\nIt is worth noting that vmalloc() and apply_to_range() carefully\nsynchronizes page tables by calling p*d_alloc_track() and\narch_sync_kernel_mappings(), and thus they are not affected by\n---truncated---",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39845",
      "Note": "In the Linux kernel, a vulnerability was found in the x86/mm/64 architecture regarding page table synchronization. The issue defines ARCH_PAGE_TABLE_SYNC_MASK and arch_sync_kernel_mappings() to ensure proper page table synchronization when calling p*d_populate_kernel(). For 5-level paging, synchronization is performed via pgd_populate_kernel(). In 4-level paging, pgd_populate() is a no-op, so synchronization is instead performed at the P4D level via p4d_populate_kernel(). This fixes intermittent boot failures on systems using 4-level paging and a large amount of persistent memory, as well as crashes in vmemmap_set_pmd() caused by accessing vmemmap before sync_global_pgds().",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39850",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nvxlan: Fix NPD in {arp,neigh}_reduce() when using nexthop objects\n\nWhen the \"proxy\" option is enabled on a VXLAN device, the device will\nsuppress ARP requests and IPv6 Neighbor Solicitation messages if it is\nable to reply on behalf of the remote host. That is, if a matching and\nvalid neighbor entry is configured on the VXLAN device whose MAC address\nis not behind the \"any\" remote (0.0.0.0 / ::).\n\nThe code currently assumes that the FDB entry for the neighbor's MAC\naddress points to a valid remote destination, but this is incorrect if\nthe entry is associated with an FDB nexthop group. This can result in a\nNPD [1][3] which can be reproduced using [2][4].\n\nFix by checking that the remote destination exists before dereferencing\nit.\n\n[1]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nCPU: 4 UID: 0 PID: 365 Comm: arping Not tainted 6.17.0-rc2-virtme-g2a89cb21162c #2 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014\nRIP: 0010:vxlan_xmit+0xb58/0x15f0\n[...]\nCall Trace:\n \u003cTASK\u003e\n dev_hard_start_xmit+0x5d/0x1c0\n __dev_queue_xmit+0x246/0xfd0\n packet_sendmsg+0x113a/0x1850\n __sock_sendmsg+0x38/0x70\n __sys_sendto+0x126/0x180\n __x64_sys_sendto+0x24/0x30\n do_syscall_64+0xa4/0x260\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\n[2]\n #!/bin/bash\n\n ip address add 192.0.2.1/32 dev lo\n\n ip nexthop add id 1 via 192.0.2.2 fdb\n ip nexthop add id 10 group 1 fdb\n\n ip link add name vx0 up type vxlan id 10010 local 192.0.2.1 dstport 4789 proxy\n\n ip neigh add 192.0.2.3 lladdr 00:11:22:33:44:55 nud perm dev vx0\n\n bridge fdb add 00:11:22:33:44:55 dev vx0 self static nhid 10\n\n arping -b -c 1 -s 192.0.2.1 -I vx0 192.0.2.3\n\n[3]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nCPU: 13 UID: 0 PID: 372 Comm: ndisc6 Not tainted 6.17.0-rc2-virtmne-g6ee90cb26014 #3 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1v996), BIOS 1.17.0-4.fc41 04/01/2x014\nRIP: 0010:vxlan_xmit+0x803/0x1600\n[...]\nCall Trace:\n \u003cTASK\u003e\n dev_hard_start_xmit+0x5d/0x1c0\n __dev_queue_xmit+0x246/0xfd0\n ip6_finish_output2+0x210/0x6c0\n ip6_finish_output+0x1af/0x2b0\n ip6_mr_output+0x92/0x3e0\n ip6_send_skb+0x30/0x90\n rawv6_sendmsg+0xe6e/0x12e0\n __sock_sendmsg+0x38/0x70\n __sys_sendto+0x126/0x180\n __x64_sys_sendto+0x24/0x30\n do_syscall_64+0xa4/0x260\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\nRIP: 0033:0x7f383422ec77\n\n[4]\n #!/bin/bash\n\n ip address add 2001:db8:1::1/128 dev lo\n\n ip nexthop add id 1 via 2001:db8:1::1 fdb\n ip nexthop add id 10 group 1 fdb\n\n ip link add name vx0 up type vxlan id 10010 local 2001:db8:1::1 dstport 4789 proxy\n\n ip neigh add 2001:db8:1::3 lladdr 00:11:22:33:44:55 nud perm dev vx0\n\n bridge fdb add 00:11:22:33:44:55 dev vx0 self static nhid 10\n\n ndisc6 -r 1 -s 2001:db8:1::1 -w 1 2001:db8:1::3 vx0",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39851",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nvxlan: Fix NPD when refreshing an FDB entry with a nexthop object\n\nVXLAN FDB entries can point to either a remote destination or an FDB\nnexthop group. The latter is usually used in EVPN deployments where\nlearning is disabled.\n\nHowever, when learning is enabled, an incoming packet might try to\nrefresh an FDB entry that points to an FDB nexthop group and therefore\ndoes not have a remote. Such packets should be dropped, but they are\nonly dropped after dereferencing the non-existent remote, resulting in a\nNPD [1] which can be reproduced using [2].\n\nFix by dropping such packets earlier. Remove the misleading comment from\nfirst_remote_rcu().\n\n[1]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nCPU: 13 UID: 0 PID: 361 Comm: mausezahn Not tainted 6.17.0-rc1-virtme-g9f6b606b6b37 #1 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014\nRIP: 0010:vxlan_snoop+0x98/0x1e0\n[...]\nCall Trace:\n \u003cTASK\u003e\n vxlan_encap_bypass+0x209/0x240\n encap_bypass_if_local+0xb1/0x100\n vxlan_xmit_one+0x1375/0x17e0\n vxlan_xmit+0x6b4/0x15f0\n dev_hard_start_xmit+0x5d/0x1c0\n __dev_queue_xmit+0x246/0xfd0\n packet_sendmsg+0x113a/0x1850\n __sock_sendmsg+0x38/0x70\n __sys_sendto+0x126/0x180\n __x64_sys_sendto+0x24/0x30\n do_syscall_64+0xa4/0x260\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\n[2]\n #!/bin/bash\n\n ip address add 192.0.2.1/32 dev lo\n ip address add 192.0.2.2/32 dev lo\n\n ip nexthop add id 1 via 192.0.2.3 fdb\n ip nexthop add id 10 group 1 fdb\n\n ip link add name vx0 up type vxlan id 10010 local 192.0.2.1 dstport 12345 localbypass\n ip link add name vx1 up type vxlan id 10020 local 192.0.2.2 dstport 54321 learning\n\n bridge fdb add 00:11:22:33:44:55 dev vx0 self static dst 192.0.2.2 port 54321 vni 10020\n bridge fdb add 00:aa:bb:cc:dd:ee dev vx1 self static nhid 10\n\n mausezahn vx0 -a 00:aa:bb:cc:dd:ee -b 00:11:22:33:44:55 -c 1 -q",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.7",
        "Vector": "AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39853",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: Fix potential invalid access when MAC list is empty\n\nlist_first_entry() never returns NULL - if the list is empty, it still\nreturns a pointer to an invalid object, leading to potential invalid\nmemory access when dereferenced.\n\nFix this by using list_first_entry_or_null instead of list_first_entry.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39865",
      "Note": "A NULL pointer dereference vulnerability was discovered in the TEE subsystem of the Linux kernel. The tee_shm_put function has a NULL pointer dereference issue: in the __optee_disable_shm_cache function, reg_pair_to_ptr may return a NULL pointer, but when tee_shm_free calls tee_shm_put, no NULL pointer check is performed, causing system crashes. This vulnerability affects multiple Linux kernel versions and can lead to denial of service.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39883",
      "Note": "A vulnerability was found in Linux Kernel up to 6.1.152/6.6.106/6.12.47/6.16.7/6.17-rc5. The issue exists in the unpoison_memory function of the mm/memory-failure module, where it tries to check the PG_HWPoison flags of an uninitialized page, triggering VM_BUG_ON_PAGE(PagePoisoned(page)) and causing kernel panic. An attacker can trigger this vulnerability by offlining a memory block and writing an uninitialized page frame number to unpoison-pfn, leading to system crash and impacting confidentiality, integrity, and availability.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39886",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Tell memcg to use allow_spinning=false path in bpf_timer_init()\n\nCurrently, calling bpf_map_kmalloc_node() from __bpf_async_init() can\ncause various locking issues; see the following stack trace (edited for\nstyle) as one example:\n\n...\n [10.011566]  do_raw_spin_lock.cold\n [10.011570]  try_to_wake_up             (5) double-acquiring the same\n [10.011575]  kick_pool                      rq_lock, causing a hardlockup\n [10.011579]  __queue_work\n [10.011582]  queue_work_on\n [10.011585]  kernfs_notify\n [10.011589]  cgroup_file_notify\n [10.011593]  try_charge_memcg           (4) memcg accounting raises an\n [10.011597]  obj_cgroup_charge_pages        MEMCG_MAX event\n [10.011599]  obj_cgroup_charge_account\n [10.011600]  __memcg_slab_post_alloc_hook\n [10.011603]  __kmalloc_node_noprof\n...\n [10.011611]  bpf_map_kmalloc_node\n [10.011612]  __bpf_async_init\n [10.011615]  bpf_timer_init             (3) BPF calls bpf_timer_init()\n [10.011617]  bpf_prog_xxxxxxxxxxxxxxxx_fcg_runnable\n [10.011619]  bpf__sched_ext_ops_runnable\n [10.011620]  enqueue_task_scx           (2) BPF runs with rq_lock held\n [10.011622]  enqueue_task\n [10.011626]  ttwu_do_activate\n [10.011629]  sched_ttwu_pending         (1) grabs rq_lock\n...\n\nThe above was reproduced on bpf-next (b338cf849ec8) by modifying\n./tools/sched_ext/scx_flatcg.bpf.c to call bpf_timer_init() during\nops.runnable(), and hacking the memcg accounting code a bit to make\na bpf_timer_init() call more likely to raise an MEMCG_MAX event.\n\nWe have also run into other similar variants (both internally and on\nbpf-next), including double-acquiring cgroup_file_kn_lock, the same\nworker_pool::lock, etc.\n\nAs suggested by Shakeel, fix this by using __GFP_HIGH instead of\nGFP_ATOMIC in __bpf_async_init(), so that e.g. if try_charge_memcg()\nraises an MEMCG_MAX event, we call __memcg_memory_event() with\n@allow_spinning=false and avoid calling cgroup_file_notify() there.\n\nDepends on mm patch\n\"memcg: skip cgroup_file_notify if spinning is not allowed\":\nhttps://lore.kernel.org/bpf/",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39895",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched: Fix sched_numa_find_nth_cpu() if mask offline\n\nsched_numa_find_nth_cpu() uses a bsearch to look for the 'closest'\nCPU in sched_domains_numa_masks and given cpus mask. However they\nmight not intersect if all CPUs in the cpus mask are offline. bsearch\nwill return NULL in that case, bail out instead of dereferencing a\nbogus pointer.\n\nThe previous behaviour lead to this bug when using maxcpus=4 on an\nrk3399 (LLLLbb) (i.e. booting with all big CPUs offline):\n\n[    1.422922] Unable to handle kernel paging request at virtual address ffffff8000000000\n[    1.423635] Mem abort info:\n[    1.423889]   ESR = 0x0000000096000006\n[    1.424227]   EC = 0x25: DABT (current EL), IL = 32 bits\n[    1.424715]   SET = 0, FnV = 0\n[    1.424995]   EA = 0, S1PTW = 0\n[    1.425279]   FSC = 0x06: level 2 translation fault\n[    1.425735] Data abort info:\n[    1.425998]   ISV = 0, ISS = 0x00000006, ISS2 = 0x00000000\n[    1.426499]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n[    1.426952]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n[    1.427428] swapper pgtable: 4k pages, 39-bit VAs, pgdp=0000000004a9f000\n[    1.428038] [ffffff8000000000] pgd=18000000f7fff403, p4d=18000000f7fff403, pud=18000000f7fff403, pmd=0000000000000000\n[    1.429014] Internal error: Oops: 0000000096000006 [#1]  SMP\n[    1.429525] Modules linked in:\n[    1.429813] CPU: 3 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.17.0-rc4-dirty #343 PREEMPT\n[    1.430559] Hardware name: Pine64 RockPro64 v2.1 (DT)\n[    1.431012] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    1.431634] pc : sched_numa_find_nth_cpu+0x2a0/0x488\n[    1.432094] lr : sched_numa_find_nth_cpu+0x284/0x488\n[    1.432543] sp : ffffffc084e1b960\n[    1.432843] x29: ffffffc084e1b960 x28: ffffff80078a8800 x27: ffffffc0846eb1d0\n[    1.433495] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000\n[    1.434144] x23: 0000000000000000 x22: fffffffffff7f093 x21: ffffffc081de6378\n[    1.434792] x20: 0000000000000000 x19: 0000000ffff7f093 x18: 00000000ffffffff\n[    1.435441] x17: 3030303866666666 x16: 66663d736b73616d x15: ffffffc104e1b5b7\n[    1.436091] x14: 0000000000000000 x13: ffffffc084712860 x12: 0000000000000372\n[    1.436739] x11: 0000000000000126 x10: ffffffc08476a860 x9 : ffffffc084712860\n[    1.437389] x8 : 00000000ffffefff x7 : ffffffc08476a860 x6 : 0000000000000000\n[    1.438036] x5 : 000000000000bff4 x4 : 0000000000000000 x3 : 0000000000000000\n[    1.438683] x2 : 0000000000000000 x1 : ffffffc0846eb000 x0 : ffffff8000407b68\n[    1.439332] Call trace:\n[    1.439559]  sched_numa_find_nth_cpu+0x2a0/0x488 (P)\n[    1.440016]  smp_call_function_any+0xc8/0xd0\n[    1.440416]  armv8_pmu_init+0x58/0x27c\n[    1.440770]  armv8_cortex_a72_pmu_init+0x20/0x2c\n[    1.441199]  arm_pmu_device_probe+0x1e4/0x5e8\n[    1.441603]  armv8_pmu_device_probe+0x1c/0x28\n[    1.442007]  platform_probe+0x5c/0xac\n[    1.442347]  really_probe+0xbc/0x298\n[    1.442683]  __driver_probe_device+0x78/0x12c\n[    1.443087]  driver_probe_device+0xdc/0x160\n[    1.443475]  __driver_attach+0x94/0x19c\n[    1.443833]  bus_for_each_dev+0x74/0xd4\n[    1.444190]  driver_attach+0x24/0x30\n[    1.444525]  bus_add_driver+0xe4/0x208\n[    1.444874]  driver_register+0x60/0x128\n[    1.445233]  __platform_driver_register+0x24/0x30\n[    1.445662]  armv8_pmu_driver_init+0x28/0x4c\n[    1.446059]  do_one_initcall+0x44/0x25c\n[    1.446416]  kernel_init_freeable+0x1dc/0x3bc\n[    1.446820]  kernel_init+0x20/0x1d8\n[    1.447151]  ret_from_fork+0x10/0x20\n[    1.447493] Code: 90022e21 f000e5f5 910de2b5 2a1703e2 (f8767803)\n[    1.448040] ---[ end trace 0000000000000000 ]---\n[    1.448483] note: swapper/0[1] exited with preempt_count 1\n[    1.449047] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n[    1.449741] SMP: stopping secondary CPUs\n[    1.450105] Kernel Offset: disabled\n[    1.450419] CPU features: 0x000000,00080000,20002001,0400421b\n[    \n---truncated---",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39914",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Silence warning when chunk allocation fails in trace_pid_write\n\nSyzkaller trigger a fault injection warning:\n\nWARNING: CPU: 1 PID: 12326 at tracepoint_add_func+0xbfc/0xeb0\nModules linked in:\nCPU: 1 UID: 0 PID: 12326 Comm: syz.6.10325 Tainted: G U 6.14.0-rc5-syzkaller #0\nTainted: [U]=USER\nHardware name: Google Compute Engine/Google Compute Engine\nRIP: 0010:tracepoint_add_func+0xbfc/0xeb0 kernel/tracepoint.c:294\nCode: 09 fe ff 90 0f 0b 90 0f b6 74 24 43 31 ff 41 bc ea ff ff ff\nRSP: 0018:ffffc9000414fb48 EFLAGS: 00010283\nRAX: 00000000000012a1 RBX: ffffffff8e240ae0 RCX: ffffc90014b78000\nRDX: 0000000000080000 RSI: ffffffff81bbd78b RDI: 0000000000000001\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffffffffffffffef\nR13: 0000000000000000 R14: dffffc0000000000 R15: ffffffff81c264f0\nFS:  00007f27217f66c0(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000001b2e80dff8 CR3: 00000000268f8000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n \u003cTASK\u003e\n tracepoint_probe_register_prio+0xc0/0x110 kernel/tracepoint.c:464\n register_trace_prio_sched_switch include/trace/events/sched.h:222 [inline]\n register_pid_events kernel/trace/trace_events.c:2354 [inline]\n event_pid_write.isra.0+0x439/0x7a0 kernel/trace/trace_events.c:2425\n vfs_write+0x24c/0x1150 fs/read_write.c:677\n ksys_write+0x12b/0x250 fs/read_write.c:731\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nWe can reproduce the warning by following the steps below:\n1. echo 8 \u003e\u003e set_event_notrace_pid. Let tr-\u003efiltered_pids owns one pid\n   and register sched_switch tracepoint.\n2. echo ' ' \u003e\u003e set_event_pid, and perform fault injection during chunk\n   allocation of trace_pid_list_alloc. Let pid_list with no pid and\nassign to tr-\u003efiltered_pids.\n3. echo ' ' \u003e\u003e set_event_pid. Let pid_list is NULL and assign to\n   tr-\u003efiltered_pids.\n4. echo 9 \u003e\u003e set_event_pid, will trigger the double register\n   sched_switch tracepoint warning.\n\nThe reason is that syzkaller injects a fault into the chunk allocation\nin trace_pid_list_alloc, causing a failure in trace_pid_list_set, which\nmay trigger double register of the same tracepoint. This only occurs\nwhen the system is about to crash, but to suppress this warning, let's\nadd failure handling logic to trace_pid_list_set.",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    },
    {
      "CVE": "CVE-2025-39953",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ncgroup: split cgroup_destroy_wq into 3 workqueues\n\nA hung task can occur during [1] LTP cgroup testing when repeatedly\nmounting/unmounting perf_event and net_prio controllers with\nsystemd.unified_cgroup_hierarchy=1. The hang manifests in\ncgroup_lock_and_drain_offline() during root destruction.\n\nRelated case:\ncgroup_fj_function_perf_event cgroup_fj_function.sh perf_event\ncgroup_fj_function_net_prio cgroup_fj_function.sh net_prio\n\nCall Trace:\n\tcgroup_lock_and_drain_offline+0x14c/0x1e8\n\tcgroup_destroy_root+0x3c/0x2c0\n\tcss_free_rwork_fn+0x248/0x338\n\tprocess_one_work+0x16c/0x3b8\n\tworker_thread+0x22c/0x3b0\n\tkthread+0xec/0x100\n\tret_from_fork+0x10/0x20\n\nRoot Cause:\n\nCPU0                            CPU1\nmount perf_event                umount net_prio\ncgroup1_get_tree                cgroup_kill_sb\nrebind_subsystems               // root destruction enqueues\n\t\t\t\t// cgroup_destroy_wq\n// kill all perf_event css\n                                // one perf_event css A is dying\n                                // css A offline enqueues cgroup_destroy_wq\n                                // root destruction will be executed first\n                                css_free_rwork_fn\n                                cgroup_destroy_root\n                                cgroup_lock_and_drain_offline\n                                // some perf descendants are dying\n                                // cgroup_destroy_wq max_active = 1\n                                // waiting for css A to die\n\nProblem scenario:\n1. CPU0 mounts perf_event (rebind_subsystems)\n2. CPU1 unmounts net_prio (cgroup_kill_sb), queuing root destruction work\n3. A dying perf_event CSS gets queued for offline after root destruction\n4. Root destruction waits for offline completion, but offline work is\n   blocked behind root destruction in cgroup_destroy_wq (max_active=1)\n\nSolution:\nSplit cgroup_destroy_wq into three dedicated workqueues:\ncgroup_offline_wq – Handles CSS offline operations\ncgroup_release_wq – Manages resource release\ncgroup_free_wq – Performs final memory deallocation\n\nThis separation eliminates blocking in the CSS free path while waiting for\noffline operations to complete.\n\n[1] https://github.com/linux-test-project/ltp/blob/master/runtest/controllers",
      "ReleaseDate": "2025-10-17",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS-SP1"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-10-17",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2466"
      }
    }
  ]
}