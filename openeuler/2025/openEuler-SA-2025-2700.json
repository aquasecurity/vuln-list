{
  "Title": "An update for kernel is now available for openEuler-24.03-LTS",
  "Type": "Security Advisory",
  "Publisher": {
    "ContactDetails": "openeuler-security@openeuler.org",
    "IssuingAuthority": "openEuler security committee"
  },
  "Tracking": {
    "ID": "openEuler-SA-2025-2700",
    "Status": "Final",
    "Version": "1.0",
    "InitialReleaseDate": "2025-11-22",
    "CurrentReleaseDate": "2025-11-22",
    "Generator": {
      "Engine": "openEuler SA Tool V1.0",
      "Date": "2025-11-22"
    },
    "RevisionHistory": [
      {
        "Number": "1.0",
        "Date": "2025-11-22",
        "Description": "Initial"
      }
    ]
  },
  "Notes": [
    {
      "Text": "kernel security update",
      "Title": "Synopsis",
      "Type": "General"
    },
    {
      "Text": "An update for kernel is now available for openEuler-24.03-LTS",
      "Title": "Summary",
      "Type": "General"
    },
    {
      "Text": "The Linux Kernel, the operating system core itself.\n\nSecurity Fix(es):\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nmisc: pci_endpoint_test: Avoid issue of interrupts remaining after request_irq error\n\nAfter devm_request_irq() fails with error in pci_endpoint_test_request_irq(),\nthe pci_endpoint_test_free_irq_vectors() is called assuming that all IRQs\nhave been released.\n\nHowever, some requested IRQs remain unreleased, so there are still\n/proc/irq/* entries remaining, and this results in WARN() with the\nfollowing message:\n\n  remove_proc_entry: removing non-empty directory 'irq/30', leaking at least 'pci-endpoint-test.0'\n  WARNING: CPU: 0 PID: 202 at fs/proc/generic.c:719 remove_proc_entry +0x190/0x19c\n\nTo solve this issue, set the number of remaining IRQs to test-\u003enum_irqs,\nand release IRQs in advance by calling pci_endpoint_test_release_irq().\n\n[kwilczynski: commit log](CVE-2025-23140)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: avoid NULL pointer dereference if no valid csum tree\n\n[BUG]\nWhen trying read-only scrub on a btrfs with rescue=idatacsums mount\noption, it will crash with the following call trace:\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000208\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  CPU: 1 UID: 0 PID: 835 Comm: btrfs Tainted: G           O        6.15.0-rc3-custom+ #236 PREEMPT(full)\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022\n  RIP: 0010:btrfs_lookup_csums_bitmap+0x49/0x480 [btrfs]\n  Call Trace:\n   \u003cTASK\u003e\n   scrub_find_fill_first_stripe+0x35b/0x3d0 [btrfs]\n   scrub_simple_mirror+0x175/0x290 [btrfs]\n   scrub_stripe+0x5f7/0x6f0 [btrfs]\n   scrub_chunk+0x9a/0x150 [btrfs]\n   scrub_enumerate_chunks+0x333/0x660 [btrfs]\n   btrfs_scrub_dev+0x23e/0x600 [btrfs]\n   btrfs_ioctl+0x1dcf/0x2f80 [btrfs]\n   __x64_sys_ioctl+0x97/0xc0\n   do_syscall_64+0x4f/0x120\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n[CAUSE]\nMount option \"rescue=idatacsums\" will completely skip loading the csum\ntree, so that any data read will not find any data csum thus we will\nignore data checksum verification.\n\nNormally call sites utilizing csum tree will check the fs state flag\nNO_DATA_CSUMS bit, but unfortunately scrub does not check that bit at all.\n\nThis results in scrub to call btrfs_search_slot() on a NULL pointer\nand triggered above crash.\n\n[FIX]\nCheck both extent and csum tree root before doing any tree search.(CVE-2025-38059)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ncoresight: holding cscfg_csdev_lock while removing cscfg from csdev\n\nThere'll be possible race scenario for coresight config:\n\nCPU0                                          CPU1\n(perf enable)                                 load module\n                                              cscfg_load_config_sets()\n                                              activate config. // sysfs\n                                              (sys_active_cnt == 1)\n...\ncscfg_csdev_enable_active_config()\n  lock(csdev-\u003ecscfg_csdev_lock)\n                                              deactivate config // sysfs\n                                              (sys_activec_cnt == 0)\n                                              cscfg_unload_config_sets()\n  \u003citerating config_csdev_list\u003e               cscfg_remove_owned_csdev_configs()\n  // here load config activate by CPU1\n  unlock(csdev-\u003ecscfg_csdev_lock)\n\niterating config_csdev_list could be raced with config_csdev_list's\nentry delete.\n\nTo resolve this race , hold csdev-\u003ecscfg_csdev_lock() while\ncscfg_remove_owned_csdev_configs()(CVE-2025-38132)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7915: Fix null-ptr-deref in mt7915_mmio_wed_init()\n\ndevm_ioremap() returns NULL on error. Currently, mt7915_mmio_wed_init()\ndoes not check for this case, which results in a NULL pointer\ndereference.\n\nPrevent null pointer dereference in mt7915_mmio_wed_init().(CVE-2025-38155)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nfs/ntfs3: handle hdr_first_de() return value\n\nThe hdr_first_de() function returns a pointer to a struct NTFS_DE. This\npointer may be NULL. To handle the NULL error effectively, it is important\nto implement an error handler. This will help manage potential errors\nconsistently.\n\nAdditionally, error handling for the return value already exists at other\npoints where this function is called.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.(CVE-2025-38167)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix double free in delayed_free\n\nThe double free could happen in the following path.\n\nexfat_create_upcase_table()\n        exfat_create_upcase_table() : return error\n        exfat_free_upcase_table() : free -\u003evol_utbl\n        exfat_load_default_upcase_table : return error\n     exfat_kill_sb()\n           delayed_free()\n                  exfat_free_upcase_table() \u003c--------- double free\nThis patch set -\u003evol_util as NULL after freeing it.(CVE-2025-38206)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\naoe: clean device rq_list in aoedev_downdev()\n\nAn aoe device's rq_list contains accepted block requests that are\nwaiting to be transmitted to the aoe target. This queue was added as\npart of the conversion to blk_mq. However, the queue was not cleaned out\nwhen an aoe device is downed which caused blk_mq_freeze_queue() to sleep\nindefinitely waiting for those requests to complete, causing a hang. This\nfix cleans out the queue before calling blk_mq_freeze_queue().(CVE-2025-38326)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nwifi: p54: prevent buffer-overflow in p54_rx_eeprom_readback()\n\nRobert Morris reported:\n\n|If a malicious USB device pretends to be an Intersil p54 wifi\n|interface and generates an eeprom_readback message with a large\n|eeprom-\u003ev1.len, p54_rx_eeprom_readback() will copy data from the\n|message beyond the end of priv-\u003eeeprom.\n|\n|static void p54_rx_eeprom_readback(struct p54_common *priv,\n|                                   struct sk_buff *skb)\n|{\n|        struct p54_hdr *hdr = (struct p54_hdr *) skb-\u003edata;\n|        struct p54_eeprom_lm86 *eeprom = (struct p54_eeprom_lm86 *) hdr-\u003edata;\n|\n|        if (priv-\u003efw_var \u003e= 0x509) {\n|                memcpy(priv-\u003eeeprom, eeprom-\u003ev2.data,\n|                       le16_to_cpu(eeprom-\u003ev2.len));\n|        } else {\n|                memcpy(priv-\u003eeeprom, eeprom-\u003ev1.data,\n|                       le16_to_cpu(eeprom-\u003ev1.len));\n|        }\n| [...]\n\nThe eeprom-\u003ev{1,2}.len is set by the driver in p54_download_eeprom().\nThe device is supposed to provide the same length back to the driver.\nBut yes, it's possible (like shown in the report) to alter the value\nto something that causes a crash/panic due to overrun.\n\nThis patch addresses the issue by adding the size to the common device\ncontext, so p54_rx_eeprom_readback no longer relies on possibly tampered\nvalues... That said, it also checks if the \"firmware\" altered the value\nand no longer copies them.\n\nThe one, small saving grace is: Before the driver tries to read the eeprom,\nit needs to upload \u003ea\u003c firmware. the vendor firmware has a proprietary\nlicense and as a reason, it is not present on most distributions by\ndefault.(CVE-2025-38348)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Disable migration in nf_hook_run_bpf().\n\nsyzbot reported that the netfilter bpf prog can be called without\nmigration disabled in xmit path.\n\nThen the assertion in __bpf_prog_run() fails, triggering the splat\nbelow. [0]\n\nLet's use bpf_prog_run_pin_on_cpu() in nf_hook_run_bpf().\n\n[0]:\nBUG: assuming non migratable context at ./include/linux/filter.h:703\nin_atomic(): 0, irqs_disabled(): 0, migration_disabled() 0 pid: 5829, name: sshd-session\n3 locks held by sshd-session/5829:\n #0: ffff88807b4e4218 (sk_lock-AF_INET){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1667 [inline]\n #0: ffff88807b4e4218 (sk_lock-AF_INET){+.+.}-{0:0}, at: tcp_sendmsg+0x20/0x50 net/ipv4/tcp.c:1395\n #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline]\n #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:841 [inline]\n #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: __ip_queue_xmit+0x69/0x26c0 net/ipv4/ip_output.c:470\n #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline]\n #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:841 [inline]\n #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: nf_hook+0xb2/0x680 include/linux/netfilter.h:241\nCPU: 0 UID: 0 PID: 5829 Comm: sshd-session Not tainted 6.16.0-rc6-syzkaller-00002-g155a3c003e55 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120\n __cant_migrate kernel/sched/core.c:8860 [inline]\n __cant_migrate+0x1c7/0x250 kernel/sched/core.c:8834\n __bpf_prog_run include/linux/filter.h:703 [inline]\n bpf_prog_run include/linux/filter.h:725 [inline]\n nf_hook_run_bpf+0x83/0x1e0 net/netfilter/nf_bpf_link.c:20\n nf_hook_entry_hookfn include/linux/netfilter.h:157 [inline]\n nf_hook_slow+0xbb/0x200 net/netfilter/core.c:623\n nf_hook+0x370/0x680 include/linux/netfilter.h:272\n NF_HOOK_COND include/linux/netfilter.h:305 [inline]\n ip_output+0x1bc/0x2a0 net/ipv4/ip_output.c:433\n dst_output include/net/dst.h:459 [inline]\n ip_local_out net/ipv4/ip_output.c:129 [inline]\n __ip_queue_xmit+0x1d7d/0x26c0 net/ipv4/ip_output.c:527\n __tcp_transmit_skb+0x2686/0x3e90 net/ipv4/tcp_output.c:1479\n tcp_transmit_skb net/ipv4/tcp_output.c:1497 [inline]\n tcp_write_xmit+0x1274/0x84e0 net/ipv4/tcp_output.c:2838\n __tcp_push_pending_frames+0xaf/0x390 net/ipv4/tcp_output.c:3021\n tcp_push+0x225/0x700 net/ipv4/tcp.c:759\n tcp_sendmsg_locked+0x1870/0x42b0 net/ipv4/tcp.c:1359\n tcp_sendmsg+0x2e/0x50 net/ipv4/tcp.c:1396\n inet_sendmsg+0xb9/0x140 net/ipv4/af_inet.c:851\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n sock_write_iter+0x4aa/0x5b0 net/socket.c:1131\n new_sync_write fs/read_write.c:593 [inline]\n vfs_write+0x6c7/0x1150 fs/read_write.c:686\n ksys_write+0x1f8/0x250 fs/read_write.c:738\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fe7d365d407\nCode: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 \u003c5b\u003e c3 0f 1f 80 00 00 00 00 83 e2 39 83 fa 08 75 de e8 23 ff ff ff\nRSP:(CVE-2025-38640)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nMIPS: Don't crash in stack_top() for tasks without ABI or vDSO\n\nNot all tasks have an ABI associated or vDSO mapped,\nfor example kthreads never do.\nIf such a task ever ends up calling stack_top(), it will derefence the\nNULL ABI pointer and crash.\n\nThis can for example happen when using kunit:\n\n    mips_stack_top+0x28/0xc0\n    arch_pick_mmap_layout+0x190/0x220\n    kunit_vm_mmap_init+0xf8/0x138\n    __kunit_add_resource+0x40/0xa8\n    kunit_vm_mmap+0x88/0xd8\n    usercopy_test_init+0xb8/0x240\n    kunit_try_run_case+0x5c/0x1a8\n    kunit_generic_run_threadfn_adapter+0x28/0x50\n    kthread+0x118/0x240\n    ret_from_kernel_thread+0x14/0x1c\n\nOnly dereference the ABI point if it is set.\n\nThe GIC page is also included as it is specific to the vDSO.\nAlso move the randomization adjustment into the same conditional.(CVE-2025-38696)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nsctp: linearize cloned gso packets in sctp_rcv\n\nA cloned head skb still shares these frag skbs in fraglist with the\noriginal head skb. It's not safe to access these frag skbs.\n\nsyzbot reported two use-of-uninitialized-memory bugs caused by this:\n\n  BUG: KMSAN: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998\n   sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331\n   sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122\n   __release_sock+0x1da/0x330 net/core/sock.c:3106\n   release_sock+0x6b/0x250 net/core/sock.c:3660\n   sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360\n   sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885\n   sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031\n   inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:718 [inline]\n\nand\n\n  BUG: KMSAN: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331\n   sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148\n   __release_sock+0x1d3/0x330 net/core/sock.c:3213\n   release_sock+0x6b/0x270 net/core/sock.c:3767\n   sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367\n   sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886\n   sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032\n   inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:712 [inline]\n\nThis patch fixes it by linearizing cloned gso packets in sctp_rcv().(CVE-2025-38718)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix UAF on smcsk after smc_listen_out()\n\nBPF CI testing report a UAF issue:\n\n  [   16.446633] BUG: kernel NULL pointer dereference, address: 000000000000003  0\n  [   16.447134] #PF: supervisor read access in kernel mod  e\n  [   16.447516] #PF: error_code(0x0000) - not-present pag  e\n  [   16.447878] PGD 0 P4D   0\n  [   16.448063] Oops: Oops: 0000 [#1] PREEMPT SMP NOPT  I\n  [   16.448409] CPU: 0 UID: 0 PID: 9 Comm: kworker/0:1 Tainted: G           OE      6.13.0-rc3-g89e8a75fda73-dirty #4  2\n  [   16.449124] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODUL  E\n  [   16.449502] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/201  4\n  [   16.450201] Workqueue: smc_hs_wq smc_listen_wor  k\n  [   16.450531] RIP: 0010:smc_listen_work+0xc02/0x159  0\n  [   16.452158] RSP: 0018:ffffb5ab40053d98 EFLAGS: 0001024  6\n  [   16.452526] RAX: 0000000000000001 RBX: 0000000000000002 RCX: 000000000000030  0\n  [   16.452994] RDX: 0000000000000280 RSI: 00003513840053f0 RDI: 000000000000000  0\n  [   16.453492] RBP: ffffa097808e3800 R08: ffffa09782dba1e0 R09: 000000000000000  5\n  [   16.453987] R10: 0000000000000000 R11: 0000000000000000 R12: ffffa0978274640  0\n  [   16.454497] R13: 0000000000000000 R14: 0000000000000000 R15: ffffa09782d4092  0\n  [   16.454996] FS:  0000000000000000(0000) GS:ffffa097bbc00000(0000) knlGS:000000000000000  0\n  [   16.455557] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003  3\n  [   16.455961] CR2: 0000000000000030 CR3: 0000000102788004 CR4: 0000000000770ef  0\n  [   16.456459] PKRU: 5555555  4\n  [   16.456654] Call Trace  :\n  [   16.456832]  \u003cTASK  \u003e\n  [   16.456989]  ? __die+0x23/0x7  0\n  [   16.457215]  ? page_fault_oops+0x180/0x4c  0\n  [   16.457508]  ? __lock_acquire+0x3e6/0x249  0\n  [   16.457801]  ? exc_page_fault+0x68/0x20  0\n  [   16.458080]  ? asm_exc_page_fault+0x26/0x3  0\n  [   16.458389]  ? smc_listen_work+0xc02/0x159  0\n  [   16.458689]  ? smc_listen_work+0xc02/0x159  0\n  [   16.458987]  ? lock_is_held_type+0x8f/0x10  0\n  [   16.459284]  process_one_work+0x1ea/0x6d  0\n  [   16.459570]  worker_thread+0x1c3/0x38  0\n  [   16.459839]  ? __pfx_worker_thread+0x10/0x1  0\n  [   16.460144]  kthread+0xe0/0x11  0\n  [   16.460372]  ? __pfx_kthread+0x10/0x1  0\n  [   16.460640]  ret_from_fork+0x31/0x5  0\n  [   16.460896]  ? __pfx_kthread+0x10/0x1  0\n  [   16.461166]  ret_from_fork_asm+0x1a/0x3  0\n  [   16.461453]  \u003c/TASK  \u003e\n  [   16.461616] Modules linked in: bpf_testmod(OE) [last unloaded: bpf_testmod(OE)  ]\n  [   16.462134] CR2: 000000000000003  0\n  [   16.462380] ---[ end trace 0000000000000000 ]---\n  [   16.462710] RIP: 0010:smc_listen_work+0xc02/0x1590\n\nThe direct cause of this issue is that after smc_listen_out_connected(),\nnewclcsock-\u003esk may be NULL since it will releases the smcsk. Therefore,\nif the application closes the socket immediately after accept,\nnewclcsock-\u003esk can be NULL. A possible execution order could be as\nfollows:\n\nsmc_listen_work                                 | userspace\n-----------------------------------------------------------------\nlock_sock(sk)                                   |\nsmc_listen_out_connected()                      |\n| \\- smc_listen_out                             |\n|    | \\- release_sock                          |\n     | |- sk-\u003esk_data_ready()                   |\n                                                | fd = accept();\n                                                | close(fd);\n                                                |  \\- socket-\u003esk = NULL;\n/* newclcsock-\u003esk is NULL now */\nSMC_STAT_SERV_SUCC_INC(sock_net(newclcsock-\u003esk))\n\nSince smc_listen_out_connected() will not fail, simply swapping the order\nof the code can easily fix this issue.(CVE-2025-38734)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Avoid a NULL pointer dereference\n\n[WHY]\nAlthough unlikely drm_atomic_get_new_connector_state() or\ndrm_atomic_get_old_connector_state() can return NULL.\n\n[HOW]\nCheck returns before dereference.\n\n(cherry picked from commit 1e5e8d672fec9f2ab352be121be971877bff2af9)(CVE-2025-39693)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nmedia: ivsc: Fix crash at shutdown due to missing mei_cldev_disable() calls\n\nBoth the ACE and CSI driver are missing a mei_cldev_disable() call in\ntheir remove() function.\n\nThis causes the mei_cl client to stay part of the mei_device-\u003efile_list\nlist even though its memory is freed by mei_cl_bus_dev_release() calling\nkfree(cldev-\u003ecl).\n\nThis leads to a use-after-free when mei_vsc_remove() runs mei_stop()\nwhich first removes all mei bus devices calling mei_ace_remove() and\nmei_csi_remove() followed by mei_cl_bus_dev_release() and then calls\nmei_cl_all_disconnect() which walks over mei_device-\u003efile_list dereferecing\nthe just freed cldev-\u003ecl.\n\nAnd mei_vsc_remove() it self is run at shutdown because of the\nplatform_device_unregister(tp-\u003epdev) in vsc_tp_shutdown()\n\nWhen building a kernel with KASAN this leads to the following KASAN report:\n\n[ 106.634504] ==================================================================\n[ 106.634623] BUG: KASAN: slab-use-after-free in mei_cl_set_disconnected (drivers/misc/mei/client.c:783) mei\n[ 106.634683] Read of size 4 at addr ffff88819cb62018 by task systemd-shutdow/1\n[ 106.634729]\n[ 106.634767] Tainted: [E]=UNSIGNED_MODULE\n[ 106.634770] Hardware name: Dell Inc. XPS 16 9640/09CK4V, BIOS 1.12.0 02/10/2025\n[ 106.634773] Call Trace:\n[ 106.634777]  \u003cTASK\u003e\n...\n[ 106.634871] kasan_report (mm/kasan/report.c:221 mm/kasan/report.c:636)\n[ 106.634901] mei_cl_set_disconnected (drivers/misc/mei/client.c:783) mei\n[ 106.634921] mei_cl_all_disconnect (drivers/misc/mei/client.c:2165 (discriminator 4)) mei\n[ 106.634941] mei_reset (drivers/misc/mei/init.c:163) mei\n...\n[ 106.635042] mei_stop (drivers/misc/mei/init.c:348) mei\n[ 106.635062] mei_vsc_remove (drivers/misc/mei/mei_dev.h:784 drivers/misc/mei/platform-vsc.c:393) mei_vsc\n[ 106.635066] platform_remove (drivers/base/platform.c:1424)\n\nAdd the missing mei_cldev_disable() calls so that the mei_cl gets removed\nfrom mei_device-\u003efile_list before it is freed to fix this.(CVE-2025-39711)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Revise __get_user() to probe user read access\n\nBecause of the way read access support is implemented, read access\ninterruptions are only triggered at privilege levels 2 and 3. The\nkernel executes at privilege level 0, so __get_user() never triggers\na read access interruption (code 26). Thus, it is currently possible\nfor user code to access a read protected address via a system call.\n\nFix this by probing read access rights at privilege level 3 (PRIV_USER)\nand setting __gu_err to -EFAULT (-14) if access isn't allowed.\n\nNote the cmpiclr instruction does a 32-bit compare because COND macro\ndoesn't work inside asm.(CVE-2025-39716)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\niio: imu: bno055: fix OOB access of hw_xlate array\n\nFix a potential out-of-bounds array access of the hw_xlate array in\nbno055.c.\n\nIn bno055_get_regmask(), hw_xlate was iterated over the length of the\nvals array instead of the length of the hw_xlate array. In the case of\nbno055_gyr_scale, the vals array is larger than the hw_xlate array,\nso this could result in an out-of-bounds access. In practice, this\nshouldn't happen though because a match should always be found which\nbreaks out of the for loop before it iterates beyond the end of the\nhw_xlate array.\n\nBy adding a new hw_xlate_len field to the bno055_sysfs_attr, we can be\nsure we are iterating over the correct length.(CVE-2025-39719)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ns390/ism: fix concurrency management in ism_cmd()\n\nThe s390x ISM device data sheet clearly states that only one\nrequest-response sequence is allowable per ISM function at any point in\ntime.  Unfortunately as of today the s390/ism driver in Linux does not\nhonor that requirement. This patch aims to rectify that.\n\nThis problem was discovered based on Aliaksei's bug report which states\nthat for certain workloads the ISM functions end up entering error state\n(with PEC 2 as seen from the logs) after a while and as a consequence\nconnections handled by the respective function break, and for future\nconnection requests the ISM device is not considered -- given it is in a\ndysfunctional state. During further debugging PEC 3A was observed as\nwell.\n\nA kernel message like\n[ 1211.244319] zpci: 061a:00:00.0: Event 0x2 reports an error for PCI function 0x61a\nis a reliable indicator of the stated function entering error state\nwith PEC 2. Let me also point out that a kernel message like\n[ 1211.244325] zpci: 061a:00:00.0: The ism driver bound to the device does not support error recovery\nis a reliable indicator that the ISM function won't be auto-recovered\nbecause the ISM driver currently lacks support for it.\n\nOn a technical level, without this synchronization, commands (inputs to\nthe FW) may be partially or fully overwritten (corrupted) by another CPU\ntrying to issue commands on the same function. There is hard evidence that\nthis can lead to DMB token values being used as DMB IOVAs, leading to\nPEC 2 PCI events indicating invalid DMA. But this is only one of the\nfailure modes imaginable. In theory even completely losing one command\nand executing another one twice and then trying to interpret the outputs\nas if the command we intended to execute was actually executed and not\nthe other one is also possible.  Frankly, I don't feel confident about\nproviding an exhaustive list of possible consequences.(CVE-2025-39726)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: Optimize module load time by optimizing PLT/GOT counting\n\nWhen enabling CONFIG_KASAN, CONFIG_PREEMPT_VOLUNTARY_BUILD and\nCONFIG_PREEMPT_VOLUNTARY at the same time, there will be soft deadlock,\nthe relevant logs are as follows:\n\nrcu: INFO: rcu_sched self-detected stall on CPU\n...\nCall Trace:\n[\u003c900000000024f9e4\u003e] show_stack+0x5c/0x180\n[\u003c90000000002482f4\u003e] dump_stack_lvl+0x94/0xbc\n[\u003c9000000000224544\u003e] rcu_dump_cpu_stacks+0x1fc/0x280\n[\u003c900000000037ac80\u003e] rcu_sched_clock_irq+0x720/0xf88\n[\u003c9000000000396c34\u003e] update_process_times+0xb4/0x150\n[\u003c90000000003b2474\u003e] tick_nohz_handler+0xf4/0x250\n[\u003c9000000000397e28\u003e] __hrtimer_run_queues+0x1d0/0x428\n[\u003c9000000000399b2c\u003e] hrtimer_interrupt+0x214/0x538\n[\u003c9000000000253634\u003e] constant_timer_interrupt+0x64/0x80\n[\u003c9000000000349938\u003e] __handle_irq_event_percpu+0x78/0x1a0\n[\u003c9000000000349a78\u003e] handle_irq_event_percpu+0x18/0x88\n[\u003c9000000000354c00\u003e] handle_percpu_irq+0x90/0xf0\n[\u003c9000000000348c74\u003e] handle_irq_desc+0x94/0xb8\n[\u003c9000000001012b28\u003e] handle_cpu_irq+0x68/0xa0\n[\u003c9000000001def8c0\u003e] handle_loongarch_irq+0x30/0x48\n[\u003c9000000001def958\u003e] do_vint+0x80/0xd0\n[\u003c9000000000268a0c\u003e] kasan_mem_to_shadow.part.0+0x2c/0x2a0\n[\u003c90000000006344f4\u003e] __asan_load8+0x4c/0x120\n[\u003c900000000025c0d0\u003e] module_frob_arch_sections+0x5c8/0x6b8\n[\u003c90000000003895f0\u003e] load_module+0x9e0/0x2958\n[\u003c900000000038b770\u003e] __do_sys_init_module+0x208/0x2d0\n[\u003c9000000001df0c34\u003e] do_syscall+0x94/0x190\n[\u003c900000000024d6fc\u003e] handle_syscall+0xbc/0x158\n\nAfter analysis, this is because the slow speed of loading the amdgpu\nmodule leads to the long time occupation of the cpu and then the soft\ndeadlock.\n\nWhen loading a module, module_frob_arch_sections() tries to figure out\nthe number of PLTs/GOTs that will be needed to handle all the RELAs. It\nwill call the count_max_entries() to find in an out-of-order date which\ncounting algorithm has O(n^2) complexity.\n\nTo make it faster, we sort the relocation list by info and addend. That\nway, to check for a duplicate relocation, it just needs to compare with\nthe previous entry. This reduces the complexity of the algorithm to O(n\n log n), as done in commit d4e0340919fb (\"arm64/module: Optimize module\nload time by optimizing PLT counting\"). This gives sinificant reduction\nin module load time for modules with large number of relocations.\n\nAfter applying this patch, the soft deadlock problem has been solved,\nand the kernel starts normally without \"Call Trace\".\n\nUsing the default configuration to test some modules, the results are as\nfollows:\n\nModule              Size\nip_tables           36K\nfat                 143K\nradeon              2.5MB\namdgpu              16MB\n\nWithout this patch:\nModule              Module load time (ms)\tCount(PLTs/GOTs)\nip_tables           18\t\t\t\t59/6\nfat                 0\t\t\t\t162/14\nradeon              54\t\t\t\t1221/84\namdgpu              1411\t\t\t4525/1098\n\nWith this patch:\nModule              Module load time (ms)\tCount(PLTs/GOTs)\nip_tables           18\t\t\t\t59/6\nfat                 0\t\t\t\t162/14\nradeon              22\t\t\t\t1221/84\namdgpu              45\t\t\t\t4525/1098(CVE-2025-39767)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Drop WARN_ON_ONCE() from flush_cache_vmap\n\nI have observed warning to occassionally trigger.(CVE-2025-39781)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nARM: tegra: Use I/O memcpy to write to IRAM\n\nKasan crashes the kernel trying to check boundaries when using the\nnormal memcpy.(CVE-2025-39794)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nHID: hid-ntrig: fix unable to handle page fault in ntrig_report_version()\n\nin ntrig_report_version(), hdev parameter passed from hid_probe().\nsending descriptor to /dev/uhid can make hdev-\u003edev.parent-\u003eparent to null\nif hdev-\u003edev.parent-\u003eparent is null, usb_dev has\ninvalid address(0xffffffffffffff58) that hid_to_usb_dev(hdev) returned\nwhen usb_rcvctrlpipe() use usb_dev,it trigger\npage fault error for address(0xffffffffffffff58)\n\nadd null check logic to ntrig_report_version()\nbefore calling hid_to_usb_dev()(CVE-2025-39808)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: prevent release journal inode after journal shutdown\n\nBefore calling ocfs2_delete_osb(), ocfs2_journal_shutdown() has already\nbeen executed in ocfs2_dismount_volume(), so osb-\u003ejournal must be NULL. \nTherefore, the following calltrace will inevitably fail when it reaches\njbd2_journal_release_jbd_inode().\n\nocfs2_dismount_volume()-\u003e\n  ocfs2_delete_osb()-\u003e\n    ocfs2_free_slot_info()-\u003e\n      __ocfs2_free_slot_info()-\u003e\n        evict()-\u003e\n          ocfs2_evict_inode()-\u003e\n            ocfs2_clear_inode()-\u003e\n\t      jbd2_journal_release_jbd_inode(osb-\u003ejournal-\u003ej_journal,\n\nAdding osb-\u003ejournal checks will prevent null-ptr-deref during the above\nexecution path.(CVE-2025-39842)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\npcmcia: Fix a NULL pointer dereference in __iodyn_find_io_region()\n\nIn __iodyn_find_io_region(), pcmcia_make_resource() is assigned to\nres and used in pci_bus_alloc_resource(). There is a dereference of res\nin pci_bus_alloc_resource(), which could lead to a NULL pointer\ndereference on failure of pcmcia_make_resource().\n\nFix this bug by adding a check of res.(CVE-2025-39846)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: vhci: Prevent use-after-free by removing debugfs files early\n\nMove the creation of debugfs files into a dedicated function, and ensure\nthey are explicitly removed during vhci_release(), before associated\ndata structures are freed.\n\nPreviously, debugfs files such as \"force_suspend\", \"force_wakeup\", and\nothers were created under hdev-\u003edebugfs but not removed in\nvhci_release(). Since vhci_release() frees the backing vhci_data\nstructure, any access to these files after release would result in\nuse-after-free errors.\n\nAlthough hdev-\u003edebugfs is later freed in hci_release_dev(), user can\naccess files after vhci_data is freed but before hdev-\u003edebugfs is\nreleased.(CVE-2025-39861)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info work\n\nThe brcmf_btcoex_detach() only shuts down the btcoex timer, if the\nflag timer_on is false. However, the brcmf_btcoex_timerfunc(), which\nruns as timer handler, sets timer_on to false. This creates critical\nrace conditions:\n\n1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc()\nis executing, it may observe timer_on as false and skip the call to\ntimer_shutdown_sync().\n\n2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_info\nworker after the cancel_work_sync() has been executed, resulting in\nuse-after-free bugs.\n\nThe use-after-free bugs occur in two distinct scenarios, depending on\nthe timing of when the brcmf_btcoex_info struct is freed relative to\nthe execution of its worker thread.\n\nScenario 1: Freed before the worker is scheduled\n\nThe brcmf_btcoex_info is deallocated before the worker is scheduled.\nA race condition can occur when schedule_work(\u0026bt_local-\u003ework) is\ncalled after the target memory has been freed. The sequence of events\nis detailed below:\n\nCPU0                           | CPU1\nbrcmf_btcoex_detach            | brcmf_btcoex_timerfunc\n                               |   bt_local-\u003etimer_on = false;\n  if (cfg-\u003ebtcoex-\u003etimer_on)   |\n    ...                        |\n  cancel_work_sync();          |\n  ...                          |\n  kfree(cfg-\u003ebtcoex); // FREE  |\n                               |   schedule_work(\u0026bt_local-\u003ework); // USE\n\nScenario 2: Freed after the worker is scheduled\n\nThe brcmf_btcoex_info is freed after the worker has been scheduled\nbut before or during its execution. In this case, statements within\nthe brcmf_btcoex_handler() â€” such as the container_of macro and\nsubsequent dereferences of the brcmf_btcoex_info object will cause\na use-after-free access. The following timeline illustrates this\nscenario:\n\nCPU0                            | CPU1\nbrcmf_btcoex_detach             | brcmf_btcoex_timerfunc\n                                |   bt_local-\u003etimer_on = false;\n  if (cfg-\u003ebtcoex-\u003etimer_on)    |\n    ...                         |\n  cancel_work_sync();           |\n  ...                           |   schedule_work(); // Reschedule\n                                |\n  kfree(cfg-\u003ebtcoex); // FREE   |   brcmf_btcoex_handler() // Worker\n  /*                            |     btci = container_of(....); // USE\n   The kfree() above could      |     ...\n   also occur at any point      |     btci-\u003e // USE\n   during the worker's execution|\n   */                           |\n\nTo resolve the race conditions, drop the conditional check and call\ntimer_shutdown_sync() directly. It can deactivate the timer reliably,\nregardless of its current state. Once stopped, the timer_on state is\nthen set to false.(CVE-2025-39863)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nmm/damon/lru_sort: avoid divide-by-zero in damon_lru_sort_apply_parameters()\n\nPatch series \"mm/damon: avoid divide-by-zero in DAMON module's parameters\napplication\".\n\nDAMON's RECLAIM and LRU_SORT modules perform no validation on\nuser-configured parameters during application, which may lead to\ndivision-by-zero errors.\n\nAvoid the divide-by-zero by adding validation checks when DAMON modules\nattempt to apply the parameters.\n\n\nThis patch (of 2):\n\nDuring the calculation of 'hot_thres' and 'cold_thres', either\n'sample_interval' or 'aggr_interval' is used as the divisor, which may\nlead to division-by-zero errors.  Fix it by directly returning -EINVAL\nwhen such a case occurs.  Additionally, since 'aggr_interval' is already\nrequired to be set no smaller than 'sample_interval' in damon_set_attrs(),\nonly the case where 'sample_interval' is zero needs to be checked.(CVE-2025-39909)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nmm/damon/reclaim: avoid divide-by-zero in damon_reclaim_apply_parameters()\n\nWhen creating a new scheme of DAMON_RECLAIM, the calculation of\n'min_age_region' uses 'aggr_interval' as the divisor, which may lead to\ndivision-by-zero errors.  Fix it by directly returning -EINVAL when such a\ncase occurs.(CVE-2025-39916)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ndrm: bridge: anx7625: Fix NULL pointer dereference with early IRQ\n\nIf the interrupt occurs before resource initialization is complete, the\ninterrupt handler/worker may access uninitialized data such as the I2C\ntcpc_client device, potentially leading to NULL pointer dereference.(CVE-2025-39934)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: avoid buffer overflow in WID string configuration\n\nFix the following copy overflow warning identified by Smatch checker.\n\n drivers/net/wireless/microchip/wilc1000/wlan_cfg.c:184 wilc_wlan_parse_response_frame()\n        error: '__memcpy()' 'cfg-\u003es[i]-\u003estr' copy overflow (512 vs 65537)\n\nThis patch introduces size check before accessing the memory buffer.\nThe checks are base on the WID type of received data from the firmware.\nFor WID string configuration, the size limit is determined by individual\nelement size in 'struct wilc_cfg_str_vals' that is maintained in 'len' field\nof 'struct wilc_cfg_str'.(CVE-2025-39952)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nKVM: SVM: Skip fastpath emulation on VM-Exit if next RIP isn't valid\n\nSkip the WRMSR and HLT fastpaths in SVM's VM-Exit handler if the next RIP\nisn't valid, e.g. because KVM is running with nrips=false.  SVM must\ndecode and emulate to skip the instruction if the CPU doesn't provide the\nnext RIP, and getting the instruction bytes to decode requires reading\nguest memory.  Reading guest memory through the emulator can fault, i.e.\ncan sleep, which is disallowed since the fastpath handlers run with IRQs\ndisabled.\n\n BUG: sleeping function called from invalid context at ./include/linux/uaccess.h:106\n in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 32611, name: qemu\n preempt_count: 1, expected: 0\n INFO: lockdep is turned off.\n irq event stamp: 30580\n hardirqs last  enabled at (30579): [\u003cffffffffc08b2527\u003e] vcpu_run+0x1787/0x1db0 [kvm]\n hardirqs last disabled at (30580): [\u003cffffffffb4f62e32\u003e] __schedule+0x1e2/0xed0\n softirqs last  enabled at (30570): [\u003cffffffffb4247a64\u003e] fpu_swap_kvm_fpstate+0x44/0x210\n softirqs last disabled at (30568): [\u003cffffffffb4247a64\u003e] fpu_swap_kvm_fpstate+0x44/0x210\n CPU: 298 UID: 0 PID: 32611 Comm: qemu Tainted: G     U              6.16.0-smp--e6c618b51cfe-sleep #782 NONE\n Tainted: [U]=USER\n Hardware name: Google Astoria-Turin/astoria, BIOS 0.20241223.2-0 01/17/2025\n Call Trace:\n  \u003cTASK\u003e\n  dump_stack_lvl+0x7d/0xb0\n  __might_resched+0x271/0x290\n  __might_fault+0x28/0x80\n  kvm_vcpu_read_guest_page+0x8d/0xc0 [kvm]\n  kvm_fetch_guest_virt+0x92/0xc0 [kvm]\n  __do_insn_fetch_bytes+0xf3/0x1e0 [kvm]\n  x86_decode_insn+0xd1/0x1010 [kvm]\n  x86_emulate_instruction+0x105/0x810 [kvm]\n  __svm_skip_emulated_instruction+0xc4/0x140 [kvm_amd]\n  handle_fastpath_invd+0xc4/0x1a0 [kvm]\n  vcpu_run+0x11a1/0x1db0 [kvm]\n  kvm_arch_vcpu_ioctl_run+0x5cc/0x730 [kvm]\n  kvm_vcpu_ioctl+0x578/0x6a0 [kvm]\n  __se_sys_ioctl+0x6d/0xb0\n  do_syscall_64+0x8a/0x2c0\n  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n RIP: 0033:0x7f479d57a94b\n  \u003c/TASK\u003e\n\nNote, this is essentially a reapply of commit 5c30e8101e8d (\"KVM: SVM:\nSkip WRMSR fastpath on VM-Exit if next RIP isn't valid\"), but with\ndifferent justification (KVM now grabs SRCU when skipping the instruction\nfor other reasons).(CVE-2025-40038)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\next4: fix potential null deref in ext4_mb_init()\n\nIn ext4_mb_init(), ext4_mb_avg_fragment_size_destroy() may be called\nwhen sbi-\u003es_mb_avg_fragment_size remains uninitialized (e.g., if groupinfo\nslab cache allocation fails). Since ext4_mb_avg_fragment_size_destroy()\nlacks null pointer checking, this leads to a null pointer dereference.\n\n==================================================================\nEXT4-fs: no memory for groupinfo slab cache\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 0 P4D 0\nOops: Oops: 0002 [#1] SMP PTI\nCPU:2 UID: 0 PID: 87 Comm:mount Not tainted 6.17.0-rc2 #1134 PREEMPT(none)\nRIP: 0010:_raw_spin_lock_irqsave+0x1b/0x40\nCall Trace:\n \u003cTASK\u003e\n xa_destroy+0x61/0x130\n ext4_mb_init+0x483/0x540\n __ext4_fill_super+0x116d/0x17b0\n ext4_fill_super+0xd3/0x280\n get_tree_bdev_flags+0x132/0x1d0\n vfs_get_tree+0x29/0xd0\n do_new_mount+0x197/0x300\n __x64_sys_mount+0x116/0x150\n do_syscall_64+0x50/0x1c0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n==================================================================\n\nTherefore, add necessary null check to ext4_mb_avg_fragment_size_destroy()\nto prevent this issue. The same fix is also applied to\next4_mb_largest_free_orders_destroy().(CVE-2025-40119)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nEDAC/i10nm: Skip DIMM enumeration on a disabled memory controller\n\nWhen loading the i10nm_edac driver on some Intel Granite Rapids servers,\na call trace may appear as follows:\n\n  UBSAN: shift-out-of-bounds in drivers/edac/skx_common.c:453:16\n  shift exponent -66 is negative\n  ...\n  __ubsan_handle_shift_out_of_bounds+0x1e3/0x390\n  skx_get_dimm_info.cold+0x47/0xd40 [skx_edac_common]\n  i10nm_get_dimm_config+0x23e/0x390 [i10nm_edac]\n  skx_register_mci+0x159/0x220 [skx_edac_common]\n  i10nm_init+0xcb0/0x1ff0 [i10nm_edac]\n  ...\n\nThis occurs because some BIOS may disable a memory controller if there\naren't any memory DIMMs populated on this memory controller. The DIMMMTR\nregister of this disabled memory controller contains the invalid value\n~0, resulting in the call trace above.\n\nFix this call trace by skipping DIMM enumeration on a disabled memory\ncontroller.(CVE-2025-40157)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nfs: quota: create dedicated workqueue for quota_release_work\n\nThere is a kernel panic due to WARN_ONCE when panic_on_warn is set.\n\nThis issue occurs when writeback is triggered due to sync call for an\nopened file(ie, writeback reason is WB_REASON_SYNC). When f2fs balance\nis needed at sync path, flush for quota_release_work is triggered.\nBy default quota_release_work is queued to \"events_unbound\" queue which\ndoes not have WQ_MEM_RECLAIM flag. During f2fs balance \"writeback\"\nworkqueue tries to flush quota_release_work causing kernel panic due to\nMEM_RECLAIM flag mismatch errors.\n\nThis patch creates dedicated workqueue with WQ_MEM_RECLAIM flag\nfor work quota_release_work.\n\n------------[ cut here ]------------\nWARNING: CPU: 4 PID: 14867 at kernel/workqueue.c:3721 check_flush_dependency+0x13c/0x148\nCall trace:\n check_flush_dependency+0x13c/0x148\n __flush_work+0xd0/0x398\n flush_delayed_work+0x44/0x5c\n dquot_writeback_dquots+0x54/0x318\n f2fs_do_quota_sync+0xb8/0x1a8\n f2fs_write_checkpoint+0x3cc/0x99c\n f2fs_gc+0x190/0x750\n f2fs_balance_fs+0x110/0x168\n f2fs_write_single_data_page+0x474/0x7dc\n f2fs_write_data_pages+0x7d0/0xd0c\n do_writepages+0xe0/0x2f4\n __writeback_single_inode+0x44/0x4ac\n writeback_sb_inodes+0x30c/0x538\n wb_writeback+0xf4/0x440\n wb_workfn+0x128/0x5d4\n process_scheduled_works+0x1c4/0x45c\n worker_thread+0x32c/0x3e8\n kthread+0x11c/0x1b0\n ret_from_fork+0x10/0x20\nKernel panic - not syncing: kernel: panic_on_warn set ...(CVE-2025-40196)\n\nIn the Linux kernel, the following vulnerability has been resolved: media: v4l2-subdev: Fix alloc failure check in v4l2_subdev_call_state_try(). v4l2_subdev_call_state_try() macro allocates a subdev state with __v4l2_subdev_state_alloc(), but does not check the returned value. If __v4l2_subdev_state_alloc fails, it returns an ERR_PTR, and that would cause v4l2_subdev_call_state_try() to crash. Add proper error handling to v4l2_subdev_call_state_try().(CVE-2025-40207)",
      "Title": "Description",
      "Type": "General"
    },
    {
      "Text": "An update for kernel is now available for openEuler-24.03-LTS.\n\nopenEuler Security has rated this update as having a security impact of high. A Common Vunlnerability Scoring System(CVSS)base score,which gives a detailed severity rating, is available for each vulnerability from the CVElink(s) in the References section.",
      "Title": "Topic",
      "Type": "General"
    },
    {
      "Text": "High",
      "Title": "Severity",
      "Type": "General"
    },
    {
      "Text": "kernel",
      "Title": "Affected Component",
      "Type": "General"
    }
  ],
  "ProductTree": {
    "Branches": [
      {
        "Type": "Product Name",
        "Name": "openEuler",
        "Productions": [
          {
            "ProductID": "openEuler-24.03-LTS",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "openEuler-24.03-LTS"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "aarch64",
        "Productions": [
          {
            "ProductID": "bpftool-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "bpftool-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "bpftool-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "bpftool-debuginfo-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-debuginfo-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-debugsource-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-debugsource-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-devel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-devel-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-headers-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-headers-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-source-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-source-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-tools-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-tools-debuginfo-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "kernel-tools-devel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-tools-devel-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "perf-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "perf-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "perf-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "perf-debuginfo-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "python3-perf-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "python3-perf-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          },
          {
            "ProductID": "python3-perf-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "python3-perf-debuginfo-6.6.0-119.0.0.110.oe2403.aarch64.rpm"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "x86_64",
        "Productions": [
          {
            "ProductID": "bpftool-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "bpftool-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "bpftool-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "bpftool-debuginfo-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-debuginfo-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-debugsource-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-debugsource-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-devel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-devel-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-headers-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-headers-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-source-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-source-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-tools-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-tools-debuginfo-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "kernel-tools-devel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-tools-devel-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "perf-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "perf-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "perf-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "perf-debuginfo-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "python3-perf-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "python3-perf-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          },
          {
            "ProductID": "python3-perf-debuginfo-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "python3-perf-debuginfo-6.6.0-119.0.0.110.oe2403.x86_64.rpm"
          }
        ]
      },
      {
        "Type": "Package Arch",
        "Name": "src",
        "Productions": [
          {
            "ProductID": "kernel-6.6.0-119.0.0.110",
            "CPE": "cpe:/a:openEuler:openEuler:24.03-LTS",
            "Text": "kernel-6.6.0-119.0.0.110.oe2403.src.rpm"
          }
        ]
      }
    ]
  },
  "References": [
    {
      "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
    },
    {
      "URL": "https://www.openeuler.org/en/security/cve/detail/?cveId=CVE-2025-40207"
    },
    {
      "URL": "https://nvd.nist.gov/vuln/detail/CVE-2025-40207"
    }
  ],
  "Vulnerabilities": [
    {
      "CVE": "CVE-2025-23140",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: pci_endpoint_test: Avoid issue of interrupts remaining after request_irq error\n\nAfter devm_request_irq() fails with error in pci_endpoint_test_request_irq(),\nthe pci_endpoint_test_free_irq_vectors() is called assuming that all IRQs\nhave been released.\n\nHowever, some requested IRQs remain unreleased, so there are still\n/proc/irq/* entries remaining, and this results in WARN() with the\nfollowing message:\n\n  remove_proc_entry: removing non-empty directory 'irq/30', leaking at least 'pci-endpoint-test.0'\n  WARNING: CPU: 0 PID: 202 at fs/proc/generic.c:719 remove_proc_entry +0x190/0x19c\n\nTo solve this issue, set the number of remaining IRQs to test-\u003enum_irqs,\nand release IRQs in advance by calling pci_endpoint_test_release_irq().\n\n[kwilczynski: commit log]",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38059",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: avoid NULL pointer dereference if no valid csum tree\n\n[BUG]\nWhen trying read-only scrub on a btrfs with rescue=idatacsums mount\noption, it will crash with the following call trace:\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000208\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  CPU: 1 UID: 0 PID: 835 Comm: btrfs Tainted: G           O        6.15.0-rc3-custom+ #236 PREEMPT(full)\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022\n  RIP: 0010:btrfs_lookup_csums_bitmap+0x49/0x480 [btrfs]\n  Call Trace:\n   \u003cTASK\u003e\n   scrub_find_fill_first_stripe+0x35b/0x3d0 [btrfs]\n   scrub_simple_mirror+0x175/0x290 [btrfs]\n   scrub_stripe+0x5f7/0x6f0 [btrfs]\n   scrub_chunk+0x9a/0x150 [btrfs]\n   scrub_enumerate_chunks+0x333/0x660 [btrfs]\n   btrfs_scrub_dev+0x23e/0x600 [btrfs]\n   btrfs_ioctl+0x1dcf/0x2f80 [btrfs]\n   __x64_sys_ioctl+0x97/0xc0\n   do_syscall_64+0x4f/0x120\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n[CAUSE]\nMount option \"rescue=idatacsums\" will completely skip loading the csum\ntree, so that any data read will not find any data csum thus we will\nignore data checksum verification.\n\nNormally call sites utilizing csum tree will check the fs state flag\nNO_DATA_CSUMS bit, but unfortunately scrub does not check that bit at all.\n\nThis results in scrub to call btrfs_search_slot() on a NULL pointer\nand triggered above crash.\n\n[FIX]\nCheck both extent and csum tree root before doing any tree search.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38132",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ncoresight: holding cscfg_csdev_lock while removing cscfg from csdev\n\nThere'll be possible race scenario for coresight config:\n\nCPU0                                          CPU1\n(perf enable)                                 load module\n                                              cscfg_load_config_sets()\n                                              activate config. // sysfs\n                                              (sys_active_cnt == 1)\n...\ncscfg_csdev_enable_active_config()\n  lock(csdev-\u003ecscfg_csdev_lock)\n                                              deactivate config // sysfs\n                                              (sys_activec_cnt == 0)\n                                              cscfg_unload_config_sets()\n  \u003citerating config_csdev_list\u003e               cscfg_remove_owned_csdev_configs()\n  // here load config activate by CPU1\n  unlock(csdev-\u003ecscfg_csdev_lock)\n\niterating config_csdev_list could be raced with config_csdev_list's\nentry delete.\n\nTo resolve this race , hold csdev-\u003ecscfg_csdev_lock() while\ncscfg_remove_owned_csdev_configs()",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38155",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7915: Fix null-ptr-deref in mt7915_mmio_wed_init()\n\ndevm_ioremap() returns NULL on error. Currently, mt7915_mmio_wed_init()\ndoes not check for this case, which results in a NULL pointer\ndereference.\n\nPrevent null pointer dereference in mt7915_mmio_wed_init().",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38167",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/ntfs3: handle hdr_first_de() return value\n\nThe hdr_first_de() function returns a pointer to a struct NTFS_DE. This\npointer may be NULL. To handle the NULL error effectively, it is important\nto implement an error handler. This will help manage potential errors\nconsistently.\n\nAdditionally, error handling for the return value already exists at other\npoints where this function is called.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38206",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix double free in delayed_free\n\nThe double free could happen in the following path.\n\nexfat_create_upcase_table()\n        exfat_create_upcase_table() : return error\n        exfat_free_upcase_table() : free -\u003evol_utbl\n        exfat_load_default_upcase_table : return error\n     exfat_kill_sb()\n           delayed_free()\n                  exfat_free_upcase_table() \u003c--------- double free\nThis patch set -\u003evol_util as NULL after freeing it.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38326",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\naoe: clean device rq_list in aoedev_downdev()\n\nAn aoe device's rq_list contains accepted block requests that are\nwaiting to be transmitted to the aoe target. This queue was added as\npart of the conversion to blk_mq. However, the queue was not cleaned out\nwhen an aoe device is downed which caused blk_mq_freeze_queue() to sleep\nindefinitely waiting for those requests to complete, causing a hang. This\nfix cleans out the queue before calling blk_mq_freeze_queue().",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38348",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: p54: prevent buffer-overflow in p54_rx_eeprom_readback()\n\nRobert Morris reported:\n\n|If a malicious USB device pretends to be an Intersil p54 wifi\n|interface and generates an eeprom_readback message with a large\n|eeprom-\u003ev1.len, p54_rx_eeprom_readback() will copy data from the\n|message beyond the end of priv-\u003eeeprom.\n|\n|static void p54_rx_eeprom_readback(struct p54_common *priv,\n|                                   struct sk_buff *skb)\n|{\n|        struct p54_hdr *hdr = (struct p54_hdr *) skb-\u003edata;\n|        struct p54_eeprom_lm86 *eeprom = (struct p54_eeprom_lm86 *) hdr-\u003edata;\n|\n|        if (priv-\u003efw_var \u003e= 0x509) {\n|                memcpy(priv-\u003eeeprom, eeprom-\u003ev2.data,\n|                       le16_to_cpu(eeprom-\u003ev2.len));\n|        } else {\n|                memcpy(priv-\u003eeeprom, eeprom-\u003ev1.data,\n|                       le16_to_cpu(eeprom-\u003ev1.len));\n|        }\n| [...]\n\nThe eeprom-\u003ev{1,2}.len is set by the driver in p54_download_eeprom().\nThe device is supposed to provide the same length back to the driver.\nBut yes, it's possible (like shown in the report) to alter the value\nto something that causes a crash/panic due to overrun.\n\nThis patch addresses the issue by adding the size to the common device\ncontext, so p54_rx_eeprom_readback no longer relies on possibly tampered\nvalues... That said, it also checks if the \"firmware\" altered the value\nand no longer copies them.\n\nThe one, small saving grace is: Before the driver tries to read the eeprom,\nit needs to upload \u003ea\u003c firmware. the vendor firmware has a proprietary\nlicense and as a reason, it is not present on most distributions by\ndefault.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38640",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Disable migration in nf_hook_run_bpf().\n\nsyzbot reported that the netfilter bpf prog can be called without\nmigration disabled in xmit path.\n\nThen the assertion in __bpf_prog_run() fails, triggering the splat\nbelow. [0]\n\nLet's use bpf_prog_run_pin_on_cpu() in nf_hook_run_bpf().\n\n[0]:\nBUG: assuming non migratable context at ./include/linux/filter.h:703\nin_atomic(): 0, irqs_disabled(): 0, migration_disabled() 0 pid: 5829, name: sshd-session\n3 locks held by sshd-session/5829:\n #0: ffff88807b4e4218 (sk_lock-AF_INET){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1667 [inline]\n #0: ffff88807b4e4218 (sk_lock-AF_INET){+.+.}-{0:0}, at: tcp_sendmsg+0x20/0x50 net/ipv4/tcp.c:1395\n #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline]\n #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:841 [inline]\n #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: __ip_queue_xmit+0x69/0x26c0 net/ipv4/ip_output.c:470\n #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline]\n #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:841 [inline]\n #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: nf_hook+0xb2/0x680 include/linux/netfilter.h:241\nCPU: 0 UID: 0 PID: 5829 Comm: sshd-session Not tainted 6.16.0-rc6-syzkaller-00002-g155a3c003e55 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n \u003cTASK\u003e\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120\n __cant_migrate kernel/sched/core.c:8860 [inline]\n __cant_migrate+0x1c7/0x250 kernel/sched/core.c:8834\n __bpf_prog_run include/linux/filter.h:703 [inline]\n bpf_prog_run include/linux/filter.h:725 [inline]\n nf_hook_run_bpf+0x83/0x1e0 net/netfilter/nf_bpf_link.c:20\n nf_hook_entry_hookfn include/linux/netfilter.h:157 [inline]\n nf_hook_slow+0xbb/0x200 net/netfilter/core.c:623\n nf_hook+0x370/0x680 include/linux/netfilter.h:272\n NF_HOOK_COND include/linux/netfilter.h:305 [inline]\n ip_output+0x1bc/0x2a0 net/ipv4/ip_output.c:433\n dst_output include/net/dst.h:459 [inline]\n ip_local_out net/ipv4/ip_output.c:129 [inline]\n __ip_queue_xmit+0x1d7d/0x26c0 net/ipv4/ip_output.c:527\n __tcp_transmit_skb+0x2686/0x3e90 net/ipv4/tcp_output.c:1479\n tcp_transmit_skb net/ipv4/tcp_output.c:1497 [inline]\n tcp_write_xmit+0x1274/0x84e0 net/ipv4/tcp_output.c:2838\n __tcp_push_pending_frames+0xaf/0x390 net/ipv4/tcp_output.c:3021\n tcp_push+0x225/0x700 net/ipv4/tcp.c:759\n tcp_sendmsg_locked+0x1870/0x42b0 net/ipv4/tcp.c:1359\n tcp_sendmsg+0x2e/0x50 net/ipv4/tcp.c:1396\n inet_sendmsg+0xb9/0x140 net/ipv4/af_inet.c:851\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n sock_write_iter+0x4aa/0x5b0 net/socket.c:1131\n new_sync_write fs/read_write.c:593 [inline]\n vfs_write+0x6c7/0x1150 fs/read_write.c:686\n ksys_write+0x1f8/0x250 fs/read_write.c:738\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fe7d365d407\nCode: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 \u003c5b\u003e c3 0f 1f 80 00 00 00 00 83 e2 39 83 fa 08 75 de e8 23 ff ff ff\nRSP:",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38696",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nMIPS: Don't crash in stack_top() for tasks without ABI or vDSO\n\nNot all tasks have an ABI associated or vDSO mapped,\nfor example kthreads never do.\nIf such a task ever ends up calling stack_top(), it will derefence the\nNULL ABI pointer and crash.\n\nThis can for example happen when using kunit:\n\n    mips_stack_top+0x28/0xc0\n    arch_pick_mmap_layout+0x190/0x220\n    kunit_vm_mmap_init+0xf8/0x138\n    __kunit_add_resource+0x40/0xa8\n    kunit_vm_mmap+0x88/0xd8\n    usercopy_test_init+0xb8/0x240\n    kunit_try_run_case+0x5c/0x1a8\n    kunit_generic_run_threadfn_adapter+0x28/0x50\n    kthread+0x118/0x240\n    ret_from_kernel_thread+0x14/0x1c\n\nOnly dereference the ABI point if it is set.\n\nThe GIC page is also included as it is specific to the vDSO.\nAlso move the randomization adjustment into the same conditional.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38718",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: linearize cloned gso packets in sctp_rcv\n\nA cloned head skb still shares these frag skbs in fraglist with the\noriginal head skb. It's not safe to access these frag skbs.\n\nsyzbot reported two use-of-uninitialized-memory bugs caused by this:\n\n  BUG: KMSAN: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998\n   sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331\n   sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122\n   __release_sock+0x1da/0x330 net/core/sock.c:3106\n   release_sock+0x6b/0x250 net/core/sock.c:3660\n   sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360\n   sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885\n   sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031\n   inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:718 [inline]\n\nand\n\n  BUG: KMSAN: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331\n   sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148\n   __release_sock+0x1d3/0x330 net/core/sock.c:3213\n   release_sock+0x6b/0x270 net/core/sock.c:3767\n   sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367\n   sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886\n   sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032\n   inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:712 [inline]\n\nThis patch fixes it by linearizing cloned gso packets in sctp_rcv().",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-38734",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix UAF on smcsk after smc_listen_out()\n\nBPF CI testing report a UAF issue:\n\n  [   16.446633] BUG: kernel NULL pointer dereference, address: 000000000000003  0\n  [   16.447134] #PF: supervisor read access in kernel mod  e\n  [   16.447516] #PF: error_code(0x0000) - not-present pag  e\n  [   16.447878] PGD 0 P4D   0\n  [   16.448063] Oops: Oops: 0000 [#1] PREEMPT SMP NOPT  I\n  [   16.448409] CPU: 0 UID: 0 PID: 9 Comm: kworker/0:1 Tainted: G           OE      6.13.0-rc3-g89e8a75fda73-dirty #4  2\n  [   16.449124] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODUL  E\n  [   16.449502] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/201  4\n  [   16.450201] Workqueue: smc_hs_wq smc_listen_wor  k\n  [   16.450531] RIP: 0010:smc_listen_work+0xc02/0x159  0\n  [   16.452158] RSP: 0018:ffffb5ab40053d98 EFLAGS: 0001024  6\n  [   16.452526] RAX: 0000000000000001 RBX: 0000000000000002 RCX: 000000000000030  0\n  [   16.452994] RDX: 0000000000000280 RSI: 00003513840053f0 RDI: 000000000000000  0\n  [   16.453492] RBP: ffffa097808e3800 R08: ffffa09782dba1e0 R09: 000000000000000  5\n  [   16.453987] R10: 0000000000000000 R11: 0000000000000000 R12: ffffa0978274640  0\n  [   16.454497] R13: 0000000000000000 R14: 0000000000000000 R15: ffffa09782d4092  0\n  [   16.454996] FS:  0000000000000000(0000) GS:ffffa097bbc00000(0000) knlGS:000000000000000  0\n  [   16.455557] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003  3\n  [   16.455961] CR2: 0000000000000030 CR3: 0000000102788004 CR4: 0000000000770ef  0\n  [   16.456459] PKRU: 5555555  4\n  [   16.456654] Call Trace  :\n  [   16.456832]  \u003cTASK  \u003e\n  [   16.456989]  ? __die+0x23/0x7  0\n  [   16.457215]  ? page_fault_oops+0x180/0x4c  0\n  [   16.457508]  ? __lock_acquire+0x3e6/0x249  0\n  [   16.457801]  ? exc_page_fault+0x68/0x20  0\n  [   16.458080]  ? asm_exc_page_fault+0x26/0x3  0\n  [   16.458389]  ? smc_listen_work+0xc02/0x159  0\n  [   16.458689]  ? smc_listen_work+0xc02/0x159  0\n  [   16.458987]  ? lock_is_held_type+0x8f/0x10  0\n  [   16.459284]  process_one_work+0x1ea/0x6d  0\n  [   16.459570]  worker_thread+0x1c3/0x38  0\n  [   16.459839]  ? __pfx_worker_thread+0x10/0x1  0\n  [   16.460144]  kthread+0xe0/0x11  0\n  [   16.460372]  ? __pfx_kthread+0x10/0x1  0\n  [   16.460640]  ret_from_fork+0x31/0x5  0\n  [   16.460896]  ? __pfx_kthread+0x10/0x1  0\n  [   16.461166]  ret_from_fork_asm+0x1a/0x3  0\n  [   16.461453]  \u003c/TASK  \u003e\n  [   16.461616] Modules linked in: bpf_testmod(OE) [last unloaded: bpf_testmod(OE)  ]\n  [   16.462134] CR2: 000000000000003  0\n  [   16.462380] ---[ end trace 0000000000000000 ]---\n  [   16.462710] RIP: 0010:smc_listen_work+0xc02/0x1590\n\nThe direct cause of this issue is that after smc_listen_out_connected(),\nnewclcsock-\u003esk may be NULL since it will releases the smcsk. Therefore,\nif the application closes the socket immediately after accept,\nnewclcsock-\u003esk can be NULL. A possible execution order could be as\nfollows:\n\nsmc_listen_work                                 | userspace\n-----------------------------------------------------------------\nlock_sock(sk)                                   |\nsmc_listen_out_connected()                      |\n| \\- smc_listen_out                             |\n|    | \\- release_sock                          |\n     | |- sk-\u003esk_data_ready()                   |\n                                                | fd = accept();\n                                                | close(fd);\n                                                |  \\- socket-\u003esk = NULL;\n/* newclcsock-\u003esk is NULL now */\nSMC_STAT_SERV_SUCC_INC(sock_net(newclcsock-\u003esk))\n\nSince smc_listen_out_connected() will not fail, simply swapping the order\nof the code can easily fix this issue.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39693",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Avoid a NULL pointer dereference\n\n[WHY]\nAlthough unlikely drm_atomic_get_new_connector_state() or\ndrm_atomic_get_old_connector_state() can return NULL.\n\n[HOW]\nCheck returns before dereference.\n\n(cherry picked from commit 1e5e8d672fec9f2ab352be121be971877bff2af9)",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39711",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: ivsc: Fix crash at shutdown due to missing mei_cldev_disable() calls\n\nBoth the ACE and CSI driver are missing a mei_cldev_disable() call in\ntheir remove() function.\n\nThis causes the mei_cl client to stay part of the mei_device-\u003efile_list\nlist even though its memory is freed by mei_cl_bus_dev_release() calling\nkfree(cldev-\u003ecl).\n\nThis leads to a use-after-free when mei_vsc_remove() runs mei_stop()\nwhich first removes all mei bus devices calling mei_ace_remove() and\nmei_csi_remove() followed by mei_cl_bus_dev_release() and then calls\nmei_cl_all_disconnect() which walks over mei_device-\u003efile_list dereferecing\nthe just freed cldev-\u003ecl.\n\nAnd mei_vsc_remove() it self is run at shutdown because of the\nplatform_device_unregister(tp-\u003epdev) in vsc_tp_shutdown()\n\nWhen building a kernel with KASAN this leads to the following KASAN report:\n\n[ 106.634504] ==================================================================\n[ 106.634623] BUG: KASAN: slab-use-after-free in mei_cl_set_disconnected (drivers/misc/mei/client.c:783) mei\n[ 106.634683] Read of size 4 at addr ffff88819cb62018 by task systemd-shutdow/1\n[ 106.634729]\n[ 106.634767] Tainted: [E]=UNSIGNED_MODULE\n[ 106.634770] Hardware name: Dell Inc. XPS 16 9640/09CK4V, BIOS 1.12.0 02/10/2025\n[ 106.634773] Call Trace:\n[ 106.634777]  \u003cTASK\u003e\n...\n[ 106.634871] kasan_report (mm/kasan/report.c:221 mm/kasan/report.c:636)\n[ 106.634901] mei_cl_set_disconnected (drivers/misc/mei/client.c:783) mei\n[ 106.634921] mei_cl_all_disconnect (drivers/misc/mei/client.c:2165 (discriminator 4)) mei\n[ 106.634941] mei_reset (drivers/misc/mei/init.c:163) mei\n...\n[ 106.635042] mei_stop (drivers/misc/mei/init.c:348) mei\n[ 106.635062] mei_vsc_remove (drivers/misc/mei/mei_dev.h:784 drivers/misc/mei/platform-vsc.c:393) mei_vsc\n[ 106.635066] platform_remove (drivers/base/platform.c:1424)\n\nAdd the missing mei_cldev_disable() calls so that the mei_cl gets removed\nfrom mei_device-\u003efile_list before it is freed to fix this.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39716",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Revise __get_user() to probe user read access\n\nBecause of the way read access support is implemented, read access\ninterruptions are only triggered at privilege levels 2 and 3. The\nkernel executes at privilege level 0, so __get_user() never triggers\na read access interruption (code 26). Thus, it is currently possible\nfor user code to access a read protected address via a system call.\n\nFix this by probing read access rights at privilege level 3 (PRIV_USER)\nand setting __gu_err to -EFAULT (-14) if access isn't allowed.\n\nNote the cmpiclr instruction does a 32-bit compare because COND macro\ndoesn't work inside asm.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39719",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: imu: bno055: fix OOB access of hw_xlate array\n\nFix a potential out-of-bounds array access of the hw_xlate array in\nbno055.c.\n\nIn bno055_get_regmask(), hw_xlate was iterated over the length of the\nvals array instead of the length of the hw_xlate array. In the case of\nbno055_gyr_scale, the vals array is larger than the hw_xlate array,\nso this could result in an out-of-bounds access. In practice, this\nshouldn't happen though because a match should always be found which\nbreaks out of the for loop before it iterates beyond the end of the\nhw_xlate array.\n\nBy adding a new hw_xlate_len field to the bno055_sysfs_attr, we can be\nsure we are iterating over the correct length.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39726",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/ism: fix concurrency management in ism_cmd()\n\nThe s390x ISM device data sheet clearly states that only one\nrequest-response sequence is allowable per ISM function at any point in\ntime.  Unfortunately as of today the s390/ism driver in Linux does not\nhonor that requirement. This patch aims to rectify that.\n\nThis problem was discovered based on Aliaksei's bug report which states\nthat for certain workloads the ISM functions end up entering error state\n(with PEC 2 as seen from the logs) after a while and as a consequence\nconnections handled by the respective function break, and for future\nconnection requests the ISM device is not considered -- given it is in a\ndysfunctional state. During further debugging PEC 3A was observed as\nwell.\n\nA kernel message like\n[ 1211.244319] zpci: 061a:00:00.0: Event 0x2 reports an error for PCI function 0x61a\nis a reliable indicator of the stated function entering error state\nwith PEC 2. Let me also point out that a kernel message like\n[ 1211.244325] zpci: 061a:00:00.0: The ism driver bound to the device does not support error recovery\nis a reliable indicator that the ISM function won't be auto-recovered\nbecause the ISM driver currently lacks support for it.\n\nOn a technical level, without this synchronization, commands (inputs to\nthe FW) may be partially or fully overwritten (corrupted) by another CPU\ntrying to issue commands on the same function. There is hard evidence that\nthis can lead to DMB token values being used as DMB IOVAs, leading to\nPEC 2 PCI events indicating invalid DMA. But this is only one of the\nfailure modes imaginable. In theory even completely losing one command\nand executing another one twice and then trying to interpret the outputs\nas if the command we intended to execute was actually executed and not\nthe other one is also possible.  Frankly, I don't feel confident about\nproviding an exhaustive list of possible consequences.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39767",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: Optimize module load time by optimizing PLT/GOT counting\n\nWhen enabling CONFIG_KASAN, CONFIG_PREEMPT_VOLUNTARY_BUILD and\nCONFIG_PREEMPT_VOLUNTARY at the same time, there will be soft deadlock,\nthe relevant logs are as follows:\n\nrcu: INFO: rcu_sched self-detected stall on CPU\n...\nCall Trace:\n[\u003c900000000024f9e4\u003e] show_stack+0x5c/0x180\n[\u003c90000000002482f4\u003e] dump_stack_lvl+0x94/0xbc\n[\u003c9000000000224544\u003e] rcu_dump_cpu_stacks+0x1fc/0x280\n[\u003c900000000037ac80\u003e] rcu_sched_clock_irq+0x720/0xf88\n[\u003c9000000000396c34\u003e] update_process_times+0xb4/0x150\n[\u003c90000000003b2474\u003e] tick_nohz_handler+0xf4/0x250\n[\u003c9000000000397e28\u003e] __hrtimer_run_queues+0x1d0/0x428\n[\u003c9000000000399b2c\u003e] hrtimer_interrupt+0x214/0x538\n[\u003c9000000000253634\u003e] constant_timer_interrupt+0x64/0x80\n[\u003c9000000000349938\u003e] __handle_irq_event_percpu+0x78/0x1a0\n[\u003c9000000000349a78\u003e] handle_irq_event_percpu+0x18/0x88\n[\u003c9000000000354c00\u003e] handle_percpu_irq+0x90/0xf0\n[\u003c9000000000348c74\u003e] handle_irq_desc+0x94/0xb8\n[\u003c9000000001012b28\u003e] handle_cpu_irq+0x68/0xa0\n[\u003c9000000001def8c0\u003e] handle_loongarch_irq+0x30/0x48\n[\u003c9000000001def958\u003e] do_vint+0x80/0xd0\n[\u003c9000000000268a0c\u003e] kasan_mem_to_shadow.part.0+0x2c/0x2a0\n[\u003c90000000006344f4\u003e] __asan_load8+0x4c/0x120\n[\u003c900000000025c0d0\u003e] module_frob_arch_sections+0x5c8/0x6b8\n[\u003c90000000003895f0\u003e] load_module+0x9e0/0x2958\n[\u003c900000000038b770\u003e] __do_sys_init_module+0x208/0x2d0\n[\u003c9000000001df0c34\u003e] do_syscall+0x94/0x190\n[\u003c900000000024d6fc\u003e] handle_syscall+0xbc/0x158\n\nAfter analysis, this is because the slow speed of loading the amdgpu\nmodule leads to the long time occupation of the cpu and then the soft\ndeadlock.\n\nWhen loading a module, module_frob_arch_sections() tries to figure out\nthe number of PLTs/GOTs that will be needed to handle all the RELAs. It\nwill call the count_max_entries() to find in an out-of-order date which\ncounting algorithm has O(n^2) complexity.\n\nTo make it faster, we sort the relocation list by info and addend. That\nway, to check for a duplicate relocation, it just needs to compare with\nthe previous entry. This reduces the complexity of the algorithm to O(n\n log n), as done in commit d4e0340919fb (\"arm64/module: Optimize module\nload time by optimizing PLT counting\"). This gives sinificant reduction\nin module load time for modules with large number of relocations.\n\nAfter applying this patch, the soft deadlock problem has been solved,\nand the kernel starts normally without \"Call Trace\".\n\nUsing the default configuration to test some modules, the results are as\nfollows:\n\nModule              Size\nip_tables           36K\nfat                 143K\nradeon              2.5MB\namdgpu              16MB\n\nWithout this patch:\nModule              Module load time (ms)\tCount(PLTs/GOTs)\nip_tables           18\t\t\t\t59/6\nfat                 0\t\t\t\t162/14\nradeon              54\t\t\t\t1221/84\namdgpu              1411\t\t\t4525/1098\n\nWith this patch:\nModule              Module load time (ms)\tCount(PLTs/GOTs)\nip_tables           18\t\t\t\t59/6\nfat                 0\t\t\t\t162/14\nradeon              22\t\t\t\t1221/84\namdgpu              45\t\t\t\t4525/1098",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39781",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Drop WARN_ON_ONCE() from flush_cache_vmap\n\nI have observed warning to occassionally trigger.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39794",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nARM: tegra: Use I/O memcpy to write to IRAM\n\nKasan crashes the kernel trying to check boundaries when using the\nnormal memcpy.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39808",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: hid-ntrig: fix unable to handle page fault in ntrig_report_version()\n\nin ntrig_report_version(), hdev parameter passed from hid_probe().\nsending descriptor to /dev/uhid can make hdev-\u003edev.parent-\u003eparent to null\nif hdev-\u003edev.parent-\u003eparent is null, usb_dev has\ninvalid address(0xffffffffffffff58) that hid_to_usb_dev(hdev) returned\nwhen usb_rcvctrlpipe() use usb_dev,it trigger\npage fault error for address(0xffffffffffffff58)\n\nadd null check logic to ntrig_report_version()\nbefore calling hid_to_usb_dev()",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39842",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: prevent release journal inode after journal shutdown\n\nBefore calling ocfs2_delete_osb(), ocfs2_journal_shutdown() has already\nbeen executed in ocfs2_dismount_volume(), so osb-\u003ejournal must be NULL. \nTherefore, the following calltrace will inevitably fail when it reaches\njbd2_journal_release_jbd_inode().\n\nocfs2_dismount_volume()-\u003e\n  ocfs2_delete_osb()-\u003e\n    ocfs2_free_slot_info()-\u003e\n      __ocfs2_free_slot_info()-\u003e\n        evict()-\u003e\n          ocfs2_evict_inode()-\u003e\n            ocfs2_clear_inode()-\u003e\n\t      jbd2_journal_release_jbd_inode(osb-\u003ejournal-\u003ej_journal,\n\nAdding osb-\u003ejournal checks will prevent null-ptr-deref during the above\nexecution path.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39846",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\npcmcia: Fix a NULL pointer dereference in __iodyn_find_io_region()\n\nIn __iodyn_find_io_region(), pcmcia_make_resource() is assigned to\nres and used in pci_bus_alloc_resource(). There is a dereference of res\nin pci_bus_alloc_resource(), which could lead to a NULL pointer\ndereference on failure of pcmcia_make_resource().\n\nFix this bug by adding a check of res.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39861",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: vhci: Prevent use-after-free by removing debugfs files early\n\nMove the creation of debugfs files into a dedicated function, and ensure\nthey are explicitly removed during vhci_release(), before associated\ndata structures are freed.\n\nPreviously, debugfs files such as \"force_suspend\", \"force_wakeup\", and\nothers were created under hdev-\u003edebugfs but not removed in\nvhci_release(). Since vhci_release() frees the backing vhci_data\nstructure, any access to these files after release would result in\nuse-after-free errors.\n\nAlthough hdev-\u003edebugfs is later freed in hci_release_dev(), user can\naccess files after vhci_data is freed but before hdev-\u003edebugfs is\nreleased.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39863",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info work\n\nThe brcmf_btcoex_detach() only shuts down the btcoex timer, if the\nflag timer_on is false. However, the brcmf_btcoex_timerfunc(), which\nruns as timer handler, sets timer_on to false. This creates critical\nrace conditions:\n\n1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc()\nis executing, it may observe timer_on as false and skip the call to\ntimer_shutdown_sync().\n\n2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_info\nworker after the cancel_work_sync() has been executed, resulting in\nuse-after-free bugs.\n\nThe use-after-free bugs occur in two distinct scenarios, depending on\nthe timing of when the brcmf_btcoex_info struct is freed relative to\nthe execution of its worker thread.\n\nScenario 1: Freed before the worker is scheduled\n\nThe brcmf_btcoex_info is deallocated before the worker is scheduled.\nA race condition can occur when schedule_work(\u0026bt_local-\u003ework) is\ncalled after the target memory has been freed. The sequence of events\nis detailed below:\n\nCPU0                           | CPU1\nbrcmf_btcoex_detach            | brcmf_btcoex_timerfunc\n                               |   bt_local-\u003etimer_on = false;\n  if (cfg-\u003ebtcoex-\u003etimer_on)   |\n    ...                        |\n  cancel_work_sync();          |\n  ...                          |\n  kfree(cfg-\u003ebtcoex); // FREE  |\n                               |   schedule_work(\u0026bt_local-\u003ework); // USE\n\nScenario 2: Freed after the worker is scheduled\n\nThe brcmf_btcoex_info is freed after the worker has been scheduled\nbut before or during its execution. In this case, statements within\nthe brcmf_btcoex_handler() â€” such as the container_of macro and\nsubsequent dereferences of the brcmf_btcoex_info object will cause\na use-after-free access. The following timeline illustrates this\nscenario:\n\nCPU0                            | CPU1\nbrcmf_btcoex_detach             | brcmf_btcoex_timerfunc\n                                |   bt_local-\u003etimer_on = false;\n  if (cfg-\u003ebtcoex-\u003etimer_on)    |\n    ...                         |\n  cancel_work_sync();           |\n  ...                           |   schedule_work(); // Reschedule\n                                |\n  kfree(cfg-\u003ebtcoex); // FREE   |   brcmf_btcoex_handler() // Worker\n  /*                            |     btci = container_of(....); // USE\n   The kfree() above could      |     ...\n   also occur at any point      |     btci-\u003e // USE\n   during the worker's execution|\n   */                           |\n\nTo resolve the race conditions, drop the conditional check and call\ntimer_shutdown_sync() directly. It can deactivate the timer reliably,\nregardless of its current state. Once stopped, the timer_on state is\nthen set to false.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Low"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "3.9",
        "Vector": "AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39909",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/damon/lru_sort: avoid divide-by-zero in damon_lru_sort_apply_parameters()\n\nPatch series \"mm/damon: avoid divide-by-zero in DAMON module's parameters\napplication\".\n\nDAMON's RECLAIM and LRU_SORT modules perform no validation on\nuser-configured parameters during application, which may lead to\ndivision-by-zero errors.\n\nAvoid the divide-by-zero by adding validation checks when DAMON modules\nattempt to apply the parameters.\n\n\nThis patch (of 2):\n\nDuring the calculation of 'hot_thres' and 'cold_thres', either\n'sample_interval' or 'aggr_interval' is used as the divisor, which may\nlead to division-by-zero errors.  Fix it by directly returning -EINVAL\nwhen such a case occurs.  Additionally, since 'aggr_interval' is already\nrequired to be set no smaller than 'sample_interval' in damon_set_attrs(),\nonly the case where 'sample_interval' is zero needs to be checked.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39916",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/damon/reclaim: avoid divide-by-zero in damon_reclaim_apply_parameters()\n\nWhen creating a new scheme of DAMON_RECLAIM, the calculation of\n'min_age_region' uses 'aggr_interval' as the divisor, which may lead to\ndivision-by-zero errors.  Fix it by directly returning -EINVAL when such a\ncase occurs.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39934",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: bridge: anx7625: Fix NULL pointer dereference with early IRQ\n\nIf the interrupt occurs before resource initialization is complete, the\ninterrupt handler/worker may access uninitialized data such as the I2C\ntcpc_client device, potentially leading to NULL pointer dereference.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-39952",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: avoid buffer overflow in WID string configuration\n\nFix the following copy overflow warning identified by Smatch checker.\n\n drivers/net/wireless/microchip/wilc1000/wlan_cfg.c:184 wilc_wlan_parse_response_frame()\n        error: '__memcpy()' 'cfg-\u003es[i]-\u003estr' copy overflow (512 vs 65537)\n\nThis patch introduces size check before accessing the memory buffer.\nThe checks are base on the WID type of received data from the firmware.\nFor WID string configuration, the size limit is determined by individual\nelement size in 'struct wilc_cfg_str_vals' that is maintained in 'len' field\nof 'struct wilc_cfg_str'.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-40038",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: SVM: Skip fastpath emulation on VM-Exit if next RIP isn't valid\n\nSkip the WRMSR and HLT fastpaths in SVM's VM-Exit handler if the next RIP\nisn't valid, e.g. because KVM is running with nrips=false.  SVM must\ndecode and emulate to skip the instruction if the CPU doesn't provide the\nnext RIP, and getting the instruction bytes to decode requires reading\nguest memory.  Reading guest memory through the emulator can fault, i.e.\ncan sleep, which is disallowed since the fastpath handlers run with IRQs\ndisabled.\n\n BUG: sleeping function called from invalid context at ./include/linux/uaccess.h:106\n in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 32611, name: qemu\n preempt_count: 1, expected: 0\n INFO: lockdep is turned off.\n irq event stamp: 30580\n hardirqs last  enabled at (30579): [\u003cffffffffc08b2527\u003e] vcpu_run+0x1787/0x1db0 [kvm]\n hardirqs last disabled at (30580): [\u003cffffffffb4f62e32\u003e] __schedule+0x1e2/0xed0\n softirqs last  enabled at (30570): [\u003cffffffffb4247a64\u003e] fpu_swap_kvm_fpstate+0x44/0x210\n softirqs last disabled at (30568): [\u003cffffffffb4247a64\u003e] fpu_swap_kvm_fpstate+0x44/0x210\n CPU: 298 UID: 0 PID: 32611 Comm: qemu Tainted: G     U              6.16.0-smp--e6c618b51cfe-sleep #782 NONE\n Tainted: [U]=USER\n Hardware name: Google Astoria-Turin/astoria, BIOS 0.20241223.2-0 01/17/2025\n Call Trace:\n  \u003cTASK\u003e\n  dump_stack_lvl+0x7d/0xb0\n  __might_resched+0x271/0x290\n  __might_fault+0x28/0x80\n  kvm_vcpu_read_guest_page+0x8d/0xc0 [kvm]\n  kvm_fetch_guest_virt+0x92/0xc0 [kvm]\n  __do_insn_fetch_bytes+0xf3/0x1e0 [kvm]\n  x86_decode_insn+0xd1/0x1010 [kvm]\n  x86_emulate_instruction+0x105/0x810 [kvm]\n  __svm_skip_emulated_instruction+0xc4/0x140 [kvm_amd]\n  handle_fastpath_invd+0xc4/0x1a0 [kvm]\n  vcpu_run+0x11a1/0x1db0 [kvm]\n  kvm_arch_vcpu_ioctl_run+0x5cc/0x730 [kvm]\n  kvm_vcpu_ioctl+0x578/0x6a0 [kvm]\n  __se_sys_ioctl+0x6d/0xb0\n  do_syscall_64+0x8a/0x2c0\n  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n RIP: 0033:0x7f479d57a94b\n  \u003c/TASK\u003e\n\nNote, this is essentially a reapply of commit 5c30e8101e8d (\"KVM: SVM:\nSkip WRMSR fastpath on VM-Exit if next RIP isn't valid\"), but with\ndifferent justification (KVM now grabs SRCU when skipping the instruction\nfor other reasons).",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "6.1",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-40119",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix potential null deref in ext4_mb_init()\n\nIn ext4_mb_init(), ext4_mb_avg_fragment_size_destroy() may be called\nwhen sbi-\u003es_mb_avg_fragment_size remains uninitialized (e.g., if groupinfo\nslab cache allocation fails). Since ext4_mb_avg_fragment_size_destroy()\nlacks null pointer checking, this leads to a null pointer dereference.\n\n==================================================================\nEXT4-fs: no memory for groupinfo slab cache\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 0 P4D 0\nOops: Oops: 0002 [#1] SMP PTI\nCPU:2 UID: 0 PID: 87 Comm:mount Not tainted 6.17.0-rc2 #1134 PREEMPT(none)\nRIP: 0010:_raw_spin_lock_irqsave+0x1b/0x40\nCall Trace:\n \u003cTASK\u003e\n xa_destroy+0x61/0x130\n ext4_mb_init+0x483/0x540\n __ext4_fill_super+0x116d/0x17b0\n ext4_fill_super+0xd3/0x280\n get_tree_bdev_flags+0x132/0x1d0\n vfs_get_tree+0x29/0xd0\n do_new_mount+0x197/0x300\n __x64_sys_mount+0x116/0x150\n do_syscall_64+0x50/0x1c0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n==================================================================\n\nTherefore, add necessary null check to ext4_mb_avg_fragment_size_destroy()\nto prevent this issue. The same fix is also applied to\next4_mb_largest_free_orders_destroy().",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "High"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "7.0",
        "Vector": "AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-40157",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nEDAC/i10nm: Skip DIMM enumeration on a disabled memory controller\n\nWhen loading the i10nm_edac driver on some Intel Granite Rapids servers,\na call trace may appear as follows:\n\n  UBSAN: shift-out-of-bounds in drivers/edac/skx_common.c:453:16\n  shift exponent -66 is negative\n  ...\n  __ubsan_handle_shift_out_of_bounds+0x1e3/0x390\n  skx_get_dimm_info.cold+0x47/0xd40 [skx_edac_common]\n  i10nm_get_dimm_config+0x23e/0x390 [i10nm_edac]\n  skx_register_mci+0x159/0x220 [skx_edac_common]\n  i10nm_init+0xcb0/0x1ff0 [i10nm_edac]\n  ...\n\nThis occurs because some BIOS may disable a memory controller if there\naren't any memory DIMMs populated on this memory controller. The DIMMMTR\nregister of this disabled memory controller contains the invalid value\n~0, resulting in the call trace above.\n\nFix this call trace by skipping DIMM enumeration on a disabled memory\ncontroller.",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "4.4",
        "Vector": "AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-40196",
      "Note": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: quota: create dedicated workqueue for quota_release_work\n\nThere is a kernel panic due to WARN_ONCE when panic_on_warn is set.\n\nThis issue occurs when writeback is triggered due to sync call for an\nopened file(ie, writeback reason is WB_REASON_SYNC). When f2fs balance\nis needed at sync path, flush for quota_release_work is triggered.\nBy default quota_release_work is queued to \"events_unbound\" queue which\ndoes not have WQ_MEM_RECLAIM flag. During f2fs balance \"writeback\"\nworkqueue tries to flush quota_release_work causing kernel panic due to\nMEM_RECLAIM flag mismatch errors.\n\nThis patch creates dedicated workqueue with WQ_MEM_RECLAIM flag\nfor work quota_release_work.\n\n------------[ cut here ]------------\nWARNING: CPU: 4 PID: 14867 at kernel/workqueue.c:3721 check_flush_dependency+0x13c/0x148\nCall trace:\n check_flush_dependency+0x13c/0x148\n __flush_work+0xd0/0x398\n flush_delayed_work+0x44/0x5c\n dquot_writeback_dquots+0x54/0x318\n f2fs_do_quota_sync+0xb8/0x1a8\n f2fs_write_checkpoint+0x3cc/0x99c\n f2fs_gc+0x190/0x750\n f2fs_balance_fs+0x110/0x168\n f2fs_write_single_data_page+0x474/0x7dc\n f2fs_write_data_pages+0x7d0/0xd0c\n do_writepages+0xe0/0x2f4\n __writeback_single_inode+0x44/0x4ac\n writeback_sb_inodes+0x30c/0x538\n wb_writeback+0xf4/0x440\n wb_workfn+0x128/0x5d4\n process_scheduled_works+0x1c4/0x45c\n worker_thread+0x32c/0x3e8\n kthread+0x11c/0x1b0\n ret_from_fork+0x10/0x20\nKernel panic - not syncing: kernel: panic_on_warn set ...",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    },
    {
      "CVE": "CVE-2025-40207",
      "Note": "In the Linux kernel, the following vulnerability has been resolved: media: v4l2-subdev: Fix alloc failure check in v4l2_subdev_call_state_try(). v4l2_subdev_call_state_try() macro allocates a subdev state with __v4l2_subdev_state_alloc(), but does not check the returned value. If __v4l2_subdev_state_alloc fails, it returns an ERR_PTR, and that would cause v4l2_subdev_call_state_try() to crash. Add proper error handling to v4l2_subdev_call_state_try().",
      "ReleaseDate": "2025-11-22",
      "Threats": [
        {
          "Type": "Impact",
          "Severity": "Medium"
        }
      ],
      "ProductStatuses": [
        {
          "Type": "Fixed",
          "ProductID": [
            "openEuler-24.03-LTS"
          ]
        }
      ],
      "CVSSScoreSets": {
        "BaseScore": "5.5",
        "Vector": "AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "Remediations": {
        "Type": "Vendor Fix",
        "Description": "kernel security update",
        "Date": "2025-11-22",
        "URL": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2700"
      }
    }
  ]
}