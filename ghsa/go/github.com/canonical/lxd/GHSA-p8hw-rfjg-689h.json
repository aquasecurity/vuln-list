{
  "Severity": "HIGH",
  "UpdatedAt": "2025-10-02T21:23:46Z",
  "Package": {
    "Ecosystem": "GO",
    "Name": "github.com/canonical/lxd"
  },
  "Advisory": {
    "DatabaseId": 314950,
    "Id": "GSA_kwCzR0hTQS1wOGh3LXJmamctNjg5aM4ABM5G",
    "GhsaId": "GHSA-p8hw-rfjg-689h",
    "References": [
      {
        "Url": "https://github.com/canonical/lxd/security/advisories/GHSA-p8hw-rfjg-689h"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2025-54286"
      },
      {
        "Url": "https://github.com/advisories/GHSA-p8hw-rfjg-689h"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-p8hw-rfjg-689h"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2025-54286"
      }
    ],
    "Description": "### Description\nOIDC authentication uses cookies with the SameSite=Strict attribute, preventing cookies from being sent with requests from other sites. Therefore, CSRF does not occur as long as web services in a Same Site relationship (same eTLD+1) with the origin running LXD-UI are trusted.\n\nHowever, since the SameSite concept does not apply to client certificates, CSRF protection that doesn't rely on the SameSite attribute is necessary.\n\nNote that when using cross-origin fetch API, client certificates are not sent in no-cors mode due to CORS restrictions (according to the WHATWG Fetch specification(https://fetch.spec.whatwg.org/#credentials), client certificates are treated as credentials), making cross-site attacks using fetch API difficult unless CORS settings are vulnerable. However, since LXD's API parses request bodies as JSON even when `Content-Type` is `text/plain` or `application/x-www-form-urlencoded`, CSRF attacks exploiting HTML form submissions are possible.\n\n### Reproduction Steps\n1. Prepare a malicious website controlled by the attacker\n2. Deploy the following HTML form to implement an attack that automatically creates instances when victims visit:\n\nThis exploit code automatically sends a JSON string as text/plain to create an instance when rendered.\n\nNote that for this PoC to work, the specified profile (default) must have a Default instance storage pool configured. \nThis is typically set in the default profile of projects created after storage pool creation.\n\n```html\n\u003chtml\u003e\n\u003cbody\u003e\n\u003cform enctype=\"text/plain\" method=\"POST\" action=\"https://lxd-host:8443/1.0/instances?project=default\u0026target=\" id=\"form\"\u003e\n\u003cinput type=\"hidden\" name='{\"' id=\"input\"\u003e\n\u003cinput type=\"submit\"\u003e\n\u003c/form\u003e\n\u003cscript\u003e\nconst i = document.getElementById('input');\ni.value = `\":123,\"name\":\"poc\",\"type\":\"container\",\"profiles\":[\"default\"], \"source\":{\"alias\":\"24.04\",\"mode\":\"pull\",\"protocol\":\"simplestreams\",\"server\":\"https://cloud-images.ubuntu.com/releases\",\"type\":\"image\"},\"devices\":{},\"config\":{},\"start\":true}`;\ndocument.getElementById('form').submit();\n\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n3. Log in to LXD-UI with a user having permissions to create instances in the project (default) specified in step 2\n4. Access the URL of the HTML file prepared in step 2 and confirm that an instance is created and started\n\n### Risk\nThe attack conditions require that the victim is already connected to LXD using client certificate authentication and that the attacker can lead the victim to a controlled website.\n\nPossible actions through the attack include, depending on the victim's permissions, creating and starting arbitrary instances, and executing arbitrary commands inside containers using cloud-init.\n\n### Countermeasures\nThe most effective countermeasure is to strictly enforce `Content-Type` validation at API endpoints. \nSpecifically, change the implementation to reject requests when `Content-Type` is not `application/json`. With this countermeasure, attackers cannot send proper JSON requests using Simple Requests (HTML form submissions) and must use fetch API with CORS. However, as long as proper CORS settings are implemented, client certificates are not sent with cross-origin fetch API requests, preventing the attack.\n\nAdditionally, implementing CSRF tokens or validating Origin/Referer headers could be considered as countermeasures, but these would create compatibility issues with the LXD command, which is another API client.\n\n### Patches\n\n| LXD Series  | Status |\n| ------------- | ------------- |\n| 6 | Fixed in LXD 6.5  |\n| 5.21 | Fixed in LXD 5.21.4  |\n| 5.0 | Fixed in LXD 5.0.5  |\n| 4.0  | Ignored - No web UI  |\n\n### References\nReported by GMO Flatt Security Inc.",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-10-02T21:23:44Z",
    "Severity": "HIGH",
    "Summary": "Canonical LXD CSRF Vulnerability When Using Client Certificate Authentication with the LXD-UI",
    "UpdatedAt": "2025-10-02T21:23:46Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 8.4,
      "VectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "0.0.0-20250827065555-0494f5d47e41"
      },
      "VulnerableVersionRange": "\u003e= 0.0.0-20220401034332-1e1349e3cbf3, \u003c 0.0.0-20250827065555-0494f5d47e41"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "6.5"
      },
      "VulnerableVersionRange": "\u003e= 6.0, \u003c 6.5"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "5.21.4"
      },
      "VulnerableVersionRange": "\u003e= 5.1, \u003c 5.21.4"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "5.0.5"
      },
      "VulnerableVersionRange": "\u003e= 5.0, \u003c 5.0.5"
    }
  ]
}