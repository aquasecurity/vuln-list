{
  "Severity": "HIGH",
  "UpdatedAt": "2025-09-10T19:51:38Z",
  "Package": {
    "Ecosystem": "PIP",
    "Name": "picklescan"
  },
  "Advisory": {
    "DatabaseId": 311053,
    "Id": "GSA_kwCzR0hTQS1qZ3c0LWNyODQtbXF4Z84ABL8N",
    "GhsaId": "GHSA-jgw4-cr84-mqxg",
    "References": [
      {
        "Url": "https://github.com/mmaitre314/picklescan/security/advisories/GHSA-jgw4-cr84-mqxg"
      },
      {
        "Url": "https://github.com/mmaitre314/picklescan/commit/28a7b4ef753466572bda3313737116eeb9b4e5c5"
      },
      {
        "Url": "https://github.com/advisories/GHSA-jgw4-cr84-mqxg"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-jgw4-cr84-mqxg"
      }
    ],
    "Description": "### Summary\nPicklescan can be bypassed, allowing the detection of malicious pickle files to fail, when a standard pickle file is given a PyTorch-related file extension (e.g., .bin). This occurs because the scanner prioritizes PyTorch file extension checks and errors out when parsing a standard pickle file with such an extension instead of falling back to standard pickle analysis. This vulnerability allows attackers to disguise malicious pickle payloads within files that would otherwise be scanned for pickle-based threats.\n### Details\nThe vulnerability stems from the logic in the scan_bytes function within picklescan/scanner.py, specifically around line 463:[ https://github.com/mmaitre314/picklescan/blob/75e60f2c02f3f1a029362e6f334e1921392dcf60/src/picklescan/scanner.py#L463](https://github.com/mmaitre314/picklescan/blob/75e60f2c02f3f1a029362e6f334e1921392dcf60/src/picklescan/scanner.py#L463)\nThe code first checks if the file extension (file_ext) is in the pytorch_file_extension list. If it is (e.g., .bin), the scan_pytorch function is called. When a standard pickle file is encountered with a PyTorch extension, scan_pytorch will likely fail. Critically, the code then returns an Error without attempting to analyze the file as a standard pickle using scan_pickle_bytes. This prevents the detection of malicious payloads within such files.\n### PoC\n- Download a malicious pickle file with a standard .pkl extension:\nwget \u003chttps://huggingface.co/kzanki/regular_model/resolve/main/model.pkl?download=true\u003e -O model.pkl\n- Scan the file with Picklescan (correct detection):\n/home/davfr/Tests/HF/dangerous_model/model.pkl: dangerous import 'builtins exec' FOUND\n----------- SCAN SUMMARY -----------\nScanned files: 1\nInfected files: 1\nDangerous globals: 1\n\n- Rename the file to use a PyTorch-related extension (e.g., .bin):\ncp model.pkl model.bin\n- Scan the renamed file with Picklescan:\n![Screenshot 2025-06-29 at 9 38 13](https://github.com/user-attachments/assets/29a7886f-2d0e-48ca-832d-9a6699ae09f1)\n\n**Observed Result:** Picklescan fails and reports an error related to PyTorch parsing but does not detect the malicious pickle content.\n**Expected Result**: Picklescan should recognize the file as a standard pickle format despite the .bin extension and scan it accordingly, identifying the malicious content.\n### Impact\n**Severity**: High\n**Affected Users**: Any organization or individual relying on Picklescan to ensure the safety of PyTorch models or other files that might contain embedded pickle objects. This includes users downloading pre-trained models or receiving files that could potentially contain malicious code.\n**Impact Details**: Attackers can craft malicious pickle payloads and disguise them within files using common PyTorch extensions (like .bin, .pt, etc.). These files would then bypass PickleScan's detection mechanism, allowing the malicious code to execute when the file is loaded by a vulnerable application or user.\n**Potential Exploits**: This vulnerability significantly weakens the security provided by PickleScan. It opens the door to various supply chain attacks, where malicious actors could distribute backdoored models through platforms like Hugging Face, PyTorch Hub, or even through direct file sharing. Users trusting PickleScan would be unknowingly exposed to these threats.\n**Recommendations**\nThe most effective solution is to modify the scanning logic to ensure that standard pickle scanning is attempted as a fallback mechanism when PyTorch scanning fails or is not applicable. A suggested approach is:\nAttempt PyTorch Scan: If the file extension matches a known PyTorch extension, attempt to scan it as a PyTorch object.\nFallback to Pickle Scan: Regardless of the success or failure of the PyTorch scan (or if the extension is not a PyTorch extension), always attempt to scan the file as a standard pickle. This ensures that files with misleading extensions are still analyzed for potential pickle-based vulnerabilities.\n### Suggested Patch\n\n```\n--- a/src/picklescan/scanner.py\n+++ b/src/picklescan/scanner.py\n@@ -462,19 +462,28 @@ def scan_bytes(data: IO[bytes], file_id, file_ext: Optional[str] = None) -\u003e Scan\n     if file_ext is not None and file_ext in pytorch_file_extensions:\n         try:\n             return scan_pytorch(data, file_id)\n         except InvalidMagicError as e:\n-            _log.error(f\"ERROR: Invalid magic number for file {e}\")\n-            return ScanResult([], scan_err=True)\n+            _log.warning(f\"PyTorch scan failed for {file_id} with extension {file_ext}: {e}\")\n+            # Don't return error here - continue to other scan methods\n     elif file_ext is not None and file_ext in numpy_file_extensions:\n-        return scan_numpy(data, file_id)\n-    else:\n-        is_zip = zipfile.is_zipfile(data)\n-        data.seek(0)\n-        if is_zip:\n-            return scan_zip_bytes(data, file_id)\n-        elif is_7z_file(data):\n-            return scan_7z_bytes(data, file_id)\n-        else:\n-            return scan_pickle_bytes(data, file_id)\n+        try:\n+            return scan_numpy(data, file_id)\n+        except Exception as e:\n+            _log.warning(f\"NumPy scan failed for {file_id}: {e}\")\n+    \n+    # Always attempt additional format checks as fallback\n+    data.seek(0)  # Reset stream position\n+    is_zip = zipfile.is_zipfile(data)\n+    data.seek(0)\n+    if is_zip:\n+        return scan_zip_bytes(data, file_id)\n+    elif is_7z_file(data):\n+        return scan_7z_bytes(data, file_id)\n+    else:\n+        # FIX: Always attempt pickle scanning as fallback\n+        # This prevents the vulnerability where pickle files with wrong extensions bypass detection\n+        return scan_pickle_bytes(data, file_id)\n```",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-09-10T19:51:37Z",
    "Severity": "HIGH",
    "Summary": "Picklescan Bypass is Possible via File Extension Mismatch",
    "UpdatedAt": "2025-09-10T19:51:38Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 7.8,
      "VectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "0.0.31"
      },
      "VulnerableVersionRange": "\u003c= 0.0.30"
    }
  ]
}