{
  "Severity": "MODERATE",
  "UpdatedAt": "2025-10-30T17:13:18Z",
  "Package": {
    "Ecosystem": "NPM",
    "Name": "tar"
  },
  "Advisory": {
    "DatabaseId": 319661,
    "Id": "GSA_kwCzR0hTQS0yOXhwLTM3MnEteHFwaM4ABOCt",
    "GhsaId": "GHSA-29xp-372q-xqph",
    "References": [
      {
        "Url": "https://github.com/isaacs/node-tar/security/advisories/GHSA-29xp-372q-xqph"
      },
      {
        "Url": "https://github.com/isaacs/node-tar/issues/445"
      },
      {
        "Url": "https://github.com/isaacs/node-tar/pull/446"
      },
      {
        "Url": "https://github.com/isaacs/node-tar/commit/5e1a8e638600d3c3a2969b4de6a6ec44fa8d74c9"
      },
      {
        "Url": "https://github.com/advisories/GHSA-29xp-372q-xqph"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-29xp-372q-xqph"
      }
    ],
    "Description": "### Summary\n\nUsing `.t` (aka `.list`) with `{ sync: true }` to read tar entry contents returns uninitialized memory contents if tar file was changed on disk to a smaller size while being read.\n\n### Details\n\nSee:\n* https://github.com/isaacs/node-tar/issues/445\n* https://github.com/isaacs/node-tar/pull/446\n* Regression happened in https://github.com/isaacs/node-tar/commit/5330eb04bc43014f216e5c271b40d5c00d45224d\n\n### PoC\n\nA:\n```js\nimport * as tar from 'tar'\nimport fs from 'node:fs'\n\nfs.writeFileSync('tar.test.tmp', Buffer.alloc(1*1024))\n\n// from readme\nconst filesAdded = []\ntar.c(\n  {\n    sync: true,\n    file: 'tar.test.tmp.tar',\n    onWriteEntry(entry) {\n      // initially, it's uppercase and 0o644\n      console.log('adding', entry.path, entry.stat.mode.toString(8))\n      // make all the paths lowercase\n      entry.path = entry.path.toLowerCase()\n      // make the entry executable\n      entry.stat.mode = 0o755\n      // in the archive, it's lowercase and 0o755\n      filesAdded.push([entry.path, entry.stat.mode.toString(8)])\n    },\n  },\n  ['./tar.test.tmp'],\n)\n\nconst a = fs.readFileSync('tar.test.tmp.tar')\n\nfor (let i = 0; ; i++){\n  if (i % 10000 === 0) console.log(i)\n  fs.writeFileSync('tar.test.tmp.tar', a)\n  fs.truncateSync('tar.test.tmp.tar', 600)\n}\n```\n\nB (vulnerable):\n```js\nimport * as tar from 'tar'\nimport * as fs from 'fs'\n\nwhile (true) {\n  fs.readFileSync(import.meta.filename)\n  tar.t({\n    sync: true,\n    file: 'tar.test.tmp.tar',\n    onReadEntry: e =\u003e e.on('data', b =\u003e {\n      const a = b.filter(x =\u003e x)\n      if (a.length \u003e 0) console.log(a.toString())\n    })\n  })\n}\n```\n\nRun A and B in parallel on Node.js 22 or \u003e=25.1.0\n\nDumps `B` memory (wait for some time to observe text data)\n\n### Impact\n\nExposes process memory and could result in e.g. unintentionally (aka attacker-controlled) attempting to process sensitive data rather than tar entry contents. Uninitialized memory can contain unrelated file contents, environment variables, passwords, etc.\n\nTo execute, an attacker must reduce the file size to boundary between a tar header and body block, in the time between when the tar archive file size is read via `stat`, and the time when the tar archive parser reaches the entry that is truncated. If the file is truncated at a different boundary, then the uninitialized data will very likely not be a valid tar entry, causing the parser to treat the entry as a damaged archive (that is, throwing an error in `strict: true` mode, or by default, skipping the entry harmlessly).\n\nThis is conditional on using the `sync: true` option to the `tar.list`/`tar.t` method, and the `7.5.1` version specifically. Earlier versions were not affected.\n\nThis is also conditional to attacker being able to truncate (or induce a truncation/replacement) of a file on disk (e.g. in cache).\n\nIf the tar file is initially larger than the `opt.maxReadSize` (16kb by default), then uninitialized memory is not exposed to user code, and instead the program enters an infinite loop, causing a DoS rather than an information disclosure vulnerability.\n\nBy default, `tar.list` does _not_ process tar archive entry body content. So, this is further conditional on the user code doing something with the tar entry file contents in an `onReadEntry` method which would expose the file contents (for example, attempting to parse them in such a way that the uninitialized data could appear in an error message).\n\nOther methods in this library (`tar.extract`, etc.) are not affected by this vulnerability.",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-10-30T17:13:17Z",
    "Severity": "MODERATE",
    "Summary": "node-tar has a race condition leading to uninitialized memory exposure",
    "UpdatedAt": "2025-10-30T17:13:18Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 0,
      "VectorString": ""
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "7.5.2"
      },
      "VulnerableVersionRange": "= 7.5.1"
    }
  ]
}